# Create your views here.
from decimal import Decimal
import hashlib
from rest_framework import viewsets, status
from rest_framework.decorators import api_view, permission_classes
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from .models import MTTB_Users
from .serializers import MTTBUserSerializer

# class MTTBUserViewSet(viewsets.ModelViewSet):
#     """
#     GET    /api/users/         → list
#     POST   /api/users/         → create
#     GET    /api/users/{pk}/    → retrieve
#     PUT    /api/users/{pk}/    → update
#     PATCH  /api/users/{pk}/    → partial update
#     DELETE /api/users/{pk}/    → destroy
#     """
#     queryset = MTTB_Users.objects.all()
#     serializer_class = MTTBUserSerializer

#     # allow unauthenticated user to create an account
#     def get_permissions(self):
#         if self.request.method == "POST":
#             return [AllowAny()]
#         return super().get_permissions()

def _hash(raw_password):
    return hashlib.md5(raw_password.encode("utf-8")).hexdigest()
from rest_framework import viewsets
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework import status
from rest_framework.parsers import MultiPartParser, FormParser, JSONParser
from django.utils import timezone
from .models import MTTB_Users
from .serializers import MTTBUserSerializer
class MTTBUserViewSet(viewsets.ModelViewSet):
    serializer_class = MTTBUserSerializer
    parser_classes = [JSONParser, MultiPartParser, FormParser]

    def get_permissions(self):
        # Allow open signup
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    def get_queryset(self):
        # start from all users
        qs = MTTB_Users.objects.select_related('div_id', 'Role_ID').all()

        params = self.request.query_params

        # filter by division if provided
        div = params.get('div_id')
        if div:
            qs = qs.filter(div_id__div_id=div)

        # filter by role if provided
        role = params.get('role_id')
        if role:
            qs = qs.filter(Role_ID__role_id=role)

        return qs.order_by('user_id')

    def perform_create(self, serializer):
        maker = self.request.user if self.request.user.is_authenticated else None
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        checker = self.request.user if self.request.user.is_authenticated else None
        serializer.save(
            Checker_Id=checker,
            Checker_DT_Stamp=timezone.now()
        )
    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        users = self.get_object()

        if users.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        users.Auth_Status = 'A'
        users.Once_Status = 'Y'
        users.Record_Status = 'O'
        users.Checker_Id = request.user
        users.Checker_DT_Stamp = timezone.now()
        users.save()

        serializer = self.get_serializer(users)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        users = self.get_object()

        if users.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'U', Record_Status = 'C'
        users.Auth_Status = 'U'
        users.Record_Status = 'C'
        users.Checker_Id = request.user
        users.Checker_DT_Stamp = timezone.now()
        users.save()

        serializer = self.get_serializer(users)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })

# from rest_framework_simplejwt.tokens import RefreshToken
# from .models import MTTB_USER_ACCESS_LOG
# from rest_framework_simplejwt.settings import api_settings
# from django.utils import timezone

# def get_client_ip(request):
#     xff = request.META.get('HTTP_X_FORWARDED_FOR')
#     if xff:
#         return xff.split(',')[0].strip()
#     return request.META.get('REMOTE_ADDR')

# @api_view(["POST"])
# @permission_classes([AllowAny])
# def login_view(request):
#     uid = request.data.get("user_name")
#     pwd = request.data.get("user_password")
#     if not uid or not pwd:
#         # log failure
#         MTTB_USER_ACCESS_LOG.objects.create(
#             user_id=None,
#             session_id=None,
#             ip_address=get_client_ip(request),
#             user_agent=request.META.get('HTTP_USER_AGENT'),
#             login_status='F',        # F = failed
#             remarks='Missing credentials'
#         )
#         return Response(
#             {"error": "User_Name and User_Password required"},
#             status=status.HTTP_400_BAD_REQUEST,
#         )

#     hashed = _hash(pwd)
#     try:
#         user = MTTB_Users.objects.get(
#             user_name=uid, user_password=hashed
#         )
#     except MTTB_Users.DoesNotExist:
#         # log failure
#         MTTB_USER_ACCESS_LOG.objects.create(
#             user_id=None,
#             session_id=None,
#             ip_address=get_client_ip(request),
#             user_agent=request.META.get('HTTP_USER_AGENT'),
#             login_status='F',
#             remarks='Invalid credentials'
#         )
#         return Response(
#             {"error": "Invalid credentials"},
#             status=status.HTTP_401_UNAUTHORIZED,
#         )

#     # 1) Create tokens
#     refresh = RefreshToken.for_user(user)
#     access  = refresh.access_token

#     # 2) Log the successful login
#     # Grab the JTI (unique token ID) for session tracking
#     jti = refresh.get(api_settings.JTI_CLAIM)
#     MTTB_USER_ACCESS_LOG.objects.create(
#         user_id=user,
#         session_id=jti,
#         ip_address=get_client_ip(request),
#         user_agent=request.META.get('HTTP_USER_AGENT'),
#         login_status='S'   # S = success
#     )

#     # 3) Serialize your user data
#     data = MTTBUserSerializer(user).data

#     # 4) Return tokens + user info
#     return Response({
#         "message": "Login successful",
#         "refresh": str(refresh),
#         "access": str(access),
#         "user": data
#     })



from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework import status
from .models import MTTB_USER_ACCESS_LOG, MTTB_Users
from .serializers import MTTBUserSerializer
from .tokens import CustomRefreshToken
from rest_framework_simplejwt.settings import api_settings

def get_client_ip(request):
    xff = request.META.get('HTTP_X_FORWARDED_FOR')
    if xff:
        return xff.split(',')[0].strip()
    return request.META.get('REMOTE_ADDR')

@api_view(["POST"])
@permission_classes([AllowAny])
def login_view(request):
    uid = request.data.get("user_name")
    pwd = request.data.get("user_password")
    if not uid or not pwd:
        # log failure
        MTTB_USER_ACCESS_LOG.objects.create(
            user_id=None,
            session_id=None,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT'),
            login_status='F',        # F = failed
            remarks='Missing credentials'
        )
        return Response(
            {"error": "User_Name and User_Password required"},
            status=status.HTTP_400_BAD_REQUEST,
        )

    hashed = _hash(pwd)
    try:
        user = MTTB_Users.objects.get(
            user_name=uid, user_password=hashed
        )
    except MTTB_Users.DoesNotExist:
        # log failure
        MTTB_USER_ACCESS_LOG.objects.create(
            user_id=None,
            session_id=None,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT'),
            login_status='F',
            remarks='Invalid credentials'
        )
        return Response(
            {"error": "Invalid credentials"},
            status=status.HTTP_401_UNAUTHORIZED,
        )

    # 1) Create tokens using CustomRefreshToken
    # refresh = RefreshToken.for_user(user)
    # access  = refresh.access_token
    refresh = CustomRefreshToken.for_user(user)
    access = refresh.access_token

    # 2) Log the successful login
    # Grab the JTI (unique token ID) for session tracking
    jti = refresh[api_settings.JTI_CLAIM]
    MTTB_USER_ACCESS_LOG.objects.create(
        user_id=user,
        session_id=jti,
        ip_address=get_client_ip(request),
        user_agent=request.META.get('HTTP_USER_AGENT'),
        login_status='S'   # S = success
    )

    # 3) Serialize your user data
    data = MTTBUserSerializer(user).data

    # 4) Return tokens + user info
    return Response({
        "message": "Login successful",
        "refresh": str(refresh),
        "access": str(access),
        "user": data
    })

from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from rest_framework_simplejwt.tokens import RefreshToken, TokenError
from django.utils import timezone
from .models import MTTB_USER_ACCESS_LOG
from rest_framework_simplejwt.tokens import RefreshToken, TokenError
from rest_framework_simplejwt.settings import api_settings
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from django.utils import timezone
from .models import MTTB_USER_ACCESS_LOG

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def logout_view(request):
    """
    POST /api/logout/
    Body: { "refresh": "<refresh_token>" }
    """
    refresh_token = request.data.get("refresh")
    if not refresh_token:
        return Response(
            {"error": "Refresh token required"},
            status=status.HTTP_400_BAD_REQUEST,
        )

    try:
        token = RefreshToken(refresh_token)
    except TokenError:
        return Response(
            {"error": "Invalid refresh token"},
            status=status.HTTP_400_BAD_REQUEST,
        )

    # Extract the JTI claim
    jti = token[api_settings.JTI_CLAIM]

    # Mark the logout in the access log
    try:
        log = MTTB_USER_ACCESS_LOG.objects.get(
            session_id=jti,
            logout_datetime__isnull=True
        )
        log.logout_datetime = timezone.now()
        log.logout_type     = 'U'  # U = user-initiated logout
        log.save()
    except MTTB_USER_ACCESS_LOG.DoesNotExist:
        # No open session found; ignore
        pass

    return Response({"message": "Logged out"}, status=status.HTTP_200_OK)


from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from .models import MTTB_USER_ACCESS_LOG, MTTB_USER_ACTIVITY_LOG
from .serializers import UserAccessLogSerializer, UserActivityLogSerializer

class UserAccessLogViewSet(viewsets.ModelViewSet):
    """
    CRUD for user access logs (login/logout events).
    """
    queryset = MTTB_USER_ACCESS_LOG.objects.select_related('user_id').all().order_by('-login_datetime')
    serializer_class = UserAccessLogSerializer
    permission_classes = [IsAuthenticated]

class UserActivityLogViewSet(viewsets.ModelViewSet):
    """
    CRUD for user activity logs (detailed actions).
    """
    queryset = MTTB_USER_ACTIVITY_LOG.objects.select_related('user_id').all().order_by('-activity_datetime')
    serializer_class = UserActivityLogSerializer
    permission_classes = [IsAuthenticated]

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.response import Response
from .models import MTTB_Divisions
from .serializers import MTTBDivisionSerializer
from django.utils import timezone
from rest_framework_simplejwt.authentication import JWTAuthentication


class MTTBDivisionViewSet(viewsets.ModelViewSet):
    """
    Provides list, create, retrieve, update and destroy for Divisions.
    """
    queryset = MTTB_Divisions.objects.all().order_by('div_id')
    serializer_class = MTTBDivisionSerializer

    def get_permissions(self):
        # Allow anyone to create new divisions (POST), but require auth for others
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]
    def get_authenticators(self):
        # debug which authenticators are being used
        print("Authenticators:", self.authentication_classes)
        return super().get_authenticators()

    def perform_create(self, serializer):
        # Automatically stamp the maker and date
        maker = None
        if self.request.user.is_authenticated:
            maker = self.request.user
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now(),
        )
        

    def perform_update(self, serializer):
        checker = self.request.user if self.request.user.is_authenticated else None
        # set Checker_Id and Checker_DT_Stamp
        serializer.save(
            Checker_Id=checker,
            Checker_DT_Stamp=timezone.now()
        )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        
        if obj.record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.record_Status = 'O'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.record_Status = 'C'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Once_Status = 'Y'
        journal_entry.record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'U', Record_Status = 'C'
        journal_entry.Auth_Status = 'U'
        journal_entry.record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })

    
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated, AllowAny
from django.utils import timezone
from .models import MTTB_Role_Master
from .serializers import MTTBRoleSerializer

class MTTBRoleViewSet(viewsets.ModelViewSet):
    """
    Provides CRUD for Role_Master.
    """
    queryset = MTTB_Role_Master.objects.all().order_by('role_id')
    serializer_class = MTTBRoleSerializer

    def get_permissions(self):
        # Allow open creation, require auth for all other actions
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    def perform_create(self, serializer):
        # Stamp maker and timestamp
        maker = self.request.user if self.request.user.is_authenticated else None
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now(),
        )

    def perform_update(self, serializer):
        checker = self.request.user if self.request.user.is_authenticated else None
        # set Checker_Id and Checker_DT_Stamp
        serializer.save(
            Checker_Id=checker,
            Checker_DT_Stamp=timezone.now()
        )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.record_Status = 'O'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.record_Status = 'C'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Once_Status = 'Y'
        journal_entry.record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'U', Record_Status = 'C'
        journal_entry.Auth_Status = 'U'
        journal_entry.record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })



from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from .models import MTTB_Role_Detail
from .serializers import RoleDetailSerializer

# class MTTBRoleDetailViewSet(viewsets.ModelViewSet):
#     """
#     CRUD for Role_Detail records, with optional filtering by role_id and/or sub_menu_id via query params.
#     """
#     serializer_class = RoleDetailSerializer

#     def create(self, request, *args, **kwargs):
#         role_id = request.data.get('role_id')
#         sub_menu_id = request.data.get('sub_menu_id')

#         if MTTB_Role_Detail.objects.filter(role_id=role_id, sub_menu_id=sub_menu_id).exists():
#             return Response(
#                 {"detail": "This role_id and sub_menu_id combination already exists."},
#                 status=status.HTTP_400_BAD_REQUEST
#             )
#         return super().create(request, *args, **kwargs)

#     @action(detail=False, methods=['get'], url_path='single')
#     def get_single(self, request):
#         role_id = request.query_params.get('role_id')
#         sub_menu_id = request.query_params.get('sub_menu_id')

#         if not role_id or not sub_menu_id:
#             return Response(
#                 {'detail': 'Both role_id and sub_menu_id are required.'}, 
#                 status=status.HTTP_400_BAD_REQUEST
#             )

#         try:
#             obj = MTTB_Role_Detail.objects.select_related('sub_menu_id', 'sub_menu_id__menu_id').get(
#                 role_id=role_id, sub_menu_id=sub_menu_id
#             )
#             serializer = self.get_serializer(obj)
#             return Response(serializer.data)
#         except MTTB_Role_Detail.DoesNotExist:
#             return Response(
#                 {'detail': 'Role detail not found.'}, 
#                 status=status.HTTP_404_NOT_FOUND
#             )
#         except Exception as e:
#             return Response(
#                 {'detail': f'Error retrieving role detail: {str(e)}'}, 
#                 status=status.HTTP_500_INTERNAL_SERVER_ERROR
#             )

#     def get_permissions(self):
#         if self.request.method == 'POST':
#             return [AllowAny()]
#         return [IsAuthenticated()]

#     def get_queryset(self):
#         qs = MTTB_Role_Detail.objects.select_related('sub_menu_id', 'sub_menu_id__menu_id').all().order_by('role_id', 'sub_menu_id')
#         params = self.request.query_params
        
#         # Filter parameters
#         role_id = params.get('role_id')
#         sub_menu_id = params.get('sub_menu_id')
#         menu_id = params.get('menu_id')  # Filter by main menu
#         module_id = params.get('module_id') or params.get('module_Id')  # Accept both 'module_id' and 'module_Id'
#         auth_status = params.get('Auth_Status')
#         record_status = params.get('Record_Status')

#         # Apply filters
#         if role_id and sub_menu_id:
#             qs = qs.filter(role_id=role_id, sub_menu_id=sub_menu_id)
#         elif role_id:
#             qs = qs.filter(role_id=role_id)
#         elif sub_menu_id:
#             qs = qs.filter(sub_menu_id=sub_menu_id)
        
#         if menu_id:
#             qs = qs.filter(sub_menu_id__menu_id_id=menu_id)
#         if module_id:
#             qs = qs.filter(sub_menu_id__menu_id__module_Id_id=module_id)
#         if auth_status:
#             qs = qs.filter(Auth_Status=auth_status)
#         if record_status:
#             qs = qs.filter(Record_Status=record_status)

#         return qs
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from django.db.models import Q, F
from .models import MTTB_Role_Detail, MTTB_Role_Master, STTB_ModulesInfo, MTTB_MAIN_MENU, MTTB_SUB_MENU
from .serializers import RoleDetailSerializer

class MTTBRoleDetailViewSet(viewsets.ModelViewSet):
    """
    CRUD for Role_Detail records, with optional filtering by role_id and/or sub_menu_id via query params.
    """
    serializer_class = RoleDetailSerializer

    def create(self, request, *args, **kwargs):
        role_id = request.data.get('role_id')
        sub_menu_id = request.data.get('sub_menu_id')

        if MTTB_Role_Detail.objects.filter(role_id=role_id, sub_menu_id=sub_menu_id).exists():
            return Response(
                {"detail": "This role_id and sub_menu_id combination already exists."},
                status=status.HTTP_400_BAD_REQUEST
            )
        return super().create(request, *args, **kwargs)

    @action(detail=False, methods=['get'], url_path='single')
    def get_single(self, request):
        role_id = request.query_params.get('role_id')
        sub_menu_id = request.query_params.get('sub_menu_id')

        if not role_id or not sub_menu_id:
            return Response(
                {'detail': 'Both role_id and sub_menu_id are required.'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            obj = MTTB_Role_Detail.objects.select_related('sub_menu_id', 'sub_menu_id__menu_id').get(
                role_id=role_id, sub_menu_id=sub_menu_id
            )
            serializer = self.get_serializer(obj)
            return Response(serializer.data)
        except MTTB_Role_Detail.DoesNotExist:
            return Response(
                {'detail': 'Role detail not found.'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {'detail': f'Error retrieving role detail: {str(e)}'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    def get_permissions(self):
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    def get_queryset(self):
        qs = MTTB_Role_Detail.objects.select_related('sub_menu_id', 'sub_menu_id__menu_id').all().order_by('role_id', 'sub_menu_id')
        params = self.request.query_params
        
        # Filter parameters
        role_id = params.get('role_id')
        sub_menu_id = params.get('sub_menu_id')
        menu_id = params.get('menu_id')  # Filter by main menu
        module_id = params.get('module_Id')  # Filter by module
        
        # Apply filters
        if role_id and sub_menu_id:
            qs = qs.filter(role_id=role_id, sub_menu_id=sub_menu_id)
        elif role_id:
            qs = qs.filter(role_id=role_id)
        elif sub_menu_id:
            qs = qs.filter(sub_menu_id=sub_menu_id)
        
        if menu_id:
            qs = qs.filter(sub_menu_id__menu_id_id=menu_id)
        if module_id:
            qs = qs.filter(sub_menu_id__menu_id__module_Id_id=module_id)

        return qs

    @action(detail=False, methods=['put'], url_path='update')
    def update_role_detail(self, request):
        role_id = request.query_params.get('role_id')
        sub_menu_id = request.query_params.get('sub_menu_id')

        if not role_id or not sub_menu_id:
            return Response(
                {'detail': 'Both role_id and sub_menu_id are required.'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            obj = MTTB_Role_Detail.objects.get(role_id=role_id, sub_menu_id=sub_menu_id)
            serializer = self.get_serializer(obj, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                return Response(serializer.data)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except MTTB_Role_Detail.DoesNotExist:
            return Response(
                {'detail': 'Role detail not found.'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            return Response(
                {'detail': f'Error updating role detail: {str(e)}'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
        
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})


@api_view(["DELETE"])
@permission_classes([IsAuthenticated])
def roledetail_delete(request):
    role_id = request.GET.get('role_id')
    sub_menu_id = request.GET.get('sub_menu_id')
    try:
        obj = MTTB_Role_Detail.objects.get(role_id=role_id, sub_menu_id=sub_menu_id)
        obj.delete()
        return Response({"detail": "Role detail deleted successfully."}, status=status.HTTP_204_NO_CONTENT)
    except MTTB_Role_Detail.DoesNotExist:
        return Response({"detail": "Role detail not found."}, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        return Response({"detail": f"Error deleting role detail: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
# Function Loop Sidebar Menu

from collections import OrderedDict
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from django.shortcuts import get_object_or_404

from .models import (
    MTTB_Users,
    MTTB_Role_Detail,
    MTTB_SUB_MENU,
    MTTB_MAIN_MENU,
    STTB_ModulesInfo,
)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def sidebar_for_user(request, user_id):
    """
    GET /api/users/{user_id}/sidebar/
    Returns modules → main menus → sub menus with permissions.
    """
    # 1) Load user & role
    user = get_object_or_404(MTTB_Users, user_id=user_id)
    role = user.Role_ID

    if not role:
        return Response([])  # no role, no sidebar

    # 2) Fetch all role_detail for this role, with joins down to module
    details = (
        MTTB_Role_Detail.objects
          .filter(role_id=role, Record_Status='O')
          .select_related(
              'sub_menu_id',
              'sub_menu_id__menu_id',
              'sub_menu_id__menu_id__module_Id'
          )
    )

    # 3) Build nested dict: module → main_menu → sub_menu
    modules = OrderedDict()
    for det in details:
        sub   = det.sub_menu_id
        main  = sub.menu_id if sub else None
        mod   = main.module_Id if main else None

        # Ensure all related records have Record_Status = 'O'
        if not (sub and main and mod):
            continue
        if sub.Record_Status != 'O' or main.Record_Status != 'O' or mod.Record_Status != 'O':
            continue

        # Module level
        mod_key = mod.module_Id
        if mod_key not in modules:
            modules[mod_key] = {
                'module_Id':      mod.module_Id,
                'module_name_la': mod.module_name_la,
                'module_name_en': mod.module_name_en,
                'module_icon':    mod.module_icon,
                'module_order':   mod.module_order,
                'Record_Status': mod.Record_Status,
                'main_menus':     OrderedDict()
            }

        # Main menu level
        mm_key = main.menu_id
        mm_group = modules[mod_key]['main_menus']
        if mm_key not in mm_group:
            mm_group[mm_key] = {
                'menu_id':      main.menu_id,
                'menu_name_la': main.menu_name_la,
                'menu_name_en': main.menu_name_en,
                'menu_icon':    main.menu_icon,
                'menu_order':   main.menu_order,
                'Record_Status': main.Record_Status,
                'sub_menus':    OrderedDict()
            }

        # Sub menu level
        sm_key = sub.sub_menu_id
        sm_group = mm_group[mm_key]['sub_menus']
        if sm_key not in sm_group:
            sm_group[sm_key] = {
                'sub_menu_id':      sub.sub_menu_id,
                'sub_menu_name_la': sub.sub_menu_name_la,
                'sub_menu_name_en': sub.sub_menu_name_en,
                'sub_menu_icon':    sub.sub_menu_icon,
                'sub_menu_order':   sub.sub_menu_order,
                'sub_menu_urls':    sub.sub_menu_urls,
                'Record_Status':        sub.Record_Status,
                'permissions': {
                    'new':    det.New_Detail,
                    'delete': det.Del_Detail,
                    'edit':   det.Edit_Detail,
                    'auth':   det.Auth_Detail,
                    'view':   det.View_Detail,
                }
            }

    # 4) Convert sub-dicts to lists
    result = []
    for mod in modules.values():
        mm_list = []
        for mm in mod['main_menus'].values():
            sm_list = list(mm['sub_menus'].values())
            mm['sub_menus'] = sm_list
            mm_list.append(mm)
        mod['main_menus'] = mm_list
        result.append(mod)

    return Response(result)

from collections import OrderedDict
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from django.shortcuts import get_object_or_404

from .models import (
    MTTB_Role_Master,
    MTTB_Role_Detail,
    MTTB_SUB_MENU,
    MTTB_MAIN_MENU,
    STTB_ModulesInfo,
)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def role_sidebar(request, role_id=None):
    """
    GET /api/role/<role_id>/sidebar/
    Returns modules → main menus → sub menus with permissions.
    """
    # 1) Initialize query based on role_id
    if role_id:
        role = get_object_or_404(MTTB_Role_Master, role_id=role_id)
        details = (
            MTTB_Role_Detail.objects
            .filter(role_id=role)
            .select_related(
                'sub_menu_id',
                'sub_menu_id__menu_id',
                'sub_menu_id__menu_id__module_Id'
            )
            .order_by(
                'sub_menu_id__menu_id__module_Id__module_order',
                'sub_menu_id__menu_id__menu_order',
                'sub_menu_id__sub_menu_order'
            )
        )
    else:
        details = (
            MTTB_Role_Detail.objects
            .select_related(
                'sub_menu_id',
                'sub_menu_id__menu_id',
                'sub_menu_id__menu_id__module_Id'
            )
            .order_by(
                'sub_menu_id__menu_id__module_Id__module_order',
                'sub_menu_id__menu_id__menu_order',
                'sub_menu_id__sub_menu_order'
            )
        )

    # 2) Group into nested dicts
    modules = OrderedDict()
    for det in details:
        sub = det.sub_menu_id
        main = sub.menu_id
        mod = main.module_Id

    # check Record_Status = 'O' 
        if not (sub and main and mod):
            continue
        if mod.Record_Status != 'O':
            continue
        if main.Record_Status != 'O':
            continue
        if sub.Record_Status != 'O':
            continue

        # Module level
        if mod.module_Id not in modules:
            modules[mod.module_Id] = {
                'module_Id':      mod.module_Id,
                'module_name_la': mod.module_name_la,
                'module_name_en': mod.module_name_en,
                'module_icon':    mod.module_icon,
                'module_order':   mod.module_order,
                'Record_Status':      mod.Record_Status,
                'main_menus':     OrderedDict()
            }
        mm_group = modules[mod.module_Id]['main_menus']

        # Main-menu level
        if main.menu_id not in mm_group:
            mm_group[main.menu_id] = {
                'menu_id':      main.menu_id,
                'menu_name_la': main.menu_name_la,
                'menu_name_en': main.menu_name_en,
                'menu_icon':    main.menu_icon,
                'menu_order':   main.menu_order,
                'Record_Status':    main.Record_Status,
                'sub_menus':    OrderedDict()
            }
        sm_group = mm_group[main.menu_id]['sub_menus']

        # Sub-menu level
        if sub.sub_menu_id not in sm_group:
            sm_group[sub.sub_menu_id] = {
                'sub_menu_id':      sub.sub_menu_id,
                'sub_menu_name_la': sub.sub_menu_name_la,
                'sub_menu_name_en': sub.sub_menu_name_en,
                'sub_menu_icon':    sub.sub_menu_icon,
                'sub_menu_order':   sub.sub_menu_order,
                'sub_menu_urls':    sub.sub_menu_urls,
                'Record_Status':        sub.Record_Status,
                'permissions': {
                    'new':    det.New_Detail,
                    'delete': det.Del_Detail,
                    'edit':   det.Edit_Detail,
                    'auth':   det.Auth_Detail,
                    'view':   det.View_Detail
                }
            }

    # 3) Convert nested OrderedDicts to lists
    sidebar = []
    for mod in modules.values():
        main_menus = []
        for mm in mod['main_menus'].values():
            mm['sub_menus'] = list(mm['sub_menus'].values())
            main_menus.append(mm)
        mod['main_menus'] = main_menus
        sidebar.append(mod)

    return Response(sidebar, status=status.HTTP_200_OK)


from collections import OrderedDict
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

from .models import (
    STTB_ModulesInfo,
    MTTB_MAIN_MENU,
    MTTB_SUB_MENU,
    MTTB_Function_Desc,
)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def AllModule(request):
    """
    GET /api/modules/all/
    Returns all modules -> main menus -> sub menus -> functions.
    Only includes active records, ordered by their respective order fields.
    """
    # 1) Fetch all active modules
    modules = (
        STTB_ModulesInfo.objects
        .filter(Record_Status='O')
        .order_by('module_order')
    )

    # 2) Initialize response structure
    result = []

    # 3) Loop through modules
    for mod in modules:
        module_data = {
            'module_Id': mod.module_Id,
            'module_name_la': mod.module_name_la,
            'module_name_en': mod.module_name_en,
            'module_icon': mod.module_icon,
            'module_order': mod.module_order,
            'Record_Status': mod.Record_Status,
            'main_menus': []
        }

        # 4) Fetch active main menus for this module
        main_menus = (
            MTTB_MAIN_MENU.objects
            .filter(module_Id=mod, Record_Status='O')
            .order_by('menu_order')
        )

        # 5) Loop through main menus
        for main in main_menus:
            main_menu_data = {
                'menu_id': main.menu_id,
                'menu_name_la': main.menu_name_la,
                'menu_name_en': main.menu_name_en,
                'menu_icon': main.menu_icon,
                'menu_order': main.menu_order,
                'Record_Status': main.Record_Status,
                'sub_menus': []
            }

            # 6) Fetch active sub-menus for this main menu
            sub_menus = (
                MTTB_SUB_MENU.objects
                .filter(menu_id=main, Record_Status='O')
                .order_by('sub_menu_order')
            )

            # 7) Loop through sub-menus
            for sub in sub_menus:
                sub_menu_data = {
                    'sub_menu_id': sub.sub_menu_id,
                    'sub_menu_name_la': sub.sub_menu_name_la,
                    'sub_menu_name_en': sub.sub_menu_name_en,
                    'sub_menu_icon': sub.sub_menu_icon,
                    'sub_menu_order': sub.sub_menu_order,
                    'sub_menu_urls': sub.sub_menu_urls,
                    'Record_Status': sub.Record_Status,
                    'functions': []
                }

                # 8) Fetch active functions for this sub-menu
                functions = (
                    MTTB_Function_Desc.objects
                    .filter(Record_Status='O')
                    .order_by('function_order')
                )

                # 9) Loop through functions
                for func in functions:
                    function_data = {
                        'function_id': func.function_id,
                        'description_la': func.description_la,
                        'description_en': func.description_en,
                        'function_order': func.function_order,
                        'Record_Status': func.Record_Status
                    }
                    sub_menu_data['functions'].append(function_data)

                main_menu_data['sub_menus'].append(sub_menu_data)

            module_data['main_menus'].append(main_menu_data)

        result.append(module_data)

    return Response(result, status=status.HTTP_200_OK)

from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated, AllowAny
from .models import (
    STTB_ModulesInfo,
    MTTB_MAIN_MENU,
    MTTB_SUB_MENU,
    MTTB_Function_Desc,
)
from .serializers import (
    ModulesInfoSerializer,
    MainMenuSerializer,
    SubMenuSerializer,
    FunctionDescSerializer,
)

class ModulesInfoViewSet(viewsets.ModelViewSet):
    queryset = STTB_ModulesInfo.objects.all().order_by('module_order')
    serializer_class = ModulesInfoSerializer
    permission_classes = [IsAuthenticated]

    def perform_create(self, serializer):
        user = self.request.user
        user_id = getattr(user, 'user_id', None)  # ปรับให้เข้ากับ user model ของคุณ
        serializer.save(
            Maker_Id=user_id,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        user_id = getattr(user, 'user_id', None)
        serializer.save(
            Checker_Id=user_id,
            Checker_DT_Stamp=timezone.now()
    )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'O'
        obj.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Once_Status = 'Y'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'U', Record_Status = 'C'
        journal_entry.Auth_Status = 'U'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })

class MainMenuViewSet(viewsets.ModelViewSet):
    serializer_class = MainMenuSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = MTTB_MAIN_MENU.objects.select_related('module_Id').all().order_by('menu_order')
        module_id = self.request.query_params.get('module_Id')
        if module_id:
            queryset = queryset.filter(module_Id=module_id) 
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        user_id = getattr(user, 'user_id', None)  # ปรับให้เข้ากับ user model ของคุณ
        serializer.save(
            Maker_Id=user_id,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        user_id = getattr(user, 'user_id', None)
        serializer.save(
            Checker_Id=user_id,
            Checker_DT_Stamp=timezone.now()
        )
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'O'
        obj.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Once_Status = 'Y'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'U', Record_Status = 'C'
        journal_entry.Auth_Status = 'U'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })


class SubMenuViewSet(viewsets.ModelViewSet):
    serializer_class = SubMenuSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = MTTB_SUB_MENU.objects.select_related('menu_id').all().order_by('menu_id','sub_menu_order')
        menu_id = self.request.query_params.get('menu_id')
        if menu_id:
            queryset = queryset.filter(menu_id=menu_id) 
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        user_id = getattr(user, 'user_id', None)  # ปรับให้เข้ากับ user model ของคุณ
        serializer.save(
            Maker_Id=user_id,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        user_id = getattr(user, 'user_id', None)
        serializer.save(
            Checker_Id=user_id,
            Checker_DT_Stamp=timezone.now()
        )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'O'
        obj.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Once_Status = 'Y'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'U', Record_Status = 'C'
        journal_entry.Auth_Status = 'U'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None) or str(request.user)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })


class FunctionDescViewSet(viewsets.ModelViewSet):
    serializer_class = FunctionDescSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = MTTB_Function_Desc.objects.all().order_by('function_order')
        Record_Status = self.request.query_params.get('Record_Status')
        eod_function = self.request.query_params.get('eod_function')
        if eod_function:
            queryset = queryset.filter(eod_function=eod_function)
        if Record_Status:
            queryset = queryset.filter(Record_Status=Record_Status) 
        return queryset
    
    def perform_create(self, serializer):
        maker = None
        if self.request.user and self.request.user.is_authenticated:
            maker = self.request.user  # Always assign the user instance
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )
    def perform_destroy(self, instance):
        return super().perform_destroy(instance)

    def get_permissions(self):
        # Allow unauthenticated creation
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'O'
        obj.Checker_Id = request.user  # Assign the user instance directly
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.eod_function = 'N'  # Ensure eod_function is set to 'N' when closing
        obj.Record_Status = 'C'
        obj.Checker_Id = request.user
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_enable_eoc(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.eod_function == 'Y':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        if getattr(obj, 'Record_Status', None) != 'O':
            return Response({'detail': 'Cannot set to Open. Only Record_Status = "O" records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.eod_function = 'Y'
        obj.Checker_Id = request.user
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Enable.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_disable_eoc(self, request, pk=None): #set_enable_eoc(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.eod_function == 'N':
            return Response({'detail': 'Already Disable.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        if getattr(obj, 'Record_Status', None) != 'C':
            return Response({'detail': 'Cannot set to Open. Only Record_Status = "C" records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.eod_function = 'N'
        obj.Checker_Id = request.user
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Disable.', 'entry': serializer.data})

from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.response import Response
from django.utils import timezone
from .models import MTTB_Ccy_DEFN
from .serializers import CcyDefnSerializer

class CcyDefnViewSet(viewsets.ModelViewSet):
    """
    CRUD for currency definitions.
    """
    queryset = MTTB_Ccy_DEFN.objects.all().order_by('ccy_code')
    serializer_class = CcyDefnSerializer

    def get_permissions(self):
        # Allow unauthenticated creation
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    def perform_create(self, serializer):
        # Stamp maker and date
        maker = None
        if self.request.user and self.request.user.is_authenticated:
            maker = self.request.user
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now(),
        )

    def perform_update(self, serializer):
        checker = self.request.user if self.request.user.is_authenticated else None

        serializer.save(
            Checker_Id=checker,
            Checker_DT_Stamp=timezone.now()
        )
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'O'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Once_Status = 'Y'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'U', Record_Status = 'C'
        journal_entry.Auth_Status = 'U'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })


from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.response import Response
from django.utils import timezone
from .models import MTTB_EXC_Rate, MTTB_EXC_Rate_History
from .serializers import ExcRateSerializer, ExcRateHistorySerializer

class ExcRateViewSet(viewsets.ModelViewSet):
    """
    CRUD for Exchange Rates.
    """
    queryset = MTTB_EXC_Rate.objects.select_related('ccy_code').all().order_by('ccy_code__ccy_code')
    serializer_class = ExcRateSerializer

    def get_queryset(self):
        queryset = MTTB_EXC_Rate.objects.select_related('ccy_code').all().order_by('ccy_code__ccy_code')
        ccy_code_param = self.request.query_params.get('ccy_code')
        if ccy_code_param:
            queryset = queryset.filter(ccy_code__ccy_code=ccy_code_param)
        return queryset

    def get_permissions(self):
        # Allow unauthenticated create
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    def perform_create(self, serializer):
        maker = None
        if self.request.user and self.request.user.is_authenticated:
            maker = self.request.user
        exc_rate = serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now()
        )
        # Also record initial history entry
        MTTB_EXC_Rate_History.objects.create(
            ccy_code=exc_rate.ccy_code,
            Buy_Rate=exc_rate.Buy_Rate,
            Sale_Rate=exc_rate.Sale_Rate,
            INT_Auth_Status=exc_rate.INT_Auth_Status,
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now(),
            Auth_Status=exc_rate.Auth_Status
        )

    def perform_update(self, serializer):
        checker = None
        if self.request.user and self.request.user.is_authenticated:
            checker = self.request.user
        exc_rate = serializer.save(
            Checker_DT_Stamp=timezone.now()
        )
        # Record history on each update
        MTTB_EXC_Rate_History.objects.create(
            ccy_code=exc_rate.ccy_code,
            Buy_Rate=exc_rate.Buy_Rate,
            Sale_Rate=exc_rate.Sale_Rate,
            INT_Auth_Status=exc_rate.INT_Auth_Status,
            Maker_Id=checker,
            Maker_DT_Stamp=timezone.now(),
            Auth_Status=exc_rate.Auth_Status
        )

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'U'
        journal_entry.Auth_Status = 'U'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })


class ExcRateHistoryViewSet(viewsets.ModelViewSet):
    """
    CRUD for Exchange Rate History.
    """
    queryset = MTTB_EXC_Rate_History.objects.select_related('ccy_code').all().order_by('-Maker_DT_Stamp')
    serializer_class = ExcRateHistorySerializer

    def get_permissions(self):
        # Read operations require authentication; creation only via ExcRateViewSet
        if self.request.method in ['POST', 'PUT', 'PATCH', 'DELETE']:
            return [IsAuthenticated()]
        return [IsAuthenticated()]
    
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def exchange_rate_history_for_ccy(request, ccy_code):
    """
    GET /api/exchange-rate-history/<ccy_code>/
    Returns all history entries for the given currency code.
    """
    histories = MTTB_EXC_Rate_History.objects.filter(ccy_code__ccy_code=ccy_code).order_by('-Maker_DT_Stamp')
    serializer = ExcRateHistorySerializer(histories, many=True)
    return Response(serializer.data, status=status.HTTP_200_OK)


from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated, AllowAny
from django.utils import timezone
from .models import MTTB_GLMaster
from .serializers import GLMasterSerializer

class GLMasterViewSet(viewsets.ModelViewSet):
    """
    CRUD for General Ledger Master records,
    with optional filtering on ?glType=X&category=Y
    and search via ?gl_code=substring
    """
    serializer_class = GLMasterSerializer

    def get_permissions(self):
        # Allow unauthenticated POST, require auth otherwise
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    def get_queryset(self):
        # Base queryset (with your related joins/order)
        qs = (
            MTTB_GLMaster.objects
            .select_related('Maker_Id', 'Checker_Id')
            .all()
            .order_by('gl_code')
        )

        params = self.request.query_params

        # Filter by glType if provided
        gltype = params.get('glType')
        if gltype:
            qs = qs.filter(glType=gltype)

        # Filter by category if provided
        category = params.get('category')
        if category:
            qs = qs.filter(category=category)

        # Search gl_code substring if provided
        code = params.get('gl_code')
        if code:
            qs = qs.filter(gl_code=code)

        return qs

    def perform_create(self, serializer):
        maker = self.request.user if self.request.user.is_authenticated else None
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        checker = self.request.user if self.request.user.is_authenticated else None
        serializer.save(
            Checker_Id=checker,
            Checker_DT_Stamp=timezone.now()
        )
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_400_BAD_REQUEST)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'O'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'C'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Once_Status = 'Y'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'U', Record_Status = 'C'
        journal_entry.Auth_Status = 'U'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })
    
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated, AllowAny
from django.utils import timezone
from .models import MTTB_GLSub
from .serializers import GLSubSerializer, GLSubDisplaySerializer

class GLSubViewSet(viewsets.ModelViewSet):
    """
    CRUD for General Ledger Sub-account (GLSub) records.
    """
    serializer_class = GLSubSerializer

    def get_queryset(self):
        queryset = MTTB_GLSub.objects.select_related('gl_code', 'Maker_Id', 'Checker_Id').all().order_by('glsub_code')

        gl_code = self.request.query_params.get('gl_code')
        glcode_sub = self.request.query_params.get('glcode_sub')  

        if gl_code:
            queryset = queryset.filter(gl_code=gl_code)

        if glcode_sub:
            queryset = queryset.filter(glsub_code__icontains=glcode_sub)

        return queryset

    def get_permissions(self):
       
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    def perform_create(self, serializer):
        maker = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        checker = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
            Checker_Id=checker,
            Checker_DT_Stamp=timezone.now()
        )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_400_BAD_REQUEST)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'O'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'C'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Once_Status = 'Y'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'U', Record_Status = 'C'
        journal_entry.Auth_Status = 'U'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })
    
    @action(detail=False, methods=['post'])
    def display_item_by_postside(self, request):
        """Retrieve GLSub items filtered by post_side (dr or cr) from GLMaster"""
        post_side = request.data.get('post_side')

        # Validate post_side
        if post_side not in ['dr', 'cr']:
            return Response({
                'error': 'Invalid post_side',
                'detail': 'post_side must be either "dr" or "cr"'
            }, status=status.HTTP_400_BAD_REQUEST)

        try:
            # Map post_side to filter values
            post_side_filter = ['dr', 'drcr'] if post_side == 'dr' else ['cr', 'drcr']

            # Query GLSub joined with GLMaster
            items = MTTB_GLSub.objects.select_related('gl_code').filter(
                gl_code__post_side__in=post_side_filter
            ).order_by('glsub_code')

            if not items.exists():
                return Response({
                    'message': f'No GLSub items found for post_side: {post_side}',
                    'items': []
                }, status=status.HTTP_200_OK)

            # Serialize the results
            serializer = GLSubDisplaySerializer(items, many=True)
            logger.info(f"Retrieved {len(items)} GLSub items for post_side: {post_side}")

            return Response({
                'message': f'Successfully retrieved {len(items)} GLSub items for post_side: {post_side}',
                'items': serializer.data
            }, status=status.HTTP_200_OK)

        except Exception as e:
            logger.error(f"Error retrieving GLSub items for post_side {post_side}: {str(e)}")
            return Response({
                'error': 'Failed to retrieve GLSub items',
                'detail': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)


from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from rest_framework.parsers import JSONParser, MultiPartParser, FormParser
from django.utils import timezone
from .models import MTTB_EMPLOYEE, MTTB_Users, MTTB_Divisions
from .serializers import EmployeeSerializer

# class EmployeeViewSet(viewsets.ModelViewSet):
#     """
#     CRUD for employees, supporting:
#       - JSON and multipart/form-data for file uploads
#       - Filtering by ?div_id=...
#       - Soft deletion via record_stat='D'
#     """
#     serializer_class = EmployeeSerializer
#     parser_classes = [JSONParser, MultiPartParser, FormParser]
#     permission_classes = [IsAuthenticated]

#     def get_queryset(self):
#         """
#         Returns active employees (record_stat='A'), optionally filtered by div_id.
#         """
#         qs = MTTB_EMPLOYEE.objects.select_related('user_id', 'div_id', 'Maker_Id', 'Checker_Id').filter(record_stat='O')
        
#         params = self.request.query_params
#         div_id = params.get('div_id')
#         if div_id:
#             qs = qs.filter(div_id_id__div_id=div_id)
        
#         return qs.order_by('employee_id')

#     def perform_create(self, serializer):
#         """
#         Sets audit fields for creation.
#         """
#         serializer.save(
#             Maker_Id=self.request.user if self.request.user.is_authenticated else None,
#             Maker_DT_Stamp=timezone.now(),
#             record_stat='A',
#             Auth_Status='U',
#             Once_Auth='N'
#         )

#     def perform_update(self, serializer):
#         """
#         Sets audit fields for updates.
#         """
#         serializer.save(
#             Checker_Id=self.request.user if self.request.user.is_authenticated else None,
#             Checker_DT_Stamp=timezone.now()
#         )

#     def perform_destroy(self, instance):
#         """
#         Soft deletes the employee by setting record_stat to 'D'.
#         """
#         instance.record_stat = 'D'
#         instance.Checker_Id = self.request.user if self.request.user.is_authenticated else None
#         instance.Checker_DT_Stamp = timezone.now()
#         instance.save()

#     @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
#     def set_open(self, request, pk=None):
#         """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
#         obj = self.get_object()
#         if obj.record_stat == 'O':
#             return Response({'detail': 'Already open.'}, status=status.HTTP_400_BAD_REQUEST)
#         if getattr(obj, 'Auth_Status', None) != 'A':
#             return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
#         obj.record_stat = 'O'
#         obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
#         obj.Checker_DT_Stamp = timezone.now()
#         obj.save()
#         serializer = self.get_serializer(obj)
#         return Response({'message': 'Set to Open.', 'entry': serializer.data})

#     @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
#     def set_close(self, request, pk=None):
#         """Set Record_Status = 'C' (Close)"""
#         obj = self.get_object()
#         if obj.record_stat == 'C':
#             return Response({'detail': 'Already closed.'}, status=status.HTTP_400_BAD_REQUEST)
#         obj.record_stat = 'C'
#         obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
#         obj.Checker_DT_Stamp = timezone.now()
#         obj.save()
#         serializer = self.get_serializer(obj)
#         return Response({'message': 'Set to Close.', 'entry': serializer.data})

#     @action(detail=True, methods=['post'])
#     def authorize(self, request, pk=None):
#         """Authorize a journal entry"""
#         journal_entry = self.get_object()

#         if journal_entry.Auth_Status == 'A':
#             return Response({'error': 'Entry is already authorized'}, 
#                           status=status.HTTP_400_BAD_REQUEST)

#         # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
#         journal_entry.Auth_Status = 'A'
#         journal_entry.Once_Status = 'Y'
#         journal_entry.record_stat = 'C'
#         journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
#         journal_entry.Checker_DT_Stamp = timezone.now()
#         journal_entry.save()

#         serializer = self.get_serializer(journal_entry)
#         return Response({
#             'message': 'Entry authorized successfully',
#             'entry': serializer.data
#         })

#     @action(detail=True, methods=['post'])
#     def unauthorize(self, request, pk=None):
#         """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
#         journal_entry = self.get_object()

#         if journal_entry.Auth_Status == 'U':
#             return Response({'error': 'Entry is already unauthorized'}, 
#                           status=status.HTTP_400_BAD_REQUEST)

#         # Set Auth_Status = 'U', Record_Status = 'C'
#         journal_entry.Auth_Status = 'U'
#         journal_entry.record_stat = 'C'
#         journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
#         journal_entry.Checker_DT_Stamp = timezone.now()
#         journal_entry.save()

#         serializer = self.get_serializer(journal_entry)
#         return Response({
#             'message': 'Entry unauthorized successfully',
#             'entry': serializer.data
#         })

class EmployeeViewSet(viewsets.ModelViewSet):
    serializer_class = EmployeeSerializer
    permission_classes = [IsAuthenticated]
    lookup_field = 'employee_id'

    def get_queryset(self):
        """
        Returns active employees (Record_Status='O'), optionally filtered by div_id.
        """
        qs = MTTB_EMPLOYEE.objects.select_related('user_id', 'div_id', 'Maker_Id', 'Checker_Id')
        params = self.request.query_params
        div_id = params.get('div_id')
        if div_id:
            qs = qs.filter(div_id_id__div_id=div_id)

        return qs.order_by('employee_id')

    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def create(self, request, *args, **kwargs):
        response = super().create(request, *args, **kwargs)
        return Response({
            'message': 'Employee created successfully.',
            'entry': response.data
        }, status=response.status_code)

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )

    def update(self, request, *args, **kwargs):
        response = super().update(request, *args, **kwargs)
        return Response({
            'message': 'Employee updated successfully.',
            'entry': response.data
        }, status=response.status_code)

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        self.perform_destroy(instance)
        return Response({
            'message': 'Employee deleted successfully.'
        }, status=status.HTTP_204_NO_CONTENT)

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, employee_id=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_400_BAD_REQUEST)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'O'
        obj.Checker_Id = request.user
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, employee_id=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'C'
        obj.Checker_Id = request.user
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def authorize(self, request, employee_id=None):
        """Authorize an employee record"""
        obj = self.get_object()
        if obj.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, status=status.HTTP_400_BAD_REQUEST)

        obj.Auth_Status = 'A'
        obj.Once_Auth = 'Y'
        obj.Record_Status = 'C'
        obj.Checker_Id = request.user
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()

        serializer = self.get_serializer(obj)
        return Response({'message': 'Entry authorized successfully.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def unauthorize(self, request, employee_id=None):
        """Unauthorize an employee record"""
        obj = self.get_object()
        if obj.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, status=status.HTTP_400_BAD_REQUEST)

        obj.Auth_Status = 'U'
        obj.Record_Status = 'C'
        obj.Checker_Id = request.user
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()

        serializer = self.get_serializer(obj)
        return Response({'message': 'Entry unauthorized successfully.', 'entry': serializer.data})

from .serializers import MTTB_LCL_HolidaySerializer
from .models import MTTB_LCL_Holiday
class HolidayViewSet(viewsets.ModelViewSet):
    queryset = MTTB_LCL_Holiday.objects.all().order_by('lcl_holiday_id')
    serializer_class = MTTB_LCL_HolidaySerializer
    permission_classes = [IsAuthenticated]

from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from .models import MTTB_Role_Detail
from .serializers import RoleDetailSerializer

@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def update_role_detail(request):
    role_id = request.query_params.get('role_id')
    sub_menu_id = request.query_params.get('sub_menu_id')

    try:
        obj = MTTB_Role_Detail.objects.get(role_id=role_id, sub_menu_id=sub_menu_id)
    except MTTB_Role_Detail.DoesNotExist:
        return Response({'detail': 'Not found.'}, status=status.HTTP_404_NOT_FOUND)

    serializer = RoleDetailSerializer(obj, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated, AllowAny
from django.utils import timezone
from .models import MTTB_Fin_Cycle
from .serializers import FinCycleSerializer

class FinCycleViewSet(viewsets.ModelViewSet):

    queryset = MTTB_Fin_Cycle.objects.select_related('Maker_Id', 'Checker_Id').all().order_by('fin_cycle')
    serializer_class = FinCycleSerializer

    def get_permissions(self):
        # Allow anyone to create a new cycle, require auth elsewhere
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    def perform_create(self, serializer):
        maker = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        checker = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
             Checker_Id=checker,
            Checker_DT_Stamp=timezone.now()
        )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'O'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Once_Status = 'Y'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_406_NOT_ACCEPTABLE)

        # Set Auth_Status = 'U', Record_Status = 'C'
        journal_entry.Auth_Status = 'U'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })



from rest_framework import viewsets
from .models import MTTB_Per_Code
from .serializers import PerCodeSerializer

class PerCodeViewSet(viewsets.ModelViewSet):
    serializer_class = PerCodeSerializer
    lookup_field = 'period_code'

    def get_queryset(self):
        queryset = MTTB_Per_Code.objects.all()
        fincycle_param = self.request.query_params.get('fincycle')

        if fincycle_param:
            queryset = queryset.filter(Fin_cycle__fin_cycle=fincycle_param)

        return queryset


from collections import OrderedDict
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response

from .models import MTTB_GLMaster
from .serializers import GLMasterSerializer

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def gl_hierarchy(request):

    qs = MTTB_GLMaster.objects.all().order_by('glType', 'category', 'gl_code')

    # 2) group
    hierarchy = OrderedDict()
    for gl in qs:
        # group by type
        by_cat = hierarchy.setdefault(gl.glType or 'None', OrderedDict())
        # then by category
        lst = by_cat.setdefault(gl.category or 'None', [])
        # append serialized record
        lst.append(GLMasterSerializer(gl).data)

    # 3) build JSON‐friendly list
    result = []
    for gltype, cats in hierarchy.items():
        type_obj = {'glType': gltype, 'categories': []}
        for cat, items in cats.items():
            type_obj['categories'].append({
                'category': cat,
                'items': items
            })
        result.append(type_obj)

    return Response(result)



# from rest_framework.decorators import api_view, permission_classes
# from rest_framework.permissions import IsAuthenticated
# from rest_framework.response import Response
# from .models import MTTB_GLMaster

# @api_view(['GET'])
# @permission_classes([IsAuthenticated])
# def gl_tree(request):
#     """
#     Returns GL codes nested by prefix.
#     """
#     q = MTTB_GLMaster.objects.filter(gl_code__isnull=False).order_by('gl_code')

#     # Build code-to-node map
#     nodes = {}
#     for gl in q:
#         if gl.gl_code:
#             nodes[gl.gl_code] = {
#                 'gl_code': gl.gl_code,
#                 'gl_Desc_la': gl.gl_Desc_la,
#                 'gl_Desc_en': gl.gl_Desc_en,
#                 'children': []
#             }

#     roots = []
#     for code, node in nodes.items():
#         parent_code = None
#         for candidate in nodes:
#             if candidate != code and code.startswith(candidate):
#                 if parent_code is None or len(candidate) > len(parent_code):
#                     parent_code = candidate
#         if parent_code:
#             nodes[parent_code]['children'].append(node)
#         else:
#             roots.append(node)

#     return Response(roots)

from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from .models import MTTB_GLMaster

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def gl_tree(request):
    """
    Returns GL codes nested by prefix.
    
    Query Parameters:
    - gl_code: Filter GL codes that start with this value (optional)
    - glType: Filter by GL type (optional)
    """
    # Get query parameters
    gl_code_filter = request.query_params.get('gl_code', None)
    gl_type_filter = request.query_params.get('glType', None)
    
    # Build base query
    q = MTTB_GLMaster.objects.filter(gl_code__isnull=False)
    
    # Apply filters if provided
    if gl_code_filter:
        q = q.filter(gl_code__startswith=gl_code_filter)
    
    if gl_type_filter:
        q = q.filter(glType=gl_type_filter)
    
    # Order by gl_code
    q = q.order_by('gl_code')

    # Build code-to-node map
    nodes = {}
    for gl in q:
        if gl.gl_code:
            nodes[gl.gl_code] = {
                'gl_code': gl.gl_code,
                'gl_Desc_la': gl.gl_Desc_la,
                'gl_Desc_en': gl.gl_Desc_en,
                'glType': gl.glType,
                'glCategory': gl.category,
                'gl_Retal': gl.retal,
                'ccy_Res': gl.ccy_Res,
                # 'Res_ccy': gl.Res_ccy,
                'Record_Status': gl.Record_Status,
                'Auth_Status': gl.Auth_Status,
                'children': []
            }

    roots = []
    for code, node in nodes.items():
        parent_code = None
        for candidate in nodes:
            if candidate != code and code.startswith(candidate):
                if parent_code is None or len(candidate) > len(parent_code):
                    parent_code = candidate
        if parent_code:
            nodes[parent_code]['children'].append(node)
        else:
            roots.append(node)

    return Response(roots)

from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.db.models import Count
from .models import MTTB_MAIN_MENU

@api_view(['GET'])
def count_menus_by_module(request):
    module_id = request.query_params.get('module_Id')

    queryset = MTTB_MAIN_MENU.objects.all()

    if module_id:
        queryset = queryset.filter(module_Id=module_id)

    data = (
        queryset
        .values('module_Id')
        .annotate(c_main=Count('menu_id'))
    )

    return Response(data)


from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.db.models import Count
from .models import MTTB_SUB_MENU

@api_view(['GET'])
def count_submenus_per_menu(request):
    menu_id = request.query_params.get('menu_id')

    queryset = MTTB_SUB_MENU.objects.all()

    if menu_id:
        queryset = queryset.filter(menu_id=menu_id)

    data = (
        queryset
        .values(
            'menu_id',
            'menu_id__menu_name_la',
            'menu_id__menu_name_en'
        )
        .annotate(count_menu=Count('sub_menu_id'))
        .order_by('menu_id')
    )

    result = [
        {
            "menu_id": item['menu_id'],
            "menu_name_la": item['menu_id__menu_name_la'],
            "menu_name_en": item['menu_id__menu_name_en'],
            "count_menu": item['count_menu']
        }
        for item in data
    ]

    return Response(result)


from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from django_filters.rest_framework import DjangoFilterBackend
from django.utils import timezone
from rest_framework import filters
from rest_framework import viewsets, status
from .models import MTTB_LCL_Holiday
from .serializers import MTTB_LCL_HolidaySerializer

class MTTB_LCL_HolidayViewSet(viewsets.ModelViewSet):
    """
    ViewSet for MTTB_LCL_Holiday model providing CRUD operations.
    
    Holiday_List now always contains exactly 31 characters:
    - H: Holiday
    - W: Working day
    - N: Weekend day
    - O: Non-existent day in month (e.g., Feb 29-31)
    
    list: Get all holidays with optional filtering
    create: Create a new holiday (no authentication required)
    retrieve: Get a specific holiday by ID
    update: Update a holiday (full update)
    partial_update: Update a holiday (partial update)
    destroy: Delete a holiday
    """
    queryset = MTTB_LCL_Holiday.objects.all()
    serializer_class = MTTB_LCL_HolidaySerializer
    lookup_field = 'lcl_holiday_id'
    
    # Enable filtering, searching, and ordering
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    
    # Define filterable fields
    filterset_fields = {
        'HYear': ['exact', 'in'],
        'HMonth': ['exact', 'in'],
        'HDate': ['exact', 'gte', 'lte', 'range'],
        'Holiday_List': ['exact'],
        'Record_Status': ['exact', 'in'],
        'Auth_Status': ['exact', 'in'],
        'Once_Auth': ['exact'],
        'Maker_Id': ['exact'],
        'Checker_Id': ['exact']
    }
    
    # Define searchable fields
    search_fields = ['lcl_holiday_id', 'HYear', 'HMonth']
    
    # Define ordering fields
    ordering_fields = ['lcl_holiday_id', 'HDate', 'HYear', 'HMonth', 'Maker_DT_Stamp']
    ordering = ['-Maker_DT_Stamp']  # Default ordering
    
    def get_permissions(self):
        # Allow anyone to create a new holiday, require auth elsewhere
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]
    
    def perform_create(self, serializer):
        maker = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now()
        )
    
    def perform_update(self, serializer):
        checker = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
            Checker_Id=checker,
            Checker_DT_Stamp=timezone.now()
        )
    
    def get_queryset(self):
        """
        Optionally restricts the returned holidays based on query parameters.
        """
        queryset = super().get_queryset()
        
        # Example: Filter holidays by date range
        start_date = self.request.query_params.get('start_date', None)
        end_date = self.request.query_params.get('end_date', None)
        
        if start_date and end_date:
            queryset = queryset.filter(HDate__range=[start_date, end_date])
        
        # Example: Filter only active records
        active_only = self.request.query_params.get('active_only', None)
        if active_only and active_only.lower() == 'true':
            queryset = queryset.filter(Record_Status='O')
        
        return queryset
    

    @action(detail=False, methods=['get'], permission_classes=[IsAuthenticated])
    def pending_authorization(self, request):
        """
        Get all holidays pending authorization (Auth_Status='U')
        """
        pending = self.get_queryset().filter(Auth_Status='U')
        serializer = self.get_serializer(pending, many=True)
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def authorize(self, request, lcl_holiday_id=None):
        """
        Authorize a holiday record
        """
        holiday = self.get_object()
        
        if holiday.Auth_Status == 'A':
            return Response(
                {'detail': 'Holiday already authorized'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Prevent self-authorization
        if holiday.Maker_Id and holiday.Maker_Id == request.user:
            return Response(
                {'detail': 'Cannot authorize your own record'},
                status=status.HTTP_403_FORBIDDEN
            )
        
        holiday.Auth_Status = 'A'
        holiday.Checker_Id = request.user
        holiday.Checker_DT_Stamp = timezone.now()
        holiday.save()
        
        serializer = self.get_serializer(holiday)
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def reject(self, request, lcl_holiday_id=None):
        """
        Reject a holiday record
        """
        holiday = self.get_object()
        
        if holiday.Auth_Status == 'U':
            return Response(
                {'detail': 'Holiday already rejected'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        holiday.Auth_Status = 'U'
        holiday.Checker_Id = request.user
        holiday.Checker_DT_Stamp = timezone.now()
        holiday.save()
        
        serializer = self.get_serializer(holiday)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def by_year_month(self, request):
        """
        Get holidays for a specific year and month
        """
        year = request.query_params.get('year', None)
        month = request.query_params.get('month', None)
        
        if not year:
            return Response(
                {'detail': 'Year parameter is required'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        queryset = self.get_queryset().filter(HYear=year)
        
        if month:
            queryset = queryset.filter(HMonth=month)
        
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def upcoming(self, request):
        """
        Get upcoming holidays (HDate >= today)
        """
        from datetime import date
        today = date.today()
        
        upcoming = self.get_queryset().filter(
            HDate__gte=today,
            Record_Status='C',
            Auth_Status='A'
        ).order_by('HDate')
        
        serializer = self.get_serializer(upcoming, many=True)
        return Response(serializer.data)
    
    def perform_destroy(self, instance):
        instance.delete()

# from rest_framework.decorators import action
# from rest_framework.response import Response
# from rest_framework.permissions import IsAuthenticated, AllowAny
# from django_filters.rest_framework import DjangoFilterBackend
# from django.utils import timezone
# from rest_framework import filters
# from rest_framework import viewsets, status
# from .models import MTTB_LCL_Holiday
# from .serializers import MTTB_LCL_HolidaySerializer

# class MTTB_LCL_HolidayViewSet(viewsets.ModelViewSet):
#     """
#     ViewSet for MTTB_LCL_Holiday model providing CRUD operations.
    
#     list: Get all holidays with optional filtering
#     create: Create a new holiday (no authentication required)
#     retrieve: Get a specific holiday by ID
#     update: Update a holiday (full update)
#     partial_update: Update a holiday (partial update)
#     destroy: Delete a holiday
#     """
#     queryset = MTTB_LCL_Holiday.objects.all()
#     serializer_class = MTTB_LCL_HolidaySerializer
#     lookup_field = 'lcl_holiday_id'
    
#     # Enable filtering, searching, and ordering
#     filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    
#     # Define filterable fields
#     filterset_fields = {
#         'HYear': ['exact', 'in'],
#         'HMonth': ['exact', 'in'],
#         'HDate': ['exact', 'gte', 'lte', 'range'],
#         'Holiday_List': ['exact'],
#         'Record_Status': ['exact', 'in'],
#         'Auth_Status': ['exact', 'in'],
#         'Once_Auth': ['exact'],
#         'Maker_Id': ['exact'],
#         'Checker_Id': ['exact']
#     }
    
#     # Define searchable fields
#     search_fields = ['lcl_holiday_id', 'HYear', 'HMonth']
    
#     # Define ordering fields
#     ordering_fields = ['lcl_holiday_id', 'HDate', 'HYear', 'HMonth', 'Maker_DT_Stamp']
#     ordering = ['-Maker_DT_Stamp']  # Default ordering
    
#     def get_permissions(self):
#         # Allow anyone to create a new holiday, require auth elsewhere
#         if self.request.method == 'POST':
#             return [AllowAny()]
#         return [IsAuthenticated()]
    
#     def perform_create(self, serializer):
#         maker = self.request.user if self.request.user and self.request.user.is_authenticated else None
#         serializer.save(
#             Maker_Id=maker,
#             Maker_DT_Stamp=timezone.now()
#         )
    
#     def perform_update(self, serializer):
#         checker = self.request.user if self.request.user and self.request.user.is_authenticated else None
#         serializer.save(
#             Checker_Id=checker,
#             Checker_DT_Stamp=timezone.now()
#         )
    
#     def get_queryset(self):
#         """
#         Optionally restricts the returned holidays based on query parameters.
#         """
#         queryset = super().get_queryset()
        
#         # Example: Filter holidays by date range
#         start_date = self.request.query_params.get('start_date', None)
#         end_date = self.request.query_params.get('end_date', None)
        
#         if start_date and end_date:
#             queryset = queryset.filter(HDate__range=[start_date, end_date])
        
#         # Example: Filter only active records
#         active_only = self.request.query_params.get('active_only', None)
#         if active_only and active_only.lower() == 'true':
#             queryset = queryset.filter(Record_Status='O')
        
#         return queryset
    

#     @action(detail=False, methods=['get'], permission_classes=[IsAuthenticated])
#     def pending_authorization(self, request):
#         """
#         Get all holidays pending authorization (Auth_Status='U')
#         """
#         pending = self.get_queryset().filter(Auth_Status='U')
#         serializer = self.get_serializer(pending, many=True)
#         return Response(serializer.data)
    
#     @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
#     def authorize(self, request, lcl_holiday_id=None):
#         """
#         Authorize a holiday record
#         """
#         holiday = self.get_object()
        
#         if holiday.Auth_Status == 'A':
#             return Response(
#                 {'detail': 'Holiday already authorized'},
#                 status=status.HTTP_400_BAD_REQUEST
#             )
        
#         # Prevent self-authorization
#         if holiday.Maker_Id and holiday.Maker_Id == request.user:
#             return Response(
#                 {'detail': 'Cannot authorize your own record'},
#                 status=status.HTTP_403_FORBIDDEN
#             )
        
#         holiday.Auth_Status = 'A'
#         holiday.Checker_Id = request.user
#         holiday.Checker_DT_Stamp = timezone.now()
#         holiday.save()
        
#         serializer = self.get_serializer(holiday)
#         return Response(serializer.data)
    
#     @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
#     def reject(self, request, lcl_holiday_id=None):
#         """
#         Reject a holiday record
#         """
#         holiday = self.get_object()
        
#         if holiday.Auth_Status == 'U':
#             return Response(
#                 {'detail': 'Holiday already rejected'},
#                 status=status.HTTP_400_BAD_REQUEST
#             )
        
#         holiday.Auth_Status = 'U'
#         holiday.Checker_Id = request.user
#         holiday.Checker_DT_Stamp = timezone.now()
#         holiday.save()
        
#         serializer = self.get_serializer(holiday)
#         return Response(serializer.data)
    
#     @action(detail=False, methods=['get'])
#     def by_year_month(self, request):
#         """
#         Get holidays for a specific year and month
#         """
#         year = request.query_params.get('year', None)
#         month = request.query_params.get('month', None)
        
#         if not year:
#             return Response(
#                 {'detail': 'Year parameter is required'},
#                 status=status.HTTP_400_BAD_REQUEST
#             )
        
#         queryset = self.get_queryset().filter(HYear=year)
        
#         if month:
#             queryset = queryset.filter(HMonth=month)
        
#         serializer = self.get_serializer(queryset, many=True)
#         return Response(serializer.data)
    
#     @action(detail=False, methods=['get'])
#     def upcoming(self, request):
#         """
#         Get upcoming holidays (HDate >= today)
#         """
#         from datetime import date
#         today = date.today()
        
#         upcoming = self.get_queryset().filter(
#             HDate__gte=today,
#             Record_Status='C',
#             Auth_Status='A'
#         ).order_by('HDate')
        
#         serializer = self.get_serializer(upcoming, many=True)
#         return Response(serializer.data)
    
#     def perform_destroy(self, instance):
#         instance.delete()

from rest_framework import viewsets, filters
from django_filters.rest_framework import DjangoFilterBackend
from .serializers import MTTB_TRN_CodeSerializer
from .models import MTTB_TRN_Code

class MTTB_TRN_CodeViewSet(viewsets.ModelViewSet):
    """
    Enhanced CRUD ViewSet with filtering and searching
    """
    queryset = MTTB_TRN_Code.objects.all()
    serializer_class = MTTB_TRN_CodeSerializer
    lookup_field = 'trn_code'
    
    # Add filtering, searching, and ordering
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['Record_Status', 'Auth_Status', 'Once_Auth']
    search_fields = ['trn_code', 'trn_Desc_la', 'trn_Desc_en']
    ordering_fields = ['trn_code', 'Maker_DT_Stamp']
    ordering = ['-Maker_DT_Stamp']
    
    def get_permissions(self):
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]
    
    def perform_create(self, serializer):
        maker = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now()
        )
    
    def perform_update(self, serializer):
        checker = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
            Checker_Id=checker,
            Checker_DT_Stamp=timezone.now()
        )
    
    def perform_destroy(self, instance):
        instance.Record_Status = 'D'
        instance.save()
    
    def get_queryset(self):
        """Add custom query filters"""
        queryset = super().get_queryset()
        
        # Filter only active records by default
        if self.request.query_params.get('all') != 'true':
            queryset = queryset.exclude(Record_Status='D')
        
        # Filter by authorization status
        auth_status = self.request.query_params.get('auth_status')
        if auth_status:
            queryset = queryset.filter(Auth_Status=auth_status)
        
        return queryset
    
    @action(detail=False, methods=['get'])
    def pending(self, request):
        """Get all pending transaction codes"""
        pending = self.get_queryset().filter(Auth_Status='U')
        serializer = self.get_serializer(pending, many=True)
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' (Open) only if Auth_Status = 'A'"""
        obj = self.get_object()
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_400_BAD_REQUEST)
        if getattr(obj, 'Auth_Status', None) != 'A':
            return Response({'detail': 'Cannot set to Open. Only authorized (Auth_Status = "A") records can be opened.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'O'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_400_BAD_REQUEST)
        obj.Record_Status = 'C'
        obj.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'])
    def authorize(self, request, pk=None):
        """Authorize a journal entry"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'A':
            return Response({'error': 'Entry is already authorized'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'A', Once_Status = 'Y', Record_Status = 'O'
        journal_entry.Auth_Status = 'A'
        journal_entry.Once_Status = 'Y'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry authorized successfully',
            'entry': serializer.data
        })

    @action(detail=True, methods=['post'])
    def unauthorize(self, request, pk=None):
        """Unauthorize a journal entry (set Auth_Status = 'U', Record_Status = 'C')"""
        journal_entry = self.get_object()

        if journal_entry.Auth_Status == 'U':
            return Response({'error': 'Entry is already unauthorized'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'U', Record_Status = 'C'
        journal_entry.Auth_Status = 'U'
        journal_entry.Record_Status = 'C'
        journal_entry.Checker_Id = MTTB_Users.objects.get(user_id=request.user.user_id)
        journal_entry.Checker_DT_Stamp = timezone.now()
        journal_entry.save()

        serializer = self.get_serializer(journal_entry)
        return Response({
            'message': 'Entry unauthorized successfully',
            'entry': serializer.data
        })

    
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAuthenticated
from rest_framework import viewsets
from django.db.models import Q
from .models import MTTB_ProvinceInfo, MTTB_DistrictInfo, MTTB_VillageInfo
from .serializers import ProvinceSerializer, DistrictSerializer, VillageSerializer

class ProvinceViewSet(viewsets.ModelViewSet):

    " CRUD for provinces with custom list and create  methods"

    queryset = MTTB_ProvinceInfo.objects.all().order_by('pro_id')
    serializer_class = ProvinceSerializer
    permission_classes = [IsAuthenticated]

    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        count = queryset.count()

        if count == 0:
            return Response({
                "status": False,
                "message": "ບໍ່ພົບຂໍ້ມູນແຂວງ",
                "count": 0,
                "data": []
            }, status=status.HTTP_200_OK)

        return Response({
            "status": True,
            "message": "ສຳເລັດການດຶງຂໍ້ມູນແຂວງທັງໝົດ",
            "count": count,
            "data": serializer.data
        }, status=status.HTTP_200_OK)

    def create(self, request, *args, **kwargs):
        try:
            response = super().create(request, *args, **kwargs)
            return Response({
                "status": True,
                "message": "ສຳເລັດການເພີ່ມຂໍ້ມູນແຂວງ",
                "data": response.data
            }, status=response.status_code)
        except Exception as e:
            return Response({
                "status": False,
                "message": f"ເພີ່ມຂໍ້ມູນແຂວງບໍ່ສຳເລັດ: {str(e)}"
            }, status=status.HTTP_400_BAD_REQUEST)

    def update(self, request, *args, **kwargs):
        try:
            response = super().update(request, *args, **kwargs)
            return Response({
                "status": True,
                "message": "ອັບເດດຂໍ້ມູນແຂວງສຳເລັດ",
                "data": response.data
            }, status=response.status_code)
        except Exception as e:
            return Response({
                "status": False,
                "message": f"ອັບເດດຂໍ້ມູນແຂວງບໍ່ສຳເລັດ: {str(e)}"
            }, status=status.HTTP_400_BAD_REQUEST)

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()
            self.perform_destroy(instance)
            return Response({
                "status": True,
                "message": "ລົບຂໍ້ມູນແຂວງສຳເລັດ"
            }, status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            return Response({
                "status": False,
                "message": f"ລົບຂໍ້ມູນແຂວງບໍ່ສຳເລັດ: {str(e)}"
            }, status=status.HTTP_400_BAD_REQUEST)


class DistrictViewSet(viewsets.ModelViewSet):
    "CRUD for districts with custom list and create methods"
        # queryset = DistrictInfo_new.objects.all().order_by('pro_id', 'dis_id')
    serializer_class = DistrictSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = MTTB_DistrictInfo.objects.all().order_by('pro_id', 'dis_id')
        pro_id = self.request.query_params.get('pro_id')
        if pro_id:
            queryset = queryset.filter(pro_id=pro_id) 
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        user_id = getattr(user, 'user_id', None)
        serializer.save(
            user_id=user_id,
            date_insert=timezone.now()
        )

    def perform_update(self, serializer):
        serializer.save(
            date_update=timezone.now()
        )
    
    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)

        pro_id = self.request.query_params.get('pro_id')
        pro_name = None

        if pro_id:
            try:
                province = MTTB_ProvinceInfo.objects.get(pro_id=pro_id)
                pro_name = province.pro_name_l
            except MTTB_ProvinceInfo.DoesNotExist:
                pro_name = None

        count = queryset.count()

        if count == 0:
            message = "ບໍ່ພົບຂໍ້ມູນທີ່ຄົນຄົນຫາ."
            return Response({
                "status": False,
                "message": message,
                "count": 0,
                "data": []
            }, status=status.HTTP_200_OK)
    
        if pro_name:
            message = f"ສຳເລັດການດຶງຂໍ້ມູນເມືອງຂອງແຂວງ={pro_name}."
        else:
            message = "ສຳເລັດການດຶງຂໍ້ມູນເມືອງທັງໝົດ."

        return Response({
            "status": True,
            "message": message,
            "count": queryset.count(),
            "data": serializer.data
        }, status=status.HTTP_200_OK)


    def create(self, request, *args, **kwargs):
        try:
            response = super().create(request, *args, **kwargs)
            return Response({
                "status": True,
                "message": "ສຳເລັດການເພີ່ມຂໍ້ມູນເມືອງ",
                "data": response.data
            }, status=response.status_code)
        except Exception as e:
            return Response({
                "status": False,
                "message": f"ການເພີ່ມຂໍ້ມູນເມືອງບໍ່ສຳເລັດ: {str(e)}"
            }, status=status.HTTP_400_BAD_REQUEST)

    def update(self, request, *args, **kwargs):
        try:
            response = super().update(request, *args, **kwargs)
            return Response({
                "status": True,
                "message": "ອັບເດດຂໍ້ມູນເມືອງສຳເລັດ.",
                "data": response.data
            }, status=response.status_code)
        except Exception as e:
            return Response({
                "status": False,
                "message": f"ອັບເດດຂໍ້ມູນເມືອງບໍ່ສຳເລັດ: {str(e)}"
            }, status=status.HTTP_400_BAD_REQUEST)

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()
            self.perform_destroy(instance)
            return Response({
                "status": True,
                "message": "ລົບຂໍ້ມູນສຳເລັດ."
            }, status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            return Response({
                "status": False,
                "message": f"ລົບຂໍ້ມູນບໍ່ສຳເລັດ: {str(e)}"
            }, status=status.HTTP_400_BAD_REQUEST)

class VillageViewSet(viewsets.ModelViewSet):
    "CRUD for villages with custom list and create methods"
    serializer_class = VillageSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = MTTB_VillageInfo.objects.all().order_by('pro_id', 'dis_id', 'vil_id')
        pro_id = self.request.query_params.get('pro_id')
        dis_id = self.request.query_params.get('dis_id')
        search_name = self.request.query_params.get('search_name')

        if pro_id:
            queryset = queryset.filter(pro_id=pro_id)
        if dis_id:
            queryset = queryset.filter(dis_id=dis_id)
        if search_name:
            queryset = queryset.filter(
                Q(vil_name_e__icontains=search_name) | Q(vil_name_l__icontains=search_name)
            )
        return queryset

    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)

        pro_id = request.query_params.get('pro_id')
        dis_id = request.query_params.get('dis_id')

        pro_name = None
        dis_name = None

        if pro_id:
            try:
                province = MTTB_ProvinceInfo.objects.get(pro_id=pro_id.strip())
                pro_name = province.pro_name_l
            except MTTB_ProvinceInfo.DoesNotExist:
                pro_name = None
        
        if dis_id:
            try:
                district = MTTB_DistrictInfo.objects.get(dis_code=dis_id.strip())
                dis_name = district.dis_name_l
            except MTTB_DistrictInfo.DoesNotExist:
                dis_name = None

        count = queryset.count()

        if count == 0:
            return Response({
                "status": False,
                "message": "ບໍ່ພົບຂໍ້ມູນບ້ານທີ່ຄົ້ນຫາ",
                "count": 0,
                "data": []
            }, status=status.HTTP_200_OK)

        if pro_name and dis_name:
            message = f"ສຳເລັດການດຶງຂໍ້ມູນບ້ານໃນແຂວງ {pro_name} ແລະ ເມືອງ {dis_name}."
        elif pro_name:
            message = f"ສຳເລັດການດຶງຂໍ້ມູນບ້ານໃນແຂວງ {pro_name}."
        elif dis_name:
            message = f"ສຳເລັດການດຶງຂໍ້ມູນບ້ານໃນເມືອງ {dis_name}."
        else:
            message = "ສຳເລັດການດຶງຂໍ້ມູນບ້ານທັງໝົດ."

        return Response({
            "status": True,
            "message": message,
            "count": count,
            "data": serializer.data
        }, status=status.HTTP_200_OK)

    def perform_create(self, serializer):
        user = self.request.user
        user_id = getattr(user, 'user_id', None)
        serializer.save(
            user_id=user_id,
            date_insert=timezone.now()
        )

    def perform_update(self, serializer):
        serializer.save(
            date_update=timezone.now()
        )

    def create(self, request, *args, **kwargs):
        try:
            response = super().create(request, *args, **kwargs)
            return Response({
                "status": True,
                "message": "ສຳເລັດການເພີ່ມຂໍ້ມູນບ້ານ",
                "data": response.data
            }, status=response.status_code)
        except Exception as e:
            return Response({
                "status": False,
                "message": f"ການເພີ່ມຂໍ້ມູນບ້ານບໍ່ສຳເລັດ: {str(e)}"
            }, status=status.HTTP_400_BAD_REQUEST)

    def update(self, request, *args, **kwargs):
        try:
            response = super().update(request, *args, **kwargs)
            return Response({
                "status": True,
                "message": "ອັບເດດຂໍ້ມູນບ້ານສຳເລັດ",
                "data": response.data
            }, status=response.status_code)
        except Exception as e:
            return Response({
                "status": False,
                "message": f"ອັບເດດຂໍ້ມູນບ້ານບໍ່ສຳເລັດ: {str(e)}"
            }, status=status.HTTP_400_BAD_REQUEST)

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()
            self.perform_destroy(instance)
            return Response({
                "status": True,
                "message": "ລົບຂໍ້ມູນສຳເລັດ"
            }, status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            return Response({
                "status": False,
                "message": f"ລົບຂໍ້ມູນບໍ່ສຳເລັດ: {str(e)}"
            }, status=status.HTTP_400_BAD_REQUEST)

@api_view(['GET']) 
@permission_classes([IsAuthenticated])
def list_provinces(request):
    """Get all provinces"""
    queryset = MTTB_ProvinceInfo.objects.all().order_by('pro_id')
    serializer = ProvinceSerializer(queryset, many=True)
    
    return Response({
        "status": True,
        "message": "ສຳເລັດການດຶງຂໍ້ມູນແຂວງ",
        "count": queryset.count(),
        "data": serializer.data
    }, status=status.HTTP_200_OK)

@api_view(['GET']) 
@permission_classes([IsAuthenticated])
def list_districts(request):
    """Get all districts with optional province filter"""
    queryset = MTTB_DistrictInfo.objects.all().order_by('pro_id', 'dis_code')
    pro_id = request.query_params.get('pro_id')
    
    if pro_id:
        queryset = queryset.filter(pro_id=pro_id)
    
    serializer = DistrictSerializer(queryset, many=True)
    
    return Response({
        "status": True,
        "message": "ສຳເລັດການດຶງຂໍ້ມູນເມືອງ",
        "count": queryset.count(),
        "data": serializer.data
    }, status=status.HTTP_200_OK)
@api_view(['GET']) 
@permission_classes([IsAuthenticated])
def list_villages(request):

    "method GET to list villages with optional filters only GET list_villages/"

    queryset = MTTB_VillageInfo.objects.all().order_by('pro_id', 'dis_id', 'vil_id')
    pro_id = request.query_params.get('pro_id')
    dis_id = request.query_params.get('dis_id')
    search_name = request.query_params.get('search_name')

    if pro_id:
        queryset = queryset.filter(pro_id=pro_id)
    if dis_id:
        queryset = queryset.filter(dis_id=dis_id)
    if search_name:
        queryset = queryset.filter(
            Q(vil_name_e__icontains=search_name) | Q(vil_name_l__icontains=search_name)
        )

    if not queryset.exists():
        return Response({
            "status": False,
            "message": "ບໍ່ພົບຂໍ້ມູນບ້ານທີ່ຄົ້ນຫາ",
            "count": 0,
            "data": []
        }, status=status.HTTP_404_NOT_FOUND)

    pro_name = None
    dis_name = None

    if pro_id:
        try:
            province = MTTB_ProvinceInfo.objects.get(pro_id=pro_id.strip())
            pro_name = province.pro_name_l
        except MTTB_ProvinceInfo.DoesNotExist:
            pro_name = None

    if dis_id:
        try:
            district = MTTB_DistrictInfo.objects.get(dis_code=dis_id.strip())
            dis_name = district.dis_name_l
        except MTTB_DistrictInfo.DoesNotExist:
            dis_name = None

    if pro_name and dis_name:
        message = f"ສຳເລັດການດຶງຂໍ້ມູນບ້ານໃນແຂວງ {pro_name} ແລະ ເມືອງ {dis_name}."
    elif pro_name:
        message = f"ສຳເລັດການດຶງຂໍ້ມູນບ້ານໃນແຂວງ {pro_name}."
    elif dis_name:
        message = f"ສຳເລັດການດຶງຂໍ້ມູນບ້ານໃນເມືອງ {dis_name}."
    else:
        message = "ສຳເລັດການດຶງຂໍ້ມູນບ້ານທັງໝົດ."

    serializer = VillageSerializer(queryset, many=True)

    return Response({
        "status": True,
        "message": message,
        "count": queryset.count(),
        "data": serializer.data
    }, status=status.HTTP_200_OK)

from rest_framework import viewsets
from .models import MTTB_DATA_Entry
from .serializers import MTTB_DATA_EntrySerializer

class Data_EntryViewSet(viewsets.ModelViewSet):
    queryset = MTTB_DATA_Entry.objects.all()
    serializer_class = MTTB_DATA_EntrySerializer

    def get_permissions(self):
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]
    
    def perform_create(self, serializer):
        maker = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
            Maker_Id=maker,
            Maker_DT_Stamp=timezone.now()
        )
    
    def perform_update(self, serializer):
        checker = self.request.user if self.request.user and self.request.user.is_authenticated else None
        serializer.save(
            Checker_Id=checker,
            Checker_DT_Stamp=timezone.now()
        )

from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .models import MTTB_GLMaster, MTTB_GLSub
from .serializers import GLSubSerializer

@api_view(['GET'])
def GLTreeAPIView(request, gl_code_id):
    """
    Get GLSub details by GL code ID
    
    Args:
        gl_code_id: The primary key (glid) of MTTB_GLMaster
    
    Returns:
        JSON response with GLSub details and related GLMaster info
    """
    try:
        # Verify GL Master exists
        gl_master = get_object_or_404(MTTB_GLMaster, glid=gl_code_id)
        
        # Get all GLSub records for this GL code
        glsub_records = MTTB_GLSub.objects.filter(
            gl_code=gl_master,
           
        ).select_related('gl_code')
        
        if not glsub_records.exists():
            return Response({
                'success': False,
                'message': f'No GLSub records found for GL code ID: {gl_code_id}',
                'data': []
            }, status=status.HTTP_404_NOT_FOUND)
        
        # Serialize the data
        serializer = GLSubSerializer(glsub_records, many=True)
        
        return Response({
            'success': True,
            'message': f'Found {glsub_records.count()} GLSub record(s)',
            'gl_master_info': {
                'glid': gl_master.glid,
                'gl_code': gl_master.gl_code,
                'gl_Desc_en': gl_master.gl_Desc_en,
                'gl_Desc_la': gl_master.gl_Desc_la
            },
            'data': serializer.data
        }, status=status.HTTP_200_OK)
        
    except MTTB_GLMaster.DoesNotExist:
        return Response({
            'success': False,
            'message': f'GL Master with ID {gl_code_id} not found',
            'data': []
        }, status=status.HTTP_404_NOT_FOUND)
    
    except Exception as e:
        return Response({
            'success': False,
            'message': f'An error occurred: {str(e)}',
            'data': []
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    

# from rest_framework import status
# from rest_framework.decorators import api_view
# from rest_framework.response import Response
# from django.shortcuts import get_object_or_404
# from .models import MTTB_GLMaster, MTTB_GLSub
# from .serializers import GLSubSerializer
# from collections import defaultdict

# @api_view(['GET'])
# def GLTreeAll(request, gl_code_id=None):
#     """
#     Get GLSub details by GL code ID, or get all GLSub records grouped by GL Master
    
#     Args:
#         gl_code_id: Optional - The primary key (glid) of MTTB_GLMaster
#                    If provided, returns GLSub records for that specific GL Master
#                    If None, returns all GLSub records grouped by their GL Master
    
#     Returns:
#         JSON response with GLSub details grouped by GLMaster info
#     """
#     try:
#         if gl_code_id is not None:
#             # Get GLSub records for specific GL Master (existing functionality)
#             gl_master = get_object_or_404(MTTB_GLMaster, glid=gl_code_id)
            
#             glsub_records = MTTB_GLSub.objects.filter(
#                 gl_code=gl_master,
#             ).select_related('gl_code')
            
#             if not glsub_records.exists():
#                 return Response({
#                     'success': False,
#                     'message': f'No GLSub records found for GL code ID: {gl_code_id}',
#                     'data': []
#                 }, status=status.HTTP_404_NOT_FOUND)
            
#             # Serialize the data
#             serializer = GLSubSerializer(glsub_records, many=True)
            
#             return Response({
#                 'success': True,
#                 'message': f'Found {glsub_records.count()} GLSub record(s)',
#                 'gl_master_info': {
#                     'glid': gl_master.glid,
#                     'gl_code': gl_master.gl_code,
#                     'gl_Desc_en': gl_master.gl_Desc_en,
#                     'gl_Desc_la': gl_master.gl_Desc_la,
#                     'glType': gl_master.glType,
#                     'category': gl_master.category,
#                     'retal': gl_master.retal,
#                     'ccy_Res': gl_master.ccy_Res,
#                     'Res_ccy': gl_master.Res_ccy,
#                     'Record_Status': gl_master.Record_Status,
#                     'Auth_Status': gl_master.Auth_Status
#                 },
#                 'data': serializer.data
#             }, status=status.HTTP_200_OK)
            
#         else:
#             # CORRECTED LOGIC: Find all GLSub records and group by GL Master
            
#             # Step 1: Get all GLSub records with their GL Master info
#             glsub_records = MTTB_GLSub.objects.all().select_related('gl_code')
            
#             if not glsub_records.exists():
#                 return Response({
#                     'success': False,
#                     'message': 'No GLSub records found in the system',
#                     'data': []
#                 }, status=status.HTTP_404_NOT_FOUND)
            
#             # Step 2: Group GLSub records by GL Master
#             gl_master_groups = defaultdict(list)
            
#             for glsub in glsub_records:
#                 if glsub.gl_code:  # Make sure gl_code exists
#                     gl_master_groups[glsub.gl_code].append(glsub)
            
#             # Step 3: Build the tree structure
#             tree_data = []
#             total_glsub_count = 0
            
#             for gl_master, glsub_list in gl_master_groups.items():
#                 # Serialize GLSub records for this GL Master
#                 glsub_serializer = GLSubSerializer(glsub_list, many=True)
                
#                 # Build GL Master node with children
#                 gl_master_node = {
#                     'gl_master_info': {
#                         'glid': gl_master.glid,
#                         'gl_code': gl_master.gl_code,
#                         'gl_Desc_en': gl_master.gl_Desc_en,
#                         'gl_Desc_la': gl_master.gl_Desc_la,
#                         'glType': gl_master.glType,
#                         'category': gl_master.category,
#                         'Record_Status': gl_master.Record_Status,
#                         'Auth_Status': gl_master.Auth_Status
#                     },
#                     'children_count': len(glsub_list),
#                     'children': glsub_serializer.data
#                 }
                
#                 tree_data.append(gl_master_node)
#                 total_glsub_count += len(glsub_list)
            
#             # Sort by GL Master glid for consistent ordering
#             tree_data.sort(key=lambda x: x['gl_master_info']['glid'])
            
#             return Response({
#                 'success': True,
#                 'message': f'Found {len(tree_data)} GL Master(s) with {total_glsub_count} total GLSub record(s)',
#                 'total_gl_masters': len(tree_data),
#                 'total_glsub_records': total_glsub_count,
#                 'data': tree_data
#             }, status=status.HTTP_200_OK)
        
#     except MTTB_GLMaster.DoesNotExist:
#         return Response({
#             'success': False,
#             'message': f'GL Master with ID {gl_code_id} not found',
#             'data': []
#         }, status=status.HTTP_404_NOT_FOUND)
    
#     except Exception as e:
#         return Response({
#             'success': False,
#             'message': f'An error occurred: {str(e)}',
#             'data': []
#         }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .models import MTTB_GLMaster, MTTB_GLSub
from .serializers import GLSubSerializer
from collections import defaultdict

@api_view(['GET'])
def GLTreeAll(request, gl_code_id=None):
    """
    Get GLSub details by GL code ID (glid) or gl_code string, or return all GLSub grouped by GLMaster.
    
    Query Parameters:
    - gl_code_id (int): Primary key of MTTB_GLMaster
    - gl_code (str or int): gl_code field of MTTB_GLMaster
    """
    try:
        gl_code_param = request.GET.get('gl_code', None)

        # If both gl_code_id and gl_code are provided, return an error
        if gl_code_id and gl_code_param:
            return Response({
                'success': False,
                'message': 'Please provide only one of gl_code_id or gl_code',
                'data': []
            }, status=status.HTTP_400_BAD_REQUEST)

        gl_master = None

        if gl_code_id:
            gl_master = get_object_or_404(MTTB_GLMaster, glid=gl_code_id)
        elif gl_code_param:
            gl_master = get_object_or_404(MTTB_GLMaster, gl_code=str(gl_code_param))

        # If either gl_code_id or gl_code was used, return filtered GLSub
        if gl_master:
            glsub_records = MTTB_GLSub.objects.filter(
                gl_code=gl_master
            ).select_related('gl_code')

            if not glsub_records.exists():
                return Response({
                    'success': False,
                    'message': 'No GLSub records found for the provided GL code.',
                    'data': []
                }, status=status.HTTP_404_NOT_FOUND)

            serializer = GLSubSerializer(glsub_records, many=True)

            return Response({
                'success': True,
                'message': f'Found {glsub_records.count()} GLSub record(s)',
                'gl_master_info': {
                    'glid': gl_master.glid,
                    'gl_code': gl_master.gl_code,
                    'gl_Desc_en': gl_master.gl_Desc_en,
                    'gl_Desc_la': gl_master.gl_Desc_la,
                    'glType': gl_master.glType,
                    'category': gl_master.category,
                    'retal': gl_master.retal,
                    'ccy_Res': getattr(gl_master.ccy_Res, 'ccy_code', gl_master.ccy_Res),
                    'Res_ccy': getattr(gl_master.Res_ccy, 'ccy_code', gl_master.Res_ccy),
                    'Record_Status': gl_master.Record_Status,
                    'Auth_Status': gl_master.Auth_Status
                },
                'data': serializer.data
            }, status=status.HTTP_200_OK)

        # If no filtering, return full GL tree
        glsub_records = MTTB_GLSub.objects.all().select_related('gl_code')

        if not glsub_records.exists():
            return Response({
                'success': False,
                'message': 'No GLSub records found in the system',
                'data': []
            }, status=status.HTTP_404_NOT_FOUND)

        gl_master_groups = defaultdict(list)
        for glsub in glsub_records:
            if glsub.gl_code:
                gl_master_groups[glsub.gl_code].append(glsub)

        tree_data = []
        total_glsub_count = 0

        for gl_master, glsub_list in gl_master_groups.items():
            glsub_serializer = GLSubSerializer(glsub_list, many=True)
            gl_master_node = {
                'gl_master_info': {
                    'glid': gl_master.glid,
                    'gl_code': gl_master.gl_code,
                    'gl_Desc_en': gl_master.gl_Desc_en,
                    'gl_Desc_la': gl_master.gl_Desc_la,
                    'glType': gl_master.glType,
                    'category': gl_master.category,
                    'Record_Status': gl_master.Record_Status,
                    'Auth_Status': gl_master.Auth_Status
                },
                'children_count': len(glsub_list),
                'children': glsub_serializer.data
            }
            tree_data.append(gl_master_node)
            total_glsub_count += len(glsub_list)

        tree_data.sort(key=lambda x: x['gl_master_info']['glid'])

        return Response({
            'success': True,
            'message': f'Found {len(tree_data)} GL Master(s) with {total_glsub_count} total GLSub record(s)',
            'total_gl_masters': len(tree_data),
            'total_glsub_records': total_glsub_count,
            'data': tree_data
        }, status=status.HTTP_200_OK)

    except MTTB_GLMaster.DoesNotExist:
        return Response({
            'success': False,
            'message': 'GL Master not found',
            'data': []
        }, status=status.HTTP_404_NOT_FOUND)

    except Exception as e:
        return Response({
            'success': False,
            'message': f'An error occurred: {str(e)}',
            'data': []
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.db import transaction
from django.utils import timezone
from django.db.models import Q, Sum
from datetime import datetime, time, timedelta
import logging
from .models import (DETB_JRNL_LOG, 
                     MTTB_GLSub, MTTB_GLMaster,
                     MTTB_TRN_Code, 
                     DETB_JRNL_LOG_MASTER, 
                     DETB_JRNL_LOG_HIST, 
                     ACTB_DAIRY_LOG,
                     ACTB_DAIRY_LOG_HISTORY)
from .serializers import JRNLLogSerializer, JournalEntryBatchSerializer
from .utils import JournalEntryHelper

logger = logging.getLogger(__name__)

class JRNLLogViewSet(viewsets.ModelViewSet):
    parser_classes = [JSONParser]
    queryset = DETB_JRNL_LOG.objects.select_related(
        'Ccy_cd', 'Account', 'Account__gl_code', 'Txn_code', 
        'fin_cycle', 'Period_code', 'Maker_Id', 'Checker_Id', 'module_id'
    ).all().order_by('-Maker_DT_Stamp')
    
    serializer_class = JRNLLogSerializer
    permission_classes = [IsAuthenticated]
    filterset_fields = ['Reference_No', 'Ccy_cd', 'Dr_cr', 'Auth_Status', 'Txn_code']
    search_fields = ['Reference_No', 'Addl_text', 'Account__glsub_code', 'Account__glsub_Desc_la']
    ordering_fields = ['Maker_DT_Stamp', 'Value_date', 'Reference_No']

    def get_queryset(self):
        queryset = super().get_queryset()
        
        # Filter by date range
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        
        if start_date:
            queryset = queryset.filter(Value_date__gte=start_date)
        if end_date:
            queryset = queryset.filter(Value_date__lte=end_date)
        
        # Filter by account
        account_id = self.request.query_params.get('account_id')
        if account_id:
            queryset = queryset.filter(Account_id=account_id)

        # Filter by Currency
        ccy_cd = self.request.query_params.get('Ccy_cd')
        if ccy_cd:
            queryset = queryset.filter(Ccy_cd_id=ccy_cd)

        Auth_Status = self.request.query_params.get('Auth_Status')
        if Auth_Status:
            queryset = queryset.filter(Auth_Status=Auth_Status)

        # Filter by Reference_No
        Reference_No = self.request.query_params.get('Reference_No')
        if Reference_No:
            queryset = queryset.filter(Reference_No=Reference_No).order_by('JRNLLog_id')
            

        return queryset

    def perform_create(self, serializer):
        """Set audit fields on creation"""
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now(),
            Auth_Status='U'  
        )

    def perform_update(self, serializer):
        """Update only if not authorized"""
        instance = serializer.instance
        if instance.Auth_Status == 'A':
            raise serializer.ValidationError("Cannot modify authorized entries.")
        
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )
        
   
        
    @action(detail=False, methods=['post'])
    def batch_create(self, request):
        """Create multiple journal entries in a single transaction"""
        serializer = JournalEntryBatchSerializer(data=request.data)
        
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        data = serializer.validated_data
        
        try:
            with transaction.atomic():
                # Auto-generate reference number if not provided
                if not data.get('Reference_No'):
                    data['Reference_No'] = JournalEntryHelper.generate_reference_number(
                        module_id=data.get('module_id', 'GL'),
                        txn_code=data['Txn_code'],
                        date=data['Value_date'].date() if data.get('Value_date') else None
                    )
                
                # Get exchange rate
                exchange_rate = self.get_exchange_rate(data['Ccy_cd'])
                
                created_entries = []
                history_entries = []
                daily_log_entries = []
                
                # Generate base timestamp for unique history references
                base_timestamp = timezone.now().strftime("%H%M%S")  # HHMMSS format (6 chars)
                
                # Counter for Reference_sub_No, incrementing for each pair
                pair_counter = 1
                
                # Process entries in pairs (assuming entries are ordered as D, C pairs)
                for idx in range(0, len(data['entries']), 2):  # Step by 2 for pairs
                    ref_sub_no = f"{data['Reference_No']}-{pair_counter:03d}"
                    
                    # Process each entry in the pair (usually D and C)
                    for pair_idx in range(2):
                        if idx + pair_idx >= len(data['entries']):
                            break  # Avoid index out of range if odd number of entries
                        entry_data = data['entries'][idx + pair_idx]
                        
                        # Calculate amounts based on Dr_cr
                        fcy_amount = Decimal(str(entry_data['Amount']))
                        lcy_amount = fcy_amount * exchange_rate
                        
                        # Set debit/credit amounts
                        fcy_dr = fcy_amount if entry_data['Dr_cr'] == 'D' else Decimal('0.00')
                        fcy_cr = fcy_amount if entry_data['Dr_cr'] == 'C' else Decimal('0.00')
                        lcy_dr = lcy_amount if entry_data['Dr_cr'] == 'D' else Decimal('0.00')
                        lcy_cr = lcy_amount if entry_data['Dr_cr'] == 'C' else Decimal('0.00')
                        
                        addl_sub_text = (
                            entry_data.get('Addl_sub_text') or 
                            data.get('Addl_sub_text', '') or 
                            f"Entry for {entry_data['Dr_cr']} {fcy_amount}"
                        )

                        account_no = entry_data.get('Account_no')
                        current_time = timezone.now()

                        # Create journal entry
                        journal_entry = DETB_JRNL_LOG.objects.create(
                            module_id_id=data.get('module_id'),
                            Reference_No=data['Reference_No'],
                            Reference_sub_No=ref_sub_no,
                            Ccy_cd_id=data['Ccy_cd'],
                            Fcy_Amount=fcy_amount,
                            Lcy_Amount=lcy_amount,
                            fcy_dr=fcy_dr,
                            fcy_cr=fcy_cr,
                            lcy_dr=lcy_dr,
                            lcy_cr=lcy_cr,
                            Dr_cr=entry_data['Dr_cr'],
                            Ac_relatives=entry_data.get('Ac_relatives'),
                            Account_id=entry_data['Account'],
                            Account_no=account_no,
                            Txn_code_id=data['Txn_code'],
                            Value_date=data['Value_date'],
                            Exch_rate=exchange_rate,
                            fin_cycle_id=data.get('fin_cycle'),
                            Period_code_id=data.get('Period_code'),
                            Addl_text=data.get('Addl_text', ''),
                            Addl_sub_text=addl_sub_text,
                            Maker_Id=request.user,
                            Maker_DT_Stamp=current_time,
                            Auth_Status='U'
                        )

                        created_entries.append(journal_entry)

                        # Create history entry
                        history_entry = DETB_JRNL_LOG_HIST.objects.create(
                            Reference_No=data['Reference_No'],
                            Reference_sub_No=ref_sub_no,
                            module_id_id=data.get('module_id'),
                            Ccy_cd_id=data['Ccy_cd'],
                            Fcy_Amount=fcy_amount,
                            Lcy_Amount=lcy_amount,
                            fcy_dr=fcy_dr,
                            fcy_cr=fcy_cr,
                            lcy_dr=lcy_dr,
                            lcy_cr=lcy_cr,
                            Dr_cr=entry_data['Dr_cr'],
                            Ac_relatives=entry_data.get('Ac_relatives'),
                            Account_id=entry_data['Account'],
                            Account_no=account_no,
                            Txn_code_id=data['Txn_code'],
                            Value_date=data['Value_date'],
                            Exch_rate=exchange_rate,
                            fin_cycle_id=data.get('fin_cycle'),
                            Period_code_id=data.get('Period_code'),
                            Addl_text=data.get('Addl_text', ''),
                            Addl_sub_text=addl_sub_text,
                            Maker_Id=request.user,
                            Maker_DT_Stamp=current_time,
                            Auth_Status='U'
                        )
                        
                        history_entries.append(history_entry)

                        try:
                            glsub_account = MTTB_GLSub.objects.select_related('gl_code').get(
                                glsub_id=entry_data['Account']
                            )
                            gl_master = glsub_account.gl_code
                        except MTTB_GLSub.DoesNotExist:
                            logger.warning(f"GLSub account {entry_data['Account']} not found")
                            gl_master = None
                    
                    # Increment pair counter after processing each pair
                    pair_counter += 1

                if created_entries:
                    entry_seq_no = len(created_entries) 
                    first = created_entries[0]
                    reference_no = first.Reference_No
                    module_id = first.module_id
                    ccy_cd = first.Ccy_cd
                    Txn_code = first.Txn_code
                    value_date = first.Value_date
                    exch_rate = first.Exch_rate
                    fin_cycle = first.fin_cycle
                    period_code = first.Period_code
                    addl_text = first.Addl_text

                    total_fcy = sum(e.fcy_dr for e in created_entries)
                    total_lcy = sum(e.lcy_dr for e in created_entries)
                
                    master_entry = DETB_JRNL_LOG_MASTER.objects.create(
                        module_id=module_id,
                        Reference_No=reference_no,
                        Ccy_cd=ccy_cd,
                        Fcy_Amount=total_fcy,
                        Lcy_Amount=total_lcy,
                        Txn_code=Txn_code,
                        Value_date=value_date,
                        Exch_rate=exch_rate,
                        fin_cycle=fin_cycle,
                        Period_code=period_code,
                        Addl_text=addl_text,
                        Maker_Id=request.user,
                        Maker_DT_Stamp=timezone.now(),
                        Auth_Status='U',
                        entry_seq_no=entry_seq_no 
                    )

                    logger.info(f"Journal batch created - Reference: {reference_no}, Entries: {len(created_entries)}, History: {len(history_entries)}")
                
                response_serializer = JRNLLogSerializer(created_entries, many=True)
                response_data = response_serializer.data

                for idx, entry in enumerate(created_entries):
                    response_data[idx]['Account_id'] = entry.Account.glsub_code
                
                return Response({
                    'message': f'Successfully created {len(created_entries)} journal entries with history',
                    'reference_no': data['Reference_No'],
                    'entries_created': len(created_entries),
                    'history_entries_created': len(history_entries),
                    'daily_log_entries_created': len(daily_log_entries),
                    'entries': response_data
                }, status=status.HTTP_201_CREATED)
                
        except Exception as e:
            logger.error(f"Error creating batch journal entries with history: {str(e)}")
            return Response({
                'error': 'Failed to create journal entries',
                'detail': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)

    # Pherm  Fucttion Delete by Pair 
    # --------------------------------------
    @action(detail=False, methods=['delete'], url_path='delete-by-pair-account')
    def delete_by_pair_account(self, request):
        """Delete journal entries by Reference_sub_No with related records"""
        reference_sub_no = request.data.get('Reference_sub_No')

        if not reference_sub_no:
            return Response({
                'error': 'Missing required field',
                'detail': 'Reference_sub_No is required'
            }, status=status.HTTP_400_BAD_REQUEST)

        try:
            with transaction.atomic():
                # Find journal entries matching the Reference_sub_No
                journal_entries = DETB_JRNL_LOG.objects.filter(
                    Reference_sub_No=reference_sub_no
                )

                if not journal_entries.exists():
                    return Response({
                        'error': 'No matching journal entries found',
                        'detail': f'No entries found for Reference_sub_No: {reference_sub_no}'
                    }, status=status.HTTP_404_NOT_FOUND)

                # Verify exactly two entries (debit and credit pair)
                if len(journal_entries) != 2:
                    return Response({
                        'error': 'Incomplete pair found',
                        'detail': 'Expected exactly two paired entries (debit and credit)'
                    }, status=status.HTTP_400_BAD_REQUEST)

                # Verify debit/credit pairing
                dr_cr_values = {entry.Dr_cr for entry in journal_entries}
                if dr_cr_values != {'D', 'C'}:
                    return Response({
                        'error': 'Invalid debit/credit pair',
                        'detail': 'Paired entries must include one debit (D) and one credit (C)'
                    }, status=status.HTTP_400_BAD_REQUEST)

                # Get Reference_No for master entry deletion and logging
                reference_no = journal_entries.first().Reference_No

                # Delete related records
                deleted_counts = {
                    'journal_entries': 0,
                    'history_entries': 0,
                    'daily_log_entries': 0,
                    'daily_log_history_entries': 0,
                    'master_entry': 0
                }

                # Delete journal entries
                deleted_counts['journal_entries'] = journal_entries.delete()[0]

                # Delete corresponding history entries
                history_entries = DETB_JRNL_LOG_HIST.objects.filter(
                    Reference_sub_No=reference_sub_no
                )
                deleted_counts['history_entries'] = history_entries.delete()[0]

                # Delete master entry if it exists and no other journal entries remain for the Reference_No
                if not DETB_JRNL_LOG.objects.filter(Reference_No=reference_no).exists():
                    master_entry = DETB_JRNL_LOG_MASTER.objects.filter(
                        Reference_No=reference_no
                    )
                    deleted_counts['master_entry'] = master_entry.delete()[0]

                # Log deletion
                logger.info(f"Deleted journal batch - Reference_sub_No: {reference_sub_no}, "
                            f"Reference_No: {reference_no}, "
                            f"Counts: {deleted_counts}")

                return Response({
                    'message': 'Successfully deleted journal entries and related records',
                    'reference_sub_no': reference_sub_no,
                    'reference_no': reference_no,
                    'deleted_counts': deleted_counts
                }, status=status.HTTP_200_OK)

        except Exception as e:
            logger.error(f"Error deleting journal entries for Reference_sub_No: {reference_sub_no}: {str(e)}")
            return Response({
                'error': 'Failed to delete journal entries',
                'detail': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)
    @action(detail=False, methods=['post'], url_path='reject-by-pair-account')
    def reject_by_pair_account(self, request):
        """Reject journal entries by Reference_sub_No and set Auth_Status to 'P' (pending fix) with comments"""
        reference_sub_no = request.data.get('Reference_sub_No')
        comments = request.data.get('comments')

        # Validate required fields
        if not reference_sub_no:
            return Response({
                'error': 'Missing required field',
                'detail': 'Reference_sub_No is required'
            }, status=status.HTTP_400_BAD_REQUEST)

        if not comments:
            return Response({
                'error': 'Missing required field',
                'detail': 'Comments are required for rejection'
            }, status=status.HTTP_400_BAD_REQUEST)

        if len(comments) > 1000:
            return Response({
                'error': 'Invalid comments',
                'detail': 'Comments must not exceed 1000 characters'
            }, status=status.HTTP_400_BAD_REQUEST)

        try:
            with transaction.atomic():
                # Find journal entries matching the Reference_sub_No
                journal_entries = DETB_JRNL_LOG.objects.filter(
                    Reference_sub_No=reference_sub_no
                )

                if not journal_entries.exists():
                    return Response({
                        'error': 'No matching journal entries found',
                        'detail': f'No entries found for Reference_sub_No: {reference_sub_no}'
                    }, status=status.HTTP_404_NOT_FOUND)

                # Verify exactly two entries (debit and credit pair)
                if len(journal_entries) != 2:
                    return Response({
                        'error': 'Incomplete pair found',
                        'detail': 'Expected exactly two paired entries (debit and credit)'
                    }, status=status.HTTP_400_BAD_REQUEST)

                # Verify debit/credit pairing
                dr_cr_values = {entry.Dr_cr for entry in journal_entries}
                if dr_cr_values != {'D', 'C'}:
                    return Response({
                        'error': 'Invalid debit/credit pair',
                        'detail': 'Paired entries must include one debit (D) and one credit (C)'
                    }, status=status.HTTP_400_BAD_REQUEST)

                # Get Reference_No for master entry update
                reference_no = journal_entries.first().Reference_No

                # Update Auth_Status and comments for journal entries
                updated_counts = {
                    'journal_entries': 0,
                    'history_entries': 0,
                    'master_entry': 0
                }
                updated_counts['journal_entries'] = journal_entries.update(
                    Auth_Status='P',
                    Checker_DT_Stamp=timezone.now(),
                    Checker_Id=request.user,
                    comments=comments
                )

                # Update corresponding history entries
                history_entries = DETB_JRNL_LOG_HIST.objects.filter(
                    Reference_sub_No=reference_sub_no
                )
                updated_counts['history_entries'] = history_entries.update(
                    Auth_Status='P',
                    Checker_DT_Stamp=timezone.now(),
                    Checker_Id=request.user,
                    comments=comments
                )

                # Update master entry if it exists
                master_entry = DETB_JRNL_LOG_MASTER.objects.filter(
                    Reference_No=reference_no
                )
                if master_entry.exists():
                    updated_counts['master_entry'] = master_entry.update(
                        Auth_Status='P',
                        Checker_DT_Stamp=timezone.now(),
                        Checker_Id=request.user
                    )

                # Log rejection
                logger.info(f"Rejected journal batch - Reference_sub_No: {reference_sub_no}, "
                           f"Reference_No: {reference_no}, "
                           f"Comments: {comments}, "
                           f"Counts: {updated_counts}")

                return Response({
                    'message': 'Successfully rejected journal entries and set Auth_Status to P',
                    'reference_sub_no': reference_sub_no,
                    'reference_no': reference_no,
                    'comments': comments,
                    'updated_counts': updated_counts
                }, status=status.HTTP_200_OK)

        except Exception as e:
            logger.error(f"Error rejecting journal entries for Reference_sub_No: {reference_sub_no}: {str(e)}")
            return Response({
                'error': 'Failed to reject journal entries',
                'detail': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)
        
    @action(detail=False, methods=['post'], url_path='fix-rejected')
    def fix_rejected(self, request):
        """Fix rejected journal entries for a Reference_sub_No by updating DETB_JRNL_LOG and inserting new DETB_JRNL_LOG_HIST entries"""
        reference_sub_no = request.data.get('Reference_sub_No')
        comments = request.data.get('comments')
        fcy_amount = request.data.get('Fcy_Amount')
        addl_text = request.data.get('Addl_text')
        addl_sub_text = request.data.get('Addl_sub_text')
        glsub_id = request.data.get('glsub_id')  # For debit entry
        relative_glsub_id = request.data.get('relative_glsub_id')  # For credit entry

        # Validate required fields
        if not reference_sub_no:
            return Response({
                'error': 'Missing required field',
                'detail': 'Reference_sub_No is required'
            }, status=status.HTTP_400_BAD_REQUEST)

        if not comments:
            return Response({
                'error': 'Missing required field',
                'detail': 'Comments are required for fixing rejected entries'
            }, status=status.HTTP_400_BAD_REQUEST)

        if len(comments) > 1000:
            return Response({
                'error': 'Invalid comments',
                'detail': 'Comments must not exceed 1000 characters'
            }, status=status.HTTP_400_BAD_REQUEST)

        # Validate Fcy_Amount if provided
        if fcy_amount is not None:
            try:
                fcy_amount = Decimal(str(fcy_amount))
                if fcy_amount < 0:
                    raise ValueError
            except (ValueError, TypeError):
                return Response({
                    'error': 'Invalid Fcy_Amount',
                    'detail': 'Fcy_Amount must be a valid non-negative decimal'
                }, status=status.HTTP_400_BAD_REQUEST)

        # Validate glsub_id and relative_glsub_id if provided
        glsub = None
        relative_glsub = None
        if glsub_id is not None or relative_glsub_id is not None:
            if not (glsub_id and relative_glsub_id):
                return Response({
                    'error': 'Missing account fields',
                    'detail': 'Both glsub_id and relative_glsub_id must be provided together'
                }, status=status.HTTP_400_BAD_REQUEST)
            try:
                glsub = MTTB_GLSub.objects.get(glsub_id=glsub_id)
                relative_glsub = MTTB_GLSub.objects.get(glsub_id=relative_glsub_id)
            except MTTB_GLSub.DoesNotExist:
                return Response({
                    'error': 'Invalid account IDs',
                    'detail': f'glsub_id {glsub_id} or relative_glsub_id {relative_glsub_id} not found'
                }, status=status.HTTP_400_BAD_REQUEST)

        try:
            with transaction.atomic():
                # Find journal entries matching the Reference_sub_No
                journal_entries = DETB_JRNL_LOG.objects.filter(
                    Reference_sub_No=reference_sub_no,
                    Auth_Status__in=['P','U']
                )

                if not journal_entries.exists():
                    return Response({
                        'error': 'No matching rejected journal entries found',
                        'detail': f'No entries found for Reference_sub_No: {reference_sub_no} with Auth_Status P'
                    }, status=status.HTTP_404_NOT_FOUND)

                # Verify exactly two entries (debit and credit pair)
                if len(journal_entries) != 2:
                    return Response({
                        'error': 'Incomplete pair found',
                        'detail': 'Expected exactly two paired entries (debit and credit)'
                    }, status=status.HTTP_400_BAD_REQUEST)

                # Verify debit/credit pairing
                dr_cr_values = {entry.Dr_cr for entry in journal_entries}
                if dr_cr_values != {'D', 'C'}:
                    return Response({
                        'error': 'Invalid debit/credit pair',
                        'detail': 'Paired entries must include one debit (D) and one credit (C)'
                    }, status=status.HTTP_400_BAD_REQUEST)

                # Get Reference_No for master entry update
                reference_no = journal_entries.first().Reference_No

                # Prepare update fields for journal entries
                update_fields = {
                    'Auth_Status': 'U',
                    'Checker_DT_Stamp': timezone.now(),
                    'Checker_Id': request.user,
                    'comments': comments
                }
                if fcy_amount is not None:
                    update_fields['Fcy_Amount'] = fcy_amount
                    update_fields['Lcy_Amount'] = None  # Will be calculated per entry
                    update_fields['fcy_dr'] = None
                    update_fields['fcy_cr'] = None
                    update_fields['lcy_dr'] = None
                    update_fields['lcy_cr'] = None
                if addl_text is not None:
                    update_fields['Addl_text'] = addl_text[:255]
                if addl_sub_text is not None:
                    update_fields['Addl_sub_text'] = addl_sub_text[:255]
                if glsub_id is not None:
                    update_fields['Account'] = None  # ✅ FIXED: Use 'Account' not 'Account_id'
                    update_fields['Account_no'] = None
                    update_fields['Ac_relatives'] = None

                # Update journal entries and create history entries
                updated_counts = {
                    'journal_entries': 0,
                    'history_entries': 0,
                    'master_entry': 0
                }
                history_entries_created = []

                # Process debit and credit entries
                debit_entry = next(e for e in journal_entries if e.Dr_cr == 'D')
                credit_entry = next(e for e in journal_entries if e.Dr_cr == 'C')

                for entry, new_account, paired_account in [
                    (debit_entry, glsub, relative_glsub),
                    (credit_entry, relative_glsub, glsub)
                ]:
                    # Calculate amounts if Fcy_Amount is provided
                    if fcy_amount is not None:
                        exchange_rate = entry.Exch_rate
                        lcy_amount = fcy_amount * exchange_rate
                        update_fields.update({
                            'Lcy_Amount': lcy_amount,
                            'fcy_dr': fcy_amount if entry.Dr_cr == 'D' else Decimal('0.00'),
                            'fcy_cr': fcy_amount if entry.Dr_cr == 'C' else Decimal('0.00'),
                            'lcy_dr': lcy_amount if entry.Dr_cr == 'D' else Decimal('0.00'),
                            'lcy_cr': lcy_amount if entry.Dr_cr == 'C' else Decimal('0.00')
                        })

                    # Update account fields if provided
                    if new_account is not None:
                        update_fields.update({
                            'Account': new_account,  # ✅ FIXED: Use 'Account' not 'Account_id'
                            'Account_no': new_account.glsub_code,
                            'Ac_relatives': paired_account.glsub_id if paired_account else entry.Ac_relatives
                        })

                    # Update journal entry
                    for field, value in update_fields.items():
                        if value is not None:
                            setattr(entry, field, value)
                    entry.save()
                    updated_counts['journal_entries'] += 1

                    # Create new history entry
                    history_entry = DETB_JRNL_LOG_HIST.objects.create(
                        module_id_id=entry.module_id_id,
                        Reference_No=entry.Reference_No,
                        Reference_sub_No=entry.Reference_sub_No,
                        comments=comments,
                        Ccy_cd_id=entry.Ccy_cd_id,
                        Fcy_Amount=fcy_amount if fcy_amount is not None else entry.Fcy_Amount,
                        Lcy_Amount=update_fields.get('Lcy_Amount', entry.Lcy_Amount),
                        fcy_dr=update_fields.get('fcy_dr', entry.fcy_dr),
                        fcy_cr=update_fields.get('fcy_cr', entry.fcy_cr),
                        lcy_dr=update_fields.get('lcy_dr', entry.lcy_dr),
                        lcy_cr=update_fields.get('lcy_cr', entry.lcy_cr),
                        Dr_cr=entry.Dr_cr,
                        Ac_relatives=update_fields.get('Ac_relatives', entry.Ac_relatives),
                        Account=update_fields.get('Account', entry.Account),  # ✅ FIXED: Use 'Account' not 'Account_id'
                        Account_no=update_fields.get('Account_no', entry.Account_no),
                        Txn_code_id=entry.Txn_code_id,
                        Value_date=entry.Value_date,
                        Exch_rate=entry.Exch_rate,
                        fin_cycle_id=entry.fin_cycle_id,
                        Period_code_id=entry.Period_code_id,
                        Addl_text=addl_text[:255] if addl_text is not None else entry.Addl_text,
                        Addl_sub_text=addl_sub_text[:255] if addl_sub_text is not None else entry.Addl_sub_text,
                        Maker_Id=entry.Maker_Id,
                        Maker_DT_Stamp=entry.Maker_DT_Stamp,
                        Checker_Id=request.user,
                        Checker_DT_Stamp=timezone.now(),
                        Auth_Status='U'
                    )
                    history_entries_created.append(history_entry)
                    updated_counts['history_entries'] += 1

                # Update master entry
                master_entry = DETB_JRNL_LOG_MASTER.objects.filter(Reference_No=reference_no)
                if master_entry.exists():
                    # Recalculate total Fcy_Amount and Lcy_Amount for the Reference_No
                    all_entries = DETB_JRNL_LOG.objects.filter(Reference_No=reference_no)
                    total_fcy = sum(e.fcy_dr for e in all_entries)
                    total_lcy = sum(e.lcy_dr for e in all_entries)
                    updated_counts['master_entry'] = master_entry.update(
                        Auth_Status='U',
                        Checker_DT_Stamp=timezone.now(),
                        Checker_Id=request.user,
                        Fcy_Amount=total_fcy,
                        Lcy_Amount=total_lcy
                    )

                # Log the fix
                logger.info(f"Fixed rejected journal batch - Reference_sub_No: {reference_sub_no}, "
                        f"Reference_No: {reference_no}, "
                        f"Comments: {comments}, "
                        f"glsub_id: {glsub_id}, "
                        f"relative_glsub_id: {relative_glsub_id}, "
                        f"Counts: {updated_counts}")

                return Response({
                    'message': 'Successfully fixed rejected journal entries and set Auth_Status to U',
                    'reference_sub_no': reference_sub_no,
                    'reference_no': reference_no,
                    'comments': comments,
                    'glsub_id': glsub_id,
                    'relative_glsub_id': relative_glsub_id,
                    'updated_counts': updated_counts
                }, status=status.HTTP_200_OK)

        except Exception as e:
            logger.error(f"Error fixing rejected journal entries for Reference_sub_No: {reference_sub_no}: {str(e)}")
            return Response({
                'error': 'Failed to fix rejected journal entries',
                'detail': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)  
        
    @action(detail=False, methods=['get'])
    def balance_check(self, request):
        """Check if journal entries are balanced by reference number"""
        reference_no = request.query_params.get('reference_no')
        
        if not reference_no:
            return Response({'error': 'reference_no parameter is required'}, 
                          status=status.HTTP_400_BAD_REQUEST)
        
        entries = DETB_JRNL_LOG.objects.filter(Reference_No=reference_no)
        
        if not entries.exists():
            return Response({'error': 'No entries found for this reference number'}, 
                          status=status.HTTP_404_NOT_FOUND)
        
        # Calculate totals
        totals = entries.aggregate(
            total_lcy_dr=Sum('lcy_dr'),
            total_lcy_cr=Sum('lcy_cr'),
            total_fcy_dr=Sum('fcy_dr'),
            total_fcy_cr=Sum('fcy_cr')
        )
        
        lcy_balanced = abs((totals['total_lcy_dr'] or 0) - (totals['total_lcy_cr'] or 0)) < 0.01
        fcy_balanced = abs((totals['total_fcy_dr'] or 0) - (totals['total_fcy_cr'] or 0)) < 0.01
        
        return Response({
            'reference_no': reference_no,
            'entry_count': entries.count(),
            'lcy_totals': {
                'debit': totals['total_lcy_dr'] or 0,
                'credit': totals['total_lcy_cr'] or 0,
                'balanced': lcy_balanced
            },
            'fcy_totals': {
                'debit': totals['total_fcy_dr'] or 0,
                'credit': totals['total_fcy_cr'] or 0,
                'balanced': fcy_balanced
            },
            'overall_balanced': lcy_balanced and fcy_balanced
        })

    @action(detail=False, methods=["post"], url_path="approve-asset")
    def approve_asset(self, request):
        reference_no = request.data.get("Ac_relatives")
        module_id = request.data.get("module_id", "AS")

        if not reference_no:
            return Response({"error": "Ac_relatives is required."}, status=status.HTTP_400_BAD_REQUEST)

        if module_id != "AS":
            return Response({"error": "Invalid module_id. This endpoint only supports module_id = 'AS'."},
                            status=status.HTTP_400_BAD_REQUEST)

        try:
            asset = FA_Asset_Lists.objects.get(
                asset_list_id=reference_no,
                asset_status__in=["UC", "AC"]  # Look for both UC and AC status
            )
        except FA_Asset_Lists.DoesNotExist:
            return Response(
                {"error": f"No asset found with Ac_relatives={reference_no} in status UC or AC"},
                status=status.HTTP_404_NOT_FOUND
            )

        # Determine which field to update based on asset_status
        if asset.asset_status == "UC":
            # Check if already approved
            if asset.Auth_Status == "A" and asset.Auth_Status_ARC == "A":
                return Response(
                    {"error": f"Asset {reference_no} (UC) has already been approved."},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Update Auth_Status for UC assets
            asset.Auth_Status = "A"
            message = f"Asset {reference_no} (UC) has been approved successfully."
            
        elif asset.asset_status == "AC":
            # Check if already approved
            if hasattr(asset, 'Auth_Status_ARC') and asset.Auth_Status_ARC == "A":
                return Response(
                    {"error": f"Asset {reference_no} (AC) has already been approved."},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Update Auth_Status_ARC for AC assets
            asset.Auth_Status_ARC = "A"
            message = f"Asset {reference_no} (AC) has been approved successfully."

        # Set common fields
        asset.Checker_Id = request.user
        asset.Checker_DT_Stamp = timezone.now()
        asset.save()

        return Response({
            "success": True,
            "message": message,
            "asset_status": asset.asset_status,
            "updated_field": "Auth_Status" if asset.asset_status == "UC" else "Auth_Status_ARC"
        }, status=status.HTTP_200_OK)
    
    @action(detail=False, methods=["post"], url_path="pending-asset")
    def pending_asset(self, request):
        reference_no = request.data.get("Ac_relatives")
        module_id = request.data.get("module_id", "AS")

        if not reference_no:
            return Response({"error": "Ac_relatives is required."}, status=status.HTTP_400_BAD_REQUEST)

        if module_id != "AS":
            return Response({"error": "Invalid module_id. This endpoint only supports module_id = 'AS'."},
                            status=status.HTTP_400_BAD_REQUEST)

        try:
            asset = FA_Asset_Lists.objects.get(
                asset_list_id=reference_no,
                asset_status__in=["UC", "AC"]  # Look for both UC and AC status
            )
        except FA_Asset_Lists.DoesNotExist:
            return Response(
                {"error": f"No asset found with Ac_relatives={reference_no} in status UC or AC"},
                status=status.HTTP_404_NOT_FOUND
            )

        # Determine which field to update based on asset_status
        if asset.asset_status == "UC":
            # Check if already approved
            if asset.Auth_Status == "A" and asset.Auth_Status_ARC == "A":
                return Response(
                    {"error": f"Asset {reference_no} (UC) has already been approved."},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Update Auth_Status for UC assets
            asset.Auth_Status = "P"
            message = f"Asset {reference_no} (UC) has been Pending successfully."
            
        elif asset.asset_status == "AC":
            # Check if already approved
            if hasattr(asset, 'Auth_Status_ARC') and asset.Auth_Status_ARC == "A":
                return Response(
                    {"error": f"Asset {reference_no} (AC) has already been approved."},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Update Auth_Status_ARC for AC assets
            asset.Auth_Status_ARC = "P"
            message = f"Asset {reference_no} (AC) has been Pending successfully."

        # Set common fields
        asset.Checker_Id = request.user
        asset.Checker_DT_Stamp = timezone.now()
        asset.save()

        return Response({
            "success": True,
            "message": message,
            "asset_status": asset.asset_status,
            "updated_field": "Auth_Status" if asset.asset_status == "UC" else "Auth_Status_ARC"
        }, status=status.HTTP_200_OK)


    @action(detail=False, methods=["post"], url_path="reject-asset")
    def reject_asset(self, request):
        reference_no = request.data.get("Ac_relatives")
        module_id = request.data.get("module_id", "AS")

        if not reference_no:
            return Response({"error": "Ac_relatives is required."}, status=status.HTTP_400_BAD_REQUEST)

        if module_id != "AS":
            return Response({"error": "Invalid module_id. This endpoint only supports module_id = 'AS'."},
                            status=status.HTTP_400_BAD_REQUEST)

        try:
            asset = FA_Asset_Lists.objects.get(
                asset_list_id=reference_no,
                asset_status__in=["UC", "AC"]  # Look for both UC and AC status
            )
        except FA_Asset_Lists.DoesNotExist:
            return Response(
                {"error": f"No asset found with Ac_relatives={reference_no} in status UC or AC"},
                status=status.HTTP_404_NOT_FOUND
            )

        # Determine which field to update based on asset_status
        if asset.asset_status == "UC":
            # Check if already rejected
            if asset.Auth_Status == "R" and asset.Auth_Status_ARC == "R":
                return Response(
                    {"error": f"Asset {reference_no} (UC) has already been rejected."},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Update Auth_Status for UC assets
            asset.Auth_Status = "R"
            message = f"Asset {reference_no} (UC) has been rejected successfully."

        elif asset.asset_status == "AC":
            # Check if already rejected
            if hasattr(asset, 'Auth_Status_ARC') and asset.Auth_Status_ARC == "R":
                return Response(
                    {"error": f"Asset {reference_no} (AC) has already been rejected."},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Update Auth_Status_ARC for AC assets
            asset.Auth_Status_ARC = "R"
            message = f"Asset {reference_no} (AC) has been rejected successfully."

        # Set common fields
        asset.Checker_Id = request.user
        asset.Checker_DT_Stamp = timezone.now()
        asset.save()

        return Response({
            "success": True,
            "message": message,
            "asset_status": asset.asset_status,
            "updated_field": "Auth_Status" if asset.asset_status == "UC" else "Auth_Status_ARC"
        }, status=status.HTTP_200_OK)


    @action(detail=False, methods=['post'], url_path='approve-all')
    def approve_all(self, request):
        """Approve all records (MASTER, LOG, HIST) for a Reference_No and insert into daily log tables"""
        reference_no = request.data.get('Reference_No')
        
        if not reference_no:
            return Response({'error': 'Reference_No is required'}, 
                        status=status.HTTP_400_BAD_REQUEST)
        
        # Check if any LOG entries have status 'P' or 'R'
        log_entries = DETB_JRNL_LOG.objects.filter(Reference_No=reference_no)
        if not log_entries.exists():
            return Response({'error': 'No entries found for this reference number'}, 
                        status=status.HTTP_404_NOT_FOUND)
        
        # Check for problematic entries
        problematic_entries = log_entries.filter(Auth_Status__in=['P', 'R'])
        if problematic_entries.exists():
            return Response({'error': 'Cannot approve: entries with status P or R found'}, 
                        status=status.HTTP_400_BAD_REQUEST)
        
        # Check if already approved
        if log_entries.filter(Auth_Status='A').exists():
            return Response({'error': 'Entries are already approved'}, 
                        status=status.HTTP_400_BAD_REQUEST)
        
        try:
            from django.db import transaction
            from django.utils import timezone
            
            with transaction.atomic():
                # Update DETB_JRNL_LOG
                log_updated = log_entries.update(
                    Auth_Status='A',
                    Checker_Id=request.user,
                    Checker_DT_Stamp=timezone.now()
                )
                
                # Update DETB_JRNL_LOG_MASTER
                try:
                    from .models import DETB_JRNL_LOG_MASTER
                    master_record = DETB_JRNL_LOG_MASTER.objects.get(Reference_No=reference_no)
                    master_record.Auth_Status = 'A'
                    master_record.Checker_Id = request.user
                    master_record.Checker_DT_Stamp = timezone.now()
                    master_record.save()
                    master_updated = 1
                except DETB_JRNL_LOG_MASTER.DoesNotExist:
                    master_updated = 0
                
                # Update DETB_JRNL_LOG_HIST (if exists)
                hist_updated = 0
                try:
                    from .models import DETB_JRNL_LOG_HIST
                    hist_updated = DETB_JRNL_LOG_HIST.objects.filter(
                        Reference_No=reference_no
                    ).update(
                        Auth_Status='A',
                        Checker_Id=request.user,
                        Checker_DT_Stamp=timezone.now()
                    )
                except:
                    pass  # HIST table might not exist
                
                # After successful approval, insert into daily log tables
                daily_log_entries_created = 0
                daily_log_hist_entries_created = 0
                
                try:
                    from .models import ACTB_DAIRY_LOG, ACTB_DAIRY_LOG_HISTORY
                    current_time = timezone.now()
                    
                    # Get the updated approved entries from DETB_JRNL_LOG
                    approved_entries = DETB_JRNL_LOG.objects.filter(
                        Reference_No=reference_no,
                        Auth_Status='A'
                    ).order_by('JRNLLog_id')
                    
                    for idx, entry in enumerate(approved_entries):
                        # Get GL Master info through the relationship chain:
                        # entry.Account (MTTB_GLSub) -> entry.Account.gl_code (MTTB_GLMaster)
                        gl_master = None
                        gl_type = None
                        category = None
                        
                        try:
                            if entry.Account and entry.Account.gl_code:
                                gl_master = entry.Account.gl_code  # This is the MTTB_GLMaster instance
                                gl_type = gl_master.glType
                                category = gl_master.category
                                print(f"Found GLMaster: {gl_master.glid}, Type: {gl_type}, Category: {category}")
                        except Exception as gl_error:
                            print(f"GLMaster lookup error: {gl_error}")
                        
                        # Calculate amounts based on Dr_cr indicator
                        fcy_amount = entry.Fcy_Amount or 0
                        lcy_amount = entry.Lcy_Amount or 0
                        exchange_rate = entry.Exch_rate or 1
                        
                        fcy_dr = fcy_amount if entry.Dr_cr == 'D' else 0
                        fcy_cr = fcy_amount if entry.Dr_cr == 'C' else 0
                        lcy_dr = lcy_amount if entry.Dr_cr == 'D' else 0
                        lcy_cr = lcy_amount if entry.Dr_cr == 'C' else 0
                        
                        # Prepare additional sub text
                        addl_sub_text = f"{entry.Addl_sub_text[:30] if entry.Addl_sub_text else ''}"
                        
                        # ACTB_DAIRY_LOG data (with ForeignKey references)
                        actb_log_data = {
                            'module': entry.module_id,  # ForeignKey to STTB_ModulesInfo
                            'trn_ref_no': entry.Reference_No,  # ForeignKey to DETB_JRNL_LOG (the entry itself!)
                            'trn_ref_sub_no': entry.Reference_sub_No,
                            'event_sr_no': idx + 1,
                            'event': 'JRNL',
                            'ac_no': entry.Account,  # ForeignKey to MTTB_GLSub
                            'ac_no_full': entry.Account_no,
                            'ac_relative': entry.Ac_relatives,
                            'ac_ccy': entry.Ccy_cd,  # ForeignKey to MTTB_Ccy_DEFN
                            'drcr_ind': entry.Dr_cr,
                            'trn_code': entry.Txn_code,  # ForeignKey to MTTB_TRN_Code
                            'fcy_amount': fcy_amount,
                            'exch_rate': exchange_rate,
                            'lcy_amount': lcy_amount,
                            'fcy_dr': fcy_dr,
                            'fcy_cr': fcy_cr,
                            'lcy_dr': lcy_dr,
                            'lcy_cr': lcy_cr,
                            'external_ref_no': '',
                            'addl_text': entry.Addl_text or '',
                            'addl_sub_text': addl_sub_text,
                            'trn_dt': entry.Value_date.date() if entry.Value_date else None,
                            'glid': gl_master,  # ForeignKey to MTTB_GLMaster
                            'glType': gl_type,  # CharField from GLMaster
                            'category': category,  # CharField from GLMaster
                            'value_dt': entry.Value_date.date() if entry.Value_date else None,
                            'financial_cycle': entry.fin_cycle,  # ForeignKey to MTTB_Fin_Cycle
                            'period_code': entry.Period_code,  # ForeignKey to MTTB_Per_Code
                            'Maker_id': request.user,  # ForeignKey to MTTB_Users
                            'Maker_DT_Stamp': current_time,
                            'Checker_id': request.user,  # ForeignKey to MTTB_Users (approver)
                            'Checker_DT_Stamp': current_time,
                            'Auth_Status': 'A',  # Authorized
                            'product': 'GL',
                            'entry_seq_no': idx + 1,
                            'delete_stat': None
                        }
                        
                        # ACTB_DAIRY_LOG_HISTORY data (with CharField references)
                        actb_hist_data = {
                            'module': entry.module_id,  # ForeignKey to STTB_ModulesInfo
                            'trn_ref_no': entry.Reference_No,  # CharField (Reference_No string)
                            'trn_ref_sub_no': entry.Reference_sub_No,
                            'event_sr_no': idx + 1,
                            'event': 'JRNL',
                            'ac_no': entry.Account,  # ForeignKey to MTTB_GLSub
                            'ac_no_full': entry.Account_no,
                            'ac_relative': entry.Ac_relatives,
                            'ac_ccy': entry.Ccy_cd,  # ForeignKey to MTTB_Ccy_DEFN
                            'drcr_ind': entry.Dr_cr,
                            'trn_code': entry.Txn_code,  
                            'fcy_amount': fcy_amount,
                            'exch_rate': exchange_rate,
                            'lcy_amount': lcy_amount,
                            'fcy_dr': fcy_dr,
                            'fcy_cr': fcy_cr,
                            'lcy_dr': lcy_dr,
                            'lcy_cr': lcy_cr,
                            'external_ref_no': '',
                            'addl_text': entry.Addl_text or '',
                            'addl_sub_text': addl_sub_text,
                            'trn_dt': entry.Value_date.date() if entry.Value_date else None,
                            'glid': gl_master,  # ForeignKey to MTTB_GLMaster
                            'glType': gl_type,  # CharField from GLMaster
                            'category': category,  # CharField from GLMaster
                            'value_dt': entry.Value_date.date() if entry.Value_date else None,
                            'financial_cycle': entry.fin_cycle,  # ForeignKey to MTTB_Fin_Cycle
                            'period_code': entry.Period_code,  # ForeignKey to MTTB_Per_Code
                            'Maker_id': request.user,  # ForeignKey to MTTB_Users
                            'Maker_DT_Stamp': current_time,
                            'Checker_id': request.user,  # ForeignKey to MTTB_Users (approver)
                            'Checker_DT_Stamp': current_time,
                            'Auth_Status': 'A',  # Authorized
                            'product': 'GL',
                            'entry_seq_no': idx + 1,
                            'delete_stat': None
                        }
                        
                        # Create ACTB_DAIRY_LOG entry
                        try:
                            daily_log_entry = ACTB_DAIRY_LOG.objects.create(**actb_log_data)
                            daily_log_entries_created += 1
                            print(f"Created ACTB_DAIRY_LOG entry {daily_log_entry.ac_entry_sr_no}")
                        except Exception as log_error:
                            print(f"Error creating ACTB_DAIRY_LOG: {str(log_error)}")
                            import traceback
                            traceback.print_exc()
                        
                        # Create ACTB_DAIRY_LOG_HISTORY entry  
                        try:
                            daily_log_hist_entry = ACTB_DAIRY_LOG_HISTORY.objects.create(**actb_hist_data)
                            daily_log_hist_entries_created += 1
                            print(f"Created ACTB_DAIRY_LOG_HISTORY entry {daily_log_hist_entry.ac_entry_sr_no}")
                        except Exception as hist_error:
                            print(f"Error creating ACTB_DAIRY_LOG_HISTORY: {str(hist_error)}")
                            import traceback
                            traceback.print_exc()
                        
                except Exception as daily_log_error:
                    # Log the error but don't fail the entire approval process
                    print(f"Error creating daily log entries: {str(daily_log_error)}")
                    import traceback
                    traceback.print_exc()
            
            return Response({
                'message': f'Successfully approved {log_updated} LOG entries, {master_updated} MASTER record, {hist_updated} HIST records',
                'daily_log_created': daily_log_entries_created,
                'daily_log_hist_created': daily_log_hist_entries_created,
                'reference_no': reference_no
            })
            
        except Exception as e:
            import traceback
            traceback.print_exc()
            return Response({'error': f'Error during approval: {str(e)}'}, 
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    @action(detail=False, methods=['post'], url_path='reject-all')  
    def reject_all(self, request):
        """Reject all records (MASTER, LOG, HIST) for a Reference_No"""
        reference_no = request.data.get('Reference_No')
        rejection_reason = request.data.get('rejection_reason')
        
        if not reference_no:
            return Response({'error': 'Reference_No is required'}, 
                        status=status.HTTP_400_BAD_REQUEST)
        
        if not rejection_reason:
            return Response({'error': 'rejection_reason is required'}, 
                        status=status.HTTP_400_BAD_REQUEST)
        
        # Check if entries exist
        log_entries = DETB_JRNL_LOG.objects.filter(Reference_No=reference_no)
        if not log_entries.exists():
            return Response({'error': 'No entries found for this reference number'}, 
                        status=status.HTTP_404_NOT_FOUND)
        
        try:
            from django.db import transaction
            
            with transaction.atomic():
                # Update DETB_JRNL_LOG
                log_updated = log_entries.update(
                    Auth_Status='R',
                    Checker_Id=request.user,
                    Checker_DT_Stamp=timezone.now(),
                    # comments=request.data.get('comments') + f'\nRejection: {rejection_reason}'
                )
                
                # Update DETB_JRNL_LOG_MASTER
                try:
                    from .models import DETB_JRNL_LOG_MASTER
                    master_record = DETB_JRNL_LOG_MASTER.objects.get(Reference_No=reference_no)
                    master_record.Auth_Status = 'R'
                    master_record.Checker_Id = request.user
                    master_record.Checker_DT_Stamp = timezone.now()
                    master_record.Addl_text = (master_record.Addl_text or '') + f'\nRejection: {rejection_reason}'
                    master_record.save()
                    master_updated = 1
                except DETB_JRNL_LOG_MASTER.DoesNotExist:
                    master_updated = 0
                
                # Update DETB_JRNL_LOG_HIST (if exists)
                hist_updated = 0
                try:
                    from .models import DETB_JRNL_LOG_HIST
                    hist_updated = DETB_JRNL_LOG_HIST.objects.filter(
                        Reference_No=reference_no
                    ).update(
                        Auth_Status='R',
                        Checker_Id=request.user,
                        Checker_DT_Stamp=timezone.now()
                    )
                except:
                    pass  # HIST table might not exist
            
            return Response({
                'message': f'Successfully rejected {log_updated} LOG entries, {master_updated} MASTER record, {hist_updated} HIST records',
                'reference_no': reference_no,
                'rejection_reason': rejection_reason
            })
            
        except Exception as e:
            return Response({'error': f'Error during rejection: {str(e)}'}, 
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @action(detail=False, methods=['post'], url_path='pending-all')  
    def pending_all(self, request):
        """Reject all records (MASTER, LOG, HIST) for a Reference_No"""
        reference_no = request.data.get('Reference_No')
        pending_reason = request.data.get('pending_reason')

        if not reference_no:
            return Response({'error': 'Reference_No is required'}, 
                        status=status.HTTP_400_BAD_REQUEST)

        if not pending_reason:
            return Response({'error': 'pending_reason is required'}, 
                        status=status.HTTP_400_BAD_REQUEST)
        
        # Check if entries exist
        log_entries = DETB_JRNL_LOG.objects.filter(Reference_No=reference_no)
        if not log_entries.exists():
            return Response({'error': 'No entries found for this reference number'}, 
                        status=status.HTTP_404_NOT_FOUND)
        
        try:
            from django.db import transaction
            
            with transaction.atomic():
                # Update DETB_JRNL_LOG
                log_updated = log_entries.update(
                    Auth_Status='P',
                    Checker_Id=request.user,
                    Checker_DT_Stamp=timezone.now(),
                    # comments=request.data.get('comments') + f'\nRejection: {rejection_reason}'
                )
                
                # Update DETB_JRNL_LOG_MASTER
                try:
                    from .models import DETB_JRNL_LOG_MASTER
                    master_record = DETB_JRNL_LOG_MASTER.objects.get(Reference_No=reference_no)
                    master_record.Auth_Status = 'P'
                    master_record.Checker_Id = request.user
                    master_record.Checker_DT_Stamp = timezone.now()
                    master_record.Addl_text = (master_record.Addl_text or '') + f'\nPending: {pending_reason}'
                    master_record.save()
                    master_updated = 1
                except DETB_JRNL_LOG_MASTER.DoesNotExist:
                    master_updated = 0
                
                # Update DETB_JRNL_LOG_HIST (if exists)
                hist_updated = 0
                try:
                    from .models import DETB_JRNL_LOG_HIST
                    hist_updated = DETB_JRNL_LOG_HIST.objects.filter(
                        Reference_No=reference_no
                    ).update(
                        Auth_Status='P',
                        Checker_Id=request.user,
                        Checker_DT_Stamp=timezone.now()
                    )
                except:
                    pass  # HIST table might not exist
            
            return Response({
                'message': f'Successfully pending {log_updated} LOG entries, {master_updated} MASTER record, {hist_updated} HIST records',
                'reference_no': reference_no,
                'rejection_reason': pending_reason
            })
            
        except Exception as e:
            return Response({'error': f'Error during rejection: {str(e)}'}, 
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    # @action(detail=True, methods=['post'])
    # def authorize(self, request, pk=None):
    #     """Authorize a journal entry"""
    #     journal_entry = self.get_object()
        
    #     if journal_entry.Auth_Status == 'A':
    #         return Response({'error': 'Entry is already authorized'}, 
    #                       status=status.HTTP_400_BAD_REQUEST)
        
    #     journal_entry.Auth_Status = 'A'
    #     journal_entry.Checker_Id = request.user
    #     journal_entry.Checker_DT_Stamp = timezone.now()
    #     journal_entry.save()
        
    #     serializer = self.get_serializer(journal_entry)
    #     return Response({
    #         'message': 'Entry authorized successfully',
    #         'entry': serializer.data
    #     })

    # @action(detail=False, methods=['post'])
    # def authorize_batch(self, request):
    #     """Authorize multiple journal entries by reference number"""
    #     reference_no = request.data.get('reference_no')
        
    #     if not reference_no:
    #         return Response({'error': 'reference_no is required'}, 
    #                       status=status.HTTP_400_BAD_REQUEST)
        
    #     entries = DETB_JRNL_LOG.objects.filter(
    #         Reference_No=reference_no,
    #     )
        
    #     if not entries.exists():
    #         return Response({'error': 'No unauthorized entries found for this reference number'}, 
    #                       status=status.HTTP_404_NOT_FOUND)
        
    #     # Check if balanced before authorization
    #     balance_info = self.balance_check(request)
    #     if not balance_info.data.get('overall_balanced'):
    #         return Response({'error': 'Cannot authorize unbalanced entries'}, 
    #                       status=status.HTTP_400_BAD_REQUEST)
        
    #     updated_count = entries.update(
    #         Auth_Status='A',
    #         Checker_Id=request.user,
    #         Checker_DT_Stamp=timezone.now()
    #     )
        
    #     return Response({
    #         'message': f'Successfully authorized {updated_count} entries',
    #         'reference_no': reference_no
    #     })
    @action(detail=False, methods=['post'])
    def reject_batch(self, request):
        """Reject multiple journal entries by reference number"""
        reference_no = request.data.get('reference_no')
        rejection_reason = request.data.get('rejection_reason')
        
        if not reference_no:
            return Response({'error': 'reference_no is required'}, 
                        status=status.HTTP_400_BAD_REQUEST)
        
        if not rejection_reason:
            return Response({'error': 'rejection_reason is required'}, 
                        status=status.HTTP_400_BAD_REQUEST)
        
        entries = DETB_JRNL_LOG.objects.filter(
            Reference_No=reference_no,
            Auth_Status='U'  # Only reject unauthorized entries
        )
        
        if not entries.exists():
            return Response({'error': 'No unauthorized entries found for this reference number'}, 
                        status=status.HTTP_404_NOT_FOUND)
        
        # Update entries with rejection status and reason
        updated_count = entries.update(
            Auth_Status='R',
            Checker_Id=request.user,
            Checker_DT_Stamp=timezone.now(),
            # You might want to add rejection reason to a specific field
            # or append it to existing additional text
            comments=('Addl_text') + '\nRejection Reason: ' + rejection_reason
        )
        
        # Also update the master record if it exists
        try:
            master_record = DETB_JRNL_LOG_MASTER.objects.get(Reference_No=reference_no)
            master_record.Auth_Status = 'R'
            master_record.Checker_Id = request.user
            master_record.Checker_DT_Stamp = timezone.now()
            master_record.Addl_text = (master_record.Addl_text or '') + f'\nRejection Reason: {rejection_reason}'
            master_record.save()
        except DETB_JRNL_LOG_MASTER.DoesNotExist:
            pass  # Master record doesn't exist, which is okay
        
        return Response({
            'message': f'Successfully rejected {updated_count} entries',
            'reference_no': reference_no,
            'rejection_reason': rejection_reason
        })
    @action(detail=False, methods=['get'])
    def summary_report(self, request):
        """Generate summary report for journal entries"""
        start_date = request.query_params.get('start_date')
        end_date = request.query_params.get('end_date')
        
        queryset = self.get_queryset()
        
        if start_date:
            queryset = queryset.filter(Value_date__gte=start_date)
        if end_date:
            queryset = queryset.filter(Value_date__lte=end_date)
        
        # Summary statistics
        summary = queryset.aggregate(
            total_entries=models.Count('JRNLLog_id'),
            total_lcy_amount=Sum('Lcy_Amount'),
            total_fcy_amount=Sum('Fcy_Amount'),
            authorized_count=models.Count('JRNLLog_id', filter=Q(Auth_Status='A')),
            unauthorized_count=models.Count('JRNLLog_id', filter=Q(Auth_Status='U'))
        )
        
        # By currency breakdown
        by_currency = queryset.values('Ccy_cd__ccy_code', 'Ccy_cd__Ccy_Name_la').annotate(
            entry_count=models.Count('JRNLLog_id'),
            total_amount=Sum('Fcy_Amount')
        ).order_by('-total_amount')
        
        # By transaction code breakdown
        by_Txn_code = queryset.values('Txn_code__trn_code', 'Txn_code__trn_Desc_la').annotate(
            entry_count=models.Count('JRNLLog_id'),
            total_amount=Sum('Lcy_Amount')
        ).order_by('-total_amount')
        
        return Response({
            'period': {
                'start_date': start_date,
                'end_date': end_date
            },
            'summary': summary,
            'by_currency': list(by_currency),
            'by_transaction_code': list(by_Txn_code)
        })

    def get_exchange_rate(self, currency_code):
        """Get current exchange rate for currency"""
        try:
            if currency_code == 'LAK':
                return Decimal('1.00')
            
            exc_rate = MTTB_EXC_Rate.objects.filter(
                ccy_code__ccy_code=currency_code,
                Auth_Status='A'
            ).first()
            
            if exc_rate:
                return exc_rate.Buy_Rate
            else:
                # Fallback to currency definition or default
                currency = MTTB_Ccy_DEFN.objects.get(ccy_code=currency_code)
                return getattr(currency, 'default_rate', Decimal('1.00'))
                
        except Exception:
            return Decimal('1.00')
    @action(detail=False, methods=['post'])
    def generate_reference(self, request):
        """Generate a reference number without creating entries"""
        module_id = request.data.get('module_id', 'GL')
        # Txn_code = request.data.get('Txn_code')
        Txn_code = (
            request.data.get('Txn_code') or
            request.data.get('txn_code') or
            request.data.get('tcn')
        )
        value_date = request.data.get('value_date')
        
        if not Txn_code:
            return Response({'error': 'Txn_code is required'}, 
                          status=status.HTTP_400_BAD_REQUEST)
        
        # Parse date if provided
        date = None
        if value_date:
            try:
                from datetime import datetime
                date = datetime.fromisoformat(value_date.replace('Z', '+00:00')).date()
            except:
                pass
        
        reference_no = JournalEntryHelper.generate_reference_number(
            module_id=module_id,
            txn_code=Txn_code,
            date=date
        )
        
        return Response({
            'reference_no': reference_no,
            'module_id': module_id,
            'Txn_code': Txn_code,
            'date': date or timezone.now().date()
        })

from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.decorators import action
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter
from django.db.models import Q, Count, Prefetch
from django.utils.dateparse import parse_date
from django.core.cache import cache
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
import logging

# Import your existing models and serializers
from .models import DETB_JRNL_LOG_MASTER
from .serializers import DETB_JRNL_LOG_MASTER_Serializer  # Your existing serializer

logger = logging.getLogger(__name__)

class DETB_JRNL_LOG_MASTER_ViewSet(viewsets.ModelViewSet):
    serializer_class = DETB_JRNL_LOG_MASTER_Serializer  # Use your existing serializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['Ccy_cd', 'Txn_code', 'fin_cycle', 'Auth_Status', 'Reference_No']
    search_fields = ['Reference_No', 'Addl_text', 'Txn_code']
    ordering_fields = ['Maker_DT_Stamp', 'Value_date', 'Reference_No', 'Fcy_Amount', 'Auth_Status']

    def get_queryset(self):
        """Optimized queryset with select_related for foreign keys"""
        base_queryset = DETB_JRNL_LOG_MASTER.objects.select_related(
            'Maker_Id',
            'Checker_Id', 
            'module_id',
            'Ccy_cd',
            'Txn_code'
        ).filter(
            # Include only non-deleted records
            Q(delete_stat__isnull=True) | ~Q(delete_stat='D')
        ).exclude(
            # Exclude ARD transaction codes
            Txn_code='ARD'
        )
        
        # Permission-based filtering
        show_all = self.request.query_params.get('show_all', 'false').lower()
        
        if show_all == 'true':
            return base_queryset
        else:
            user_id = getattr(self.request.user, 'user_id', None) or getattr(self.request.user, 'id', None)
            return base_queryset.filter(Maker_Id=user_id)
    def _apply_filters(self, queryset, request):
        """Apply all custom filters efficiently"""
        try:
            # Date filtering
            specific_date = request.query_params.get('Value_date')
            if specific_date:
                filter_date = parse_date(specific_date)
                if filter_date:
                    queryset = queryset.filter(Value_date__date=filter_date)
            else:
                date_from = request.query_params.get('Value_date__gte')
                date_to = request.query_params.get('Value_date__lte')
                
                if date_from:
                    from_date = parse_date(date_from)
                    if from_date:
                        queryset = queryset.filter(Value_date__date__gte=from_date)
                
                if date_to:
                    to_date = parse_date(date_to)
                    if to_date:
                        queryset = queryset.filter(Value_date__date__lte=to_date)
            
            # Other filters
            module_id = request.query_params.get('module_id')
            if module_id:
                queryset = queryset.filter(module_id=module_id)
            
            ccy_cd = request.query_params.get('Ccy_cd')
            if ccy_cd:
                queryset = queryset.filter(Ccy_cd=ccy_cd)
            
            auth_status = request.query_params.get('Auth_Status')
            if auth_status:
                queryset = queryset.filter(Auth_Status=auth_status)
                

            
            # Search
            search = request.query_params.get('search')
            if search:
                queryset = queryset.filter(
                    Q(Reference_No__icontains=search) | 
                    Q(Addl_text__icontains=search) |
                    Q(Txn_code__icontains=search)
                )
            
            # Exclude deleted
            delete_stat_ne = request.query_params.get('delete_stat__ne')
            if delete_stat_ne:
                queryset = queryset.exclude(delete_stat=delete_stat_ne)

            txn_code = request.query_params.get('Txn_code')
            if txn_code:
                queryset = queryset.exclude(Txn_code='ARD')
                print("DEBUG: Applied ARD exclusion filter")

            # Ordering
            ordering = request.query_params.get('ordering', '-Maker_DT_Stamp')
            valid_fields = [
                'Maker_DT_Stamp', '-Maker_DT_Stamp',
                'Value_date', '-Value_date',
                'Reference_No', '-Reference_No',
                'Fcy_Amount', '-Fcy_Amount',
                'Auth_Status', '-Auth_Status'
            ]
            if ordering in valid_fields:
                queryset = queryset.order_by(ordering)
            
            return queryset
            
        except Exception as e:
            logger.error(f"Error applying filters: {str(e)}")
            return queryset

    @action(detail=False, methods=['get'], url_path='init-data')

    def init_data(self, request):
        """
        Combined endpoint for initial data loading
        Returns paginated journal data + summary data in one request
        """
        try:
            # Get query parameters
            page_size = min(int(request.query_params.get('page_size', 25)), 100)
            page = int(request.query_params.get('page', 1))
            
            print(f"DEBUG: init_data called with page={page}, page_size={page_size}")
            
            # Get base queryset with optimizations
            base_queryset = self.get_queryset().select_related(
                'Maker_Id', 'Checker_Id', 'module_id', 'Ccy_cd', 'Txn_code'
            )
            
            print(f"DEBUG: Base queryset count: {base_queryset.count()}")
            
            # Apply existing filters
            queryset = self.filter_queryset(base_queryset)
            
            # Apply additional custom filters
            queryset = self._apply_custom_filters(queryset, request)
            
            print(f"DEBUG: Filtered queryset count: {queryset.count()}")
            
            # For summary - get counts WITHOUT Auth_Status filter for accurate totals
            summary_queryset = self.filter_queryset(base_queryset)
            summary_queryset = self._apply_custom_filters_for_summary(summary_queryset, request)
            
            # Get summary counts
            summary_data = summary_queryset.aggregate(
                total=Count('JRNLLog_id'),
                pending=Count('JRNLLog_id', filter=Q(Auth_Status='U')),
                approved=Count('JRNLLog_id', filter=Q(Auth_Status='A')),
                rejected=Count('JRNLLog_id', filter=Q(Auth_Status='R')),
                correction=Count('JRNLLog_id', filter=Q(Auth_Status='P'))
            )
            
            print(f"DEBUG: Summary data: {summary_data}")
            
            # Get total count for pagination
            total_count = queryset.count()
            
            # Paginate the results
            start = (page - 1) * page_size
            end = start + page_size
            paginated_queryset = queryset[start:end]
            
            print(f"DEBUG: Paginated queryset: {start}-{end}, count: {len(paginated_queryset)}")
            
            # Serialize data using your existing serializer
            serializer = self.get_serializer(paginated_queryset, many=True)
            
            # Build response (NO CACHING)
            response_data = {
                'results': serializer.data,
                'count': total_count,
                'next': f"?page={page + 1}" if end < total_count else None,
                'previous': f"?page={page - 1}" if page > 1 else None,
                'summary': summary_data,
                'page_info': {
                    'current_page': page,
                    'page_size': page_size,
                    'total_pages': (total_count + page_size - 1) // page_size
                }
            }
            
            print(f"DEBUG: Response ready, results count: {len(response_data['results'])}")
            
            return Response(response_data, status=200)
            
        except Exception as e:
            print(f"ERROR in init_data: {str(e)}")
            logger.error(f"Error in init_data: {str(e)}")
            import traceback
            traceback.print_exc()
            
            return Response({
                'error': 'Failed to load initial data',
                'details': str(e)
            }, status=500)

    def _apply_custom_filters(self, queryset, request):
        """Apply all custom filters including Auth_Status"""
        try:
            print("DEBUG: Applying custom filters...")
            
            # Date filtering
            specific_date = request.query_params.get('Value_date')
            if specific_date:
                filter_date = parse_date(specific_date)
                if filter_date:
                    queryset = queryset.filter(Value_date__date=filter_date)
                    print(f"DEBUG: Applied specific date filter: {specific_date}")
            else:
                date_from = request.query_params.get('Value_date__gte')
                date_to = request.query_params.get('Value_date__lte')
                
                if date_from:
                    from_date = parse_date(date_from)
                    if from_date:
                        queryset = queryset.filter(Value_date__date__gte=from_date)
                        print(f"DEBUG: Applied date_from filter: {date_from}")
                
                if date_to:
                    to_date = parse_date(date_to)
                    if to_date:
                        queryset = queryset.filter(Value_date__date__lte=to_date)
                        print(f"DEBUG: Applied date_to filter: {date_to}")
            
            # Module filtering
            module_id = request.query_params.get('module_id')
            if module_id:
                queryset = queryset.filter(module_id=module_id)
                print(f"DEBUG: Applied module filter: {module_id}")
            
            # Currency filtering
            ccy_cd = request.query_params.get('Ccy_cd')
            if ccy_cd:
                queryset = queryset.filter(Ccy_cd=ccy_cd)
                print(f"DEBUG: Applied currency filter: {ccy_cd}")
            
            # Authorization status filtering
            auth_status = request.query_params.get('Auth_Status')
            if auth_status:
                queryset = queryset.filter(Auth_Status=auth_status)
                print(f"DEBUG: Applied auth_status filter: {auth_status}")
            
            # Search filtering
            search = request.query_params.get('search')
            if search:
                queryset = queryset.filter(
                    Q(Reference_No__icontains=search) | 
                    Q(Addl_text__icontains=search) |
                    Q(Txn_code__icontains=search)
                )
                print(f"DEBUG: Applied search filter: {search}")
            
            # Exclude soft deleted records
            delete_stat_ne = request.query_params.get('delete_stat__ne')
            if delete_stat_ne:
                queryset = queryset.exclude(delete_stat=delete_stat_ne)
                print(f"DEBUG: Applied delete_stat filter: {delete_stat_ne}")
            txn_code = request.query_params.get('Txn_code')
            if txn_code:
                queryset = queryset.exclude(Txn_code=txn_code)
                print(f"DEBUG: Applied txn_code filter: {txn_code}")
            
            # Ordering
            ordering = request.query_params.get('ordering', '-Maker_DT_Stamp')
            valid_fields = [
                'Maker_DT_Stamp', '-Maker_DT_Stamp',
                'Value_date', '-Value_date',
                'Reference_No', '-Reference_No',
                'Fcy_Amount', '-Fcy_Amount',
                'Auth_Status', '-Auth_Status'
            ]
            if ordering in valid_fields:
                queryset = queryset.order_by(ordering)
                print(f"DEBUG: Applied ordering: {ordering}")
            
            return queryset
            
        except Exception as e:
            print(f"ERROR applying custom filters: {str(e)}")
            logger.error(f"Error applying custom filters: {str(e)}")
            return queryset

    def _apply_custom_filters_for_summary(self, queryset, request):
        """Same as above but exclude Auth_Status filter for accurate summary counts"""
        try:
            print("DEBUG: Applying custom filters for summary...")
            
            # Date filtering
            specific_date = request.query_params.get('Value_date')
            if specific_date:
                filter_date = parse_date(specific_date)
                if filter_date:
                    queryset = queryset.filter(Value_date__date=filter_date)
            else:
                date_from = request.query_params.get('Value_date__gte')
                date_to = request.query_params.get('Value_date__lte')
                
                if date_from:
                    from_date = parse_date(date_from)
                    if from_date:
                        queryset = queryset.filter(Value_date__date__gte=from_date)
                
                if date_to:
                    to_date = parse_date(date_to)
                    if to_date:
                        queryset = queryset.filter(Value_date__date__lte=to_date)
            
            # Module filtering
            module_id = request.query_params.get('module_id')
            if module_id:
                queryset = queryset.filter(module_id=module_id)
            
            # Currency filtering
            ccy_cd = request.query_params.get('Ccy_cd')
            if ccy_cd:
                queryset = queryset.filter(Ccy_cd=ccy_cd)
            
            # Search filtering
            search = request.query_params.get('search')
            if search:
                queryset = queryset.filter(
                    Q(Reference_No__icontains=search) | 
                    Q(Addl_text__icontains=search) |
                    Q(Txn_code__icontains=search)
                )
            queryset = queryset.exclude(Txn_code='ARD')
            print("DEBUG: Applied ARD exclusion filter for summary")
            
            # Exclude soft deleted records
            delete_stat_ne = request.query_params.get('delete_stat__ne')
            if delete_stat_ne:
                queryset = queryset.exclude(delete_stat=delete_stat_ne)
            
            # NOTE: We EXCLUDE Auth_Status filtering here to get accurate summary counts
            print("DEBUG: Summary filters applied (excluding Auth_Status)")
            
            return queryset
            
        except Exception as e:
            print(f"ERROR applying summary filters: {str(e)}")
            logger.error(f"Error applying summary filters: {str(e)}")
            return queryset


    def _get_reference_data(self):
        """Get reference data with caching"""
        cache_key = 'journal_reference_data'
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return cached_data
        
        try:
            # Get reference data from your existing endpoints or models
            reference_data = {
                'modules': self._get_modules_data(),
                'currencies': self._get_currencies_data(),
                'auth_status_options': [
                    {'value': 'U', 'text': 'ລໍຖ້າອະນຸມັດ'},
                    {'value': 'A', 'text': 'ອະນຸມັດແລ້ວ'},
                    {'value': 'R', 'text': 'ປະຕິເສດ'},
                    {'value': 'P', 'text': 'ຖ້າເແກ້ໄຂ'}
                ]
            }
            
            # Cache for 5 minutes
            cache.set(cache_key, reference_data, 300)
            return reference_data
            
        except Exception as e:
            logger.error(f"Error loading reference data: {str(e)}")
            return {
                'modules': [],
                'currencies': [],
                'auth_status_options': [
                    {'value': 'U', 'text': 'ລໍຖ້າອະນຸມັດ'},
                    {'value': 'A', 'text': 'ອະນຸມັດແລ້ວ'},
                    {'value': 'R', 'text': 'ປະຕິເສດ'},
                    {'value': 'P', 'text': 'ຖ້າເແກ້ໄຂ'}
                ]
            }

    def _get_modules_data(self):
        """Get modules data - adapt this to your actual module model"""
        try:
            # You'll need to adapt this based on your actual models
            from django.db import connection
            with connection.cursor() as cursor:
                cursor.execute("""
                    SELECT module_Id, module_name_la 
                    FROM STTB_ModulesInfo 
                    WHERE status = 'A'
                    ORDER BY module_name_la
                """)
                return [
                    {'module_Id': row[0], 'module_name_la': row[1]} 
                    for row in cursor.fetchall()
                ]
        except Exception as e:
            logger.error(f"Error loading modules: {str(e)}")
            return []

    def _get_currencies_data(self):
        """Get currencies data - adapt this to your actual currency model"""
        try:
            # You'll need to adapt this based on your actual models
            from django.db import connection
            with connection.cursor() as cursor:
                cursor.execute("""
                    SELECT ccy_code, ccy_name 
                    FROM MTTB_Ccy_DEFN 
                    WHERE status = 'A'
                    ORDER BY ccy_code
                """)
                return [
                    {'ccy_code': row[0], 'ccy_name': row[1]} 
                    for row in cursor.fetchall()
                ]
        except Exception as e:
            logger.error(f"Error loading currencies: {str(e)}")
            return []

    # Keep all your existing methods
    def list(self, request, *args, **kwargs):
        """
        Override list to add comprehensive date filtering and permission-based access
        """
        queryset = self.filter_queryset(self.get_queryset())
        
        # Permission-based filtering
        show_all = request.query_params.get('show_all', 'false').lower() == 'true'
        
        # If user doesn't have authorization permission, filter to only their own records
        if not show_all:
            user_id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None)
            if user_id:
                queryset = queryset.filter(Maker_Id=user_id)
            else:
                queryset = queryset.none()
        
        # Apply additional filters
        queryset = self._apply_filters(queryset, request)
        
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

    def retrieve(self, request, *args, **kwargs):
        """Override retrieve method to check permissions"""
        instance = self.get_object()
        user = request.user
        
        # Permission check
        show_all = request.query_params.get('show_all', 'false').lower() == 'true'
        if not show_all and instance.Maker_Id != user:
            return Response(
                {"detail": "You don't have permission to view this record."},
                status=status.HTTP_403_FORBIDDEN
            )
        
        return super().retrieve(request, *args, **kwargs)

    def perform_update(self, serializer):
        instance = serializer.save()
        if instance.Auth_Status == 'A':
            from .models import DETB_JRNL_LOG
            DETB_JRNL_LOG.objects.filter(
                Reference_No=instance.Reference_No
            ).update(Auth_Status='A')

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        instance.delete_stat = 'D'
        instance.save()
        return Response({'detail': 'Marked as deleted.'}, status=status.HTTP_204_NO_CONTENT)

    # # Keep your existing custom actions
    # @action(detail=False, methods=['get'], url_path='journal-log-active')
    # def journal_log_active(self, request):
    #     """Get all active journal log master records"""
    #     from django.utils import timezone
        
    #     Today = timezone.now().date()
    #     reference_no = request.query_params.get('Reference_No')
    #     auth_status = request.query_params.get('Auth_Status')
        
    #     queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
    #         delete_stat__isnull=True,
    #         Value_date=Today
    #     ).exclude(delete_stat='D', Auth_Status='U')

    #     if reference_no:
    #         queryset = queryset.filter(Reference_No=reference_no)
    #     if auth_status:
    #         queryset = queryset.filter(Auth_Status=auth_status)

    #     serializer = self.get_serializer(queryset, many=True)
    #     return Response(serializer.data)
    
    @action(detail=False, methods=['get'], url_path='journal-log-active')
    def journal_log_active(self, request):
        """
        Get all active journal log master records based on current EOD processing date.
        This ensures consistency with EOD validation logic.
        """
        import pytz
        from django.utils import timezone
        from django.db.models import Q
        
        try:
            tz = pytz.timezone('Asia/Bangkok')
            today = timezone.now().astimezone(tz).date()
            
            # Get the current processing date based on EOD logic
            processing_date = self.get_current_processing_date(request)
            
            # Get query parameters
            reference_no = request.query_params.get('Reference_No')
            auth_status = request.query_params.get('Auth_Status')
            
            # Base queryset - filter by the processing date
            queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
                ~Q(Txn_code='ARD'),
                delete_stat__isnull=True,
                Value_date=processing_date
            ).exclude(
                # Q(delete_stat='D') | Q(Auth_Status='D')
                 Q(delete_stat='D') | Q(Txn_code='ARD')
            ).order_by('-Maker_DT_Stamp')

            # Apply additional filters if provided
            if reference_no:
                queryset = queryset.filter(Reference_No=reference_no)
            if auth_status:
                queryset = queryset.filter(Auth_Status=auth_status)

            serializer = self.get_serializer(queryset, many=True)
            
            # Add metadata about the processing date
            response_data = {
                'results': serializer.data,
                'processing_date': processing_date.isoformat(),
                'is_back_date': processing_date != today,
                'record_count': len(serializer.data),
                'today': today.isoformat()
            }
            
            return Response(response_data)
            
        except Exception as e:
            return Response({
                'error': f'Error fetching journal records: {str(e)}',
                'results': [],
                'processing_date': None,
                'is_back_date': False,
                'record_count': 0
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def get_current_processing_date(self, request):
        """
        Get the current processing date based on EOD logic.
        This should match the same logic used in check_journal_submission_available.
        """
        import pytz
        from django.utils import timezone
        from .models import MTTB_DATA_Entry, STTB_Dates  # Replace with actual import
        
        try:
            tz = pytz.timezone('Asia/Bangkok')
            today = timezone.now().astimezone(tz).date()
            
            # Get MTTB_DATA_Entry configuration
            try:
                data_entry = MTTB_DATA_Entry.objects.filter(
                    # Auth_Status='A'  # Uncomment if needed
                ).first()
                
                if not data_entry:
                    bypass_eod_check = False
                else:
                    bypass_eod_check = data_entry.BACK_VALUE == 'Y'
                    
            except Exception:
                bypass_eod_check = False

            # Get the latest EOD record
            try:
                latest_eod = STTB_Dates.objects.latest('date_id')
            except STTB_Dates.DoesNotExist:
                # No EOD records - use today
                return today

            latest_next_working = latest_eod.next_working_Day.astimezone(tz).date()
            
            # Apply the same logic as EOD validation
            if latest_next_working == today:
                # Normal case - processing today's journals
                return today
            elif latest_next_working < today:
                # We're ahead - check if back-dating is enabled
                if bypass_eod_check:
                    # Back-date mode - return the target date
                    return latest_next_working
                else:
                    # No back-dating - use today (but this might mean no journals)
                    return today
            else:
                # Future date (shouldn't happen normally) - use today
                return today
                
        except Exception:
            # Fallback to today if anything goes wrong
            return timezone.now().astimezone(pytz.timezone('Asia/Bangkok')).date()

    # Alternative version with more explicit back-date handling
    @action(detail=False, methods=['get'], url_path='journal-log-by-date')
    def journal_log_by_date(self, request):
        """
        Get journal log records for a specific date.
        Used for back-date EOD processing.
        """
        target_date_str = request.query_params.get('date')
        
        if not target_date_str:
            return Response({
                'error': 'Date parameter is required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            from datetime import datetime
            target_date = datetime.strptime(target_date_str, '%Y-%m-%d').date()
            
            # Get query parameters
            reference_no = request.query_params.get('Reference_No')
            auth_status = request.query_params.get('Auth_Status')
            
            # Query journals for the specific date
            queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
                delete_stat__isnull=True,
                Value_date=target_date,
                Auth_Status='U'
            ).exclude(
                # Q(delete_stat='D') | Q(Auth_Status='D')
                 Q(delete_stat__isnull=True) | ~Q(delete_stat='D') | Q(Txn_code='ARD')
            ).order_by('-Maker_DT_Stamp')

            # Apply additional filters if provided
            if reference_no:
                queryset = queryset.filter(Reference_No=reference_no)
            if auth_status:
                queryset = queryset.filter(Auth_Status=auth_status)

            serializer = self.get_serializer(queryset, many=True)
            
            return Response({
                'results': serializer.data,
                'target_date': target_date.isoformat(),
                'record_count': len(serializer.data)
            })
            
        except ValueError:
            return Response({
                'error': 'Invalid date format. Use YYYY-MM-DD'
            }, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({
                'error': f'Error fetching journal records: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    # Enhanced version with comprehensive EOD integration
    @action(detail=False, methods=['get'], url_path='journal-log-eod-context')
    def journal_log_eod_context(self, request):
        """
        Get journal log records with full EOD context.
        Returns both current and target date journals if in back-date mode.
        """
        import pytz
        from django.utils import timezone
        from django.db.models import Q
        
        try:
            tz = pytz.timezone('Asia/Bangkok')
            today = timezone.now().astimezone(tz).date()
            
            # Get EOD status to determine processing context
            eod_status = self.get_eod_processing_status(request)
            
            response_data = {
                'today': today.isoformat(),
                'eod_context': eod_status,
                'current_journals': [],
                'target_journals': [],
            }
            
            # Get current day journals (always needed for validation)
            current_queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
                delete_stat__isnull=True,
                Value_date=today
            ).exclude(
                # Q(delete_stat='D') | Q(Auth_Status='D')
                 Q(delete_stat__isnull=True) | ~Q(delete_stat='D') | Q(Txn_code='ARD')
            ).order_by('-Maker_DT_Stamp')
            
            current_serializer = self.get_serializer(current_queryset, many=True)
            response_data['current_journals'] = current_serializer.data
            
            # If in back-date mode, also get target date journals
            if eod_status.get('is_back_date') and eod_status.get('target_date'):
                target_date_str = eod_status['target_date']
                target_date = datetime.strptime(target_date_str, '%Y-%m-%d').date()
                
                target_queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
                    delete_stat__isnull=True,
                    Value_date=target_date
                ).exclude(
                    Q(delete_stat='D') | Q(Auth_Status='D' | Q(Txn_code='ARD')) 
                ).order_by('-Maker_DT_Stamp')
                
                target_serializer = self.get_serializer(target_queryset, many=True)
                response_data['target_journals'] = target_serializer.data
            
            return Response(response_data)
            
        except Exception as e:
            return Response({
                'error': f'Error fetching journal records with EOD context: {str(e)}',
                'today': today.isoformat() if 'today' in locals() else None,
                'eod_context': {},
                'current_journals': [],
                'target_journals': [],
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def get_eod_processing_status(self, request):
        """
        Get the current EOD processing status to determine which date to use.
        This mirrors the logic from check_journal_submission_available.
        """
        import pytz
        from django.utils import timezone
        from .models import MTTB_DATA_Entry, STTB_Dates  # Replace with actual import
        
        try:
            tz = pytz.timezone('Asia/Bangkok')
            today = timezone.now().astimezone(tz).date()
            
            # Get MTTB_DATA_Entry configuration
            try:
                data_entry = MTTB_DATA_Entry.objects.filter(
                    # Auth_Status='A'
                ).first()
                
                if not data_entry:
                    bypass_eod_check = False
                else:
                    bypass_eod_check = data_entry.BACK_VALUE == 'Y'
                    
            except Exception:
                bypass_eod_check = False

            # Get the latest EOD record
            try:
                latest_eod = STTB_Dates.objects.latest('date_id')
            except STTB_Dates.DoesNotExist:
                return {
                    'is_back_date': False,
                    'target_date': today.isoformat(),
                    'current_eod': None,
                    'bypass_enabled': False
                }

            latest_next_working = latest_eod.next_working_Day.astimezone(tz).date()
            
            # Determine if we're in back-date mode
            if latest_next_working < today and bypass_eod_check:
                return {
                    'is_back_date': True,
                    'target_date': latest_next_working.isoformat(),
                    'current_eod': {
                        'date_id': latest_eod.date_id,
                        'next_working_day': latest_next_working.isoformat(),
                        'eod_status': latest_eod.eod_time
                    },
                    'bypass_enabled': True
                }
            else:
                return {
                    'is_back_date': False,
                    'target_date': today.isoformat(),
                    'current_eod': {
                        'date_id': latest_eod.date_id,
                        'next_working_day': latest_next_working.isoformat(),
                        'eod_status': latest_eod.eod_time
                    },
                    'bypass_enabled': bypass_eod_check
                }
                
        except Exception as e:
            return {
                'is_back_date': False,
                'target_date': today.isoformat(),
                'current_eod': None,
                'bypass_enabled': False,
                'error': str(e)
            }
        
    @action(detail=False, methods=['get'], url_path='journal-log-detail')
    def journal_log_detail(self, request):
        """Get journal log detail records"""
        reference_no = request.query_params.get('Reference_No')
        auth_status = request.query_params.get('Auth_Status')
        
        queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
            delete_stat__isnull=True
        ).exclude(delete_stat='D')

        if reference_no:
            queryset = queryset.filter(Reference_No=reference_no)
        if auth_status:
            queryset = queryset.filter(Auth_Status=auth_status)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

    @action(detail=False, methods=['patch'], url_path='approve-by-reference')
    def approve_by_reference(self, request):
        reference_no = request.data.get('Reference_No')
        if not reference_no:
            return Response({'detail': 'Reference_No is required'}, 
                          status=status.HTTP_400_BAD_REQUEST)
        
        try:
            master_record = self.get_queryset().get(Reference_No=reference_no)
            
            # Update master record
            master_record.Auth_Status = 'A'
            master_record.Checker_Id = request.data.get('Checker_Id')
            master_record.Checker_DT_Stamp = request.data.get('Checker_DT_Stamp')
            master_record.save()
            
            serializer = self.get_serializer(master_record)
            return Response(serializer.data, status=status.HTTP_200_OK)
            
        except DETB_JRNL_LOG_MASTER.DoesNotExist:
            return Response({'detail': 'Master record not found'}, 
                          status=status.HTTP_404_NOT_FOUND)
    
    @action(detail=False, methods=['patch'], url_path='reject-by-reference')
    def reject_by_reference(self, request):
        reference_no = request.data.get('Reference_No')
        if not reference_no:
            return Response({'detail': 'Reference_No is required'}, 
                          status=status.HTTP_400_BAD_REQUEST)
        
        try:
            master_record = self.get_queryset().get(Reference_No=reference_no)
            
            # Update master record
            master_record.Auth_Status = 'R'
            master_record.Checker_Id = request.data.get('Checker_Id')
            master_record.Checker_DT_Stamp = request.data.get('Checker_DT_Stamp')
            if request.data.get('Addl_text'):
                master_record.Addl_text = request.data.get('Addl_text')
            master_record.save()
            
            serializer = self.get_serializer(master_record)
            return Response(serializer.data, status=status.HTTP_200_OK)
            
        except DETB_JRNL_LOG_MASTER.DoesNotExist:
            return Response({'detail': 'Master record not found'}, 
                          status=status.HTTP_404_NOT_FOUND)


    # def list(self, request, *args, **kwargs):
    #     """
    #     Override list to add comprehensive date filtering and permission-based access
    #     Supports:
    #     - Specific date: Value_date=2024-01-15
    #     - Date range: Value_date__gte=2024-01-01&Value_date__lte=2024-01-31
    #     - Permission-based filtering: show_all=true/false
    #     """
    #     queryset = self.filter_queryset(self.get_queryset())
        
    #     # Permission-based filtering
    #     show_all = request.query_params.get('show_all', 'false').lower() == 'true'
        
    #     # If user doesn't have authorization permission, filter to only their own records
    #     if not show_all:
    #         # Assuming the user ID is available in request.user
    #         user_id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None)
    #         if user_id:
    #             queryset = queryset.filter(Maker_Id=user_id)
    #         else:
    #             # If no user ID found, return empty queryset for security
    #             queryset = queryset.none()
        
    #     # Date filtering logic
    #     try:
    #         # 1. Handle specific date filtering (Value_date=2024-01-15)
    #         specific_date = request.query_params.get('Value_date')
    #         if specific_date:
    #             filter_date = parse_date(specific_date)
    #             if filter_date:
    #                 # Filter for exact date match
    #                 queryset = queryset.filter(Value_date__date=filter_date)
    #             else:
    #                 # Invalid date format, return empty queryset
    #                 return Response({
    #                     'error': 'Invalid date format for Value_date. Expected YYYY-MM-DD.',
    #                     'results': [],
    #                     'count': 0
    #                 }, status=400)
            
    #         # 2. Handle date range filtering (Value_date__gte and Value_date__lte)
    #         else:
    #             date_from = request.query_params.get('Value_date__gte')
    #             date_to = request.query_params.get('Value_date__lte')
                
    #             if date_from:
    #                 from_date = parse_date(date_from)
    #                 if from_date:
    #                     queryset = queryset.filter(Value_date__date__gte=from_date)
    #                 else:
    #                     return Response({
    #                         'error': 'Invalid date format for Value_date__gte. Expected YYYY-MM-DD.',
    #                         'results': [],
    #                         'count': 0
    #                     }, status=400)
                
    #             if date_to:
    #                 to_date = parse_date(date_to)
    #                 if to_date:
    #                     queryset = queryset.filter(Value_date__date__lte=to_date)
    #                 else:
    #                     return Response({
    #                         'error': 'Invalid date format for Value_date__lte. Expected YYYY-MM-DD.',
    #                         'results': [],
    #                         'count': 0
    #                     }, status=400)
        
    #     except Exception as e:
    #         # Log the error for debugging
    #         import logging
    #         logger = logging.getLogger(__name__)
    #         logger.error(f"Date filtering error: {str(e)}")
            
    #         return Response({
    #             'error': 'Error processing date filters.',
    #             'results': [],
    #             'count': 0
    #         }, status=400)
        
    #     # Additional filtering parameters
    #     try:
    #         # Module filtering
    #         module_id = request.query_params.get('module_id')
    #         if module_id:
    #             queryset = queryset.filter(module_id=module_id)
            
    #         # Currency filtering
    #         ccy_cd = request.query_params.get('Ccy_cd')
    #         if ccy_cd:
    #             queryset = queryset.filter(Ccy_cd=ccy_cd)
            
    #         # Authorization status filtering
    #         auth_status = request.query_params.get('Auth_Status')
    #         if auth_status:
    #             queryset = queryset.filter(Auth_Status=auth_status)
            
    #         # Search filtering (search in Reference_No and Addl_text)
    #         search = request.query_params.get('search')
    #         if search:
    #             from django.db.models import Q
    #             queryset = queryset.filter(
    #                 Q(Reference_No__icontains=search) | 
    #                 Q(Addl_text__icontains=search) |
    #                 Q(Txn_code__icontains=search)
    #             )
            
    #         # Exclude soft deleted records
    #         delete_stat_ne = request.query_params.get('delete_stat__ne')
    #         if delete_stat_ne:
    #             queryset = queryset.exclude(delete_stat=delete_stat_ne)
            
    #         # Ordering
    #         ordering = request.query_params.get('ordering', '-Maker_DT_Stamp')
    #         if ordering:
    #             # Validate ordering field to prevent SQL injection
    #             valid_fields = [
    #                 'Maker_DT_Stamp', '-Maker_DT_Stamp',
    #                 'Value_date', '-Value_date',
    #                 'Reference_No', '-Reference_No',
    #                 'Fcy_Amount', '-Fcy_Amount',
    #                 'Auth_Status', '-Auth_Status'
    #             ]
    #             if ordering in valid_fields:
    #                 queryset = queryset.order_by(ordering)
    #             else:
    #                 queryset = queryset.order_by('-Maker_DT_Stamp')  # Default ordering
        
    #     except Exception as e:
    #         # Log the error for debugging
    #         import logging
    #         logger = logging.getLogger(__name__)
    #         logger.error(f"Additional filtering error: {str(e)}")
            
    #         return Response({
    #             'error': 'Error processing filters.',
    #             'results': [],
    #             'count': 0
    #         }, status=400)
    #         # Get page from pagination
    #     page = self.paginate_queryset(queryset)
    #     if page is not None:
    #         serializer = self.get_serializer(page, many=True)
    #         return self.get_paginated_response(serializer.data)

    #     serializer = self.get_serializer(queryset, many=True)
    #     return Response(serializer.data)


    
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from datetime import datetime
from django.utils.timezone import make_aware
from .models import STTB_Dates, MTTB_LCL_Holiday


@api_view(['GET'])  # or ['GET'] if you want it triggered without payload
@permission_classes([IsAuthenticated])
def submit_eod_journal(request):
    today = datetime.today().date()
    current_year = today.year
    current_month = today.month
    current_day = today.day

    try:
        # Get Holiday Entry for Current Month and Year
        holiday = MTTB_LCL_Holiday.objects.get(HYear=str(current_year), HMonth=str(current_month))

        # Check Working Day from Holiday_List
        day_index = current_day - 1  # 0-based index
        if day_index >= len(holiday.Holiday_List):
            return Response({"status": "error", "message": "Holiday list does not include today."}, status=400)

        day_type = holiday.Holiday_List[day_index]
        if day_type != 'W':
            return Response({"status": "error", "message": f"Today is not a working day: {day_type}"}, status=400)

        # Check if EOD Already Submitted
        last_eod = STTB_Dates.objects.filter(eod_time='Y').order_by('-Start_Date').first()

        if last_eod and last_eod.Start_Date.date() >= today:
            return Response({"status": "error", "message": "EOD already submitted for today or later."}, status=400)

        # Save New EOD Entry
        new_eod = STTB_Dates.objects.create(
            Start_Date=make_aware(datetime.combine(today, datetime.min.time())),
            prev_Working_Day=last_eod.Start_Date if last_eod else None,
            next_working_Day=None,  # To be calculated if needed
            eod_time='Y'
        )

        return Response({
            "status": "success",
            "message": f"EOD submitted for {today}",
            "eod_id": new_eod.date_id
        }, status=201)

    except MTTB_LCL_Holiday.DoesNotExist:
        return Response({"status": "error", "message": "Holiday data not found for this month."}, status=404)

    except Exception as e:
        return Response({"status": "error", "message": str(e)}, status=500)
    


# from datetime import datetime, timedelta
# from django.utils import timezone
# import pytz
# from .models import MTTB_LCL_Holiday, STTB_Dates

# @api_view(['POST'])
# @permission_classes([IsAuthenticated])
# def end_of_day_journal_view(request):
#     """
#     API endpoint to validate and process end-of-day journal submission.
#     Requires authentication.
#     """
#     success, message = end_of_day_journal()
#     if success:
#         return Response({"message": message}, status=status.HTTP_201_CREATED)
#     return Response({"error": message}, status=status.HTTP_400_BAD_REQUEST)
# def end_of_day_journal():
#     """
#     Validates and processes end-of-day journal submission.
#     Checks if today is a working day and matches the next_working_date in STTB_Dates.
#     If valid, creates a new STTB_Dates entry for the next working day.
    
#     Returns:
#         tuple: (bool, str) - (Success status, Message)
#     """
#     try:
#         # Set timezone to +07:00 as per user context
#         tz = pytz.timezone('Asia/Bangkok')  # UTC+07:00
#         today = timezone.now().astimezone(tz).date()
#         year_str = str(today.year)
#         month_str = str(today.month).zfill(2)  # Ensure two-digit month
#         print(f"Processing end-of-day journal for {year_str}-{month_str} on {today} in timezone {tz}")
#         # Step 1: Check if today is a working day in MTTB_LCL_Holiday
#         try:
#             holiday_record = MTTB_LCL_Holiday.objects.get(
#                 HYear=year_str, HMonth=month_str
#             )
#             print(f"Holiday record found for {year_str}-{month_str}: {holiday_record.Holiday_List}")
#         except MTTB_LCL_Holiday.DoesNotExist:
#             return False, f"No holiday record found for {year_str}-{month_str}."

#         holiday_list = holiday_record.Holiday_List
#         if len(holiday_list) != 31:
#             return False, "Invalid Holiday_List length. Must be 31 characters."

#         # Get the day index (1-based) for today
#         day_index = today.day - 1
#         if day_index >= len(holiday_list) or holiday_list[day_index] != 'W':
#             return False, f"Today ({today}) is not a working day."

#         # Step 2: Check the latest STTB_Dates row
#         try:
#             latest_eod = STTB_Dates.objects.latest('date_id')
#         except STTB_Dates.DoesNotExist:
#             return False, "No records found in STTB_Dates."

#         # Convert next_working_day to date for comparison
#         next_working_date = latest_eod.next_working_Day.astimezone(tz).date()
#         if next_working_date != today:
#             return False, f"Today ({today}) does not match the next working day ({next_working_date})."

#         # Step 3: Find the next working day after today
#         current_date = today
#         next_working_date = None
#         while True:
#             current_date += timedelta(days=1)
#             # Check if we need to fetch a new holiday record for the next month
#             if current_date.month != today.month:
#                 try:
#                     holiday_record = MTTB_LCL_Holiday.objects.get(
#                         HYear=str(current_date.year), HMonth=str(current_date.month).zfill(2),
#                         Record_Status='C', Auth_Status='U'
#                     )
#                     holiday_list = holiday_record.Holiday_List
#                 except MTTB_LCL_Holiday.DoesNotExist:
#                     return False, f"No holiday record found for {current_date.year}-{current_date.month:02d}."
#             day_index = current_date.day - 1
#             if day_index < len(holiday_list) and holiday_list[day_index] == 'W':
#                 next_working_date = current_date
#                 break
#             if current_date > today + timedelta(days=31):  # Prevent infinite loop
#                 return False, "No working day found in the next 31 days."

#         # Step 4: Create new STTB_Dates entry
#         new_eod = STTB_Dates(
#             Start_Date=latest_eod.next_working_Day,  # Use next_working_Day from latest row
#             prev_Working_Day=latest_eod.Start_Date,  # Use Start_Date from latest row
#             next_working_Day=timezone.make_aware(
#                 datetime.combine(next_working_date, datetime.min.time()), timezone=tz
#             ),
#             eod_time='N'
#         )
#         new_eod.save()

#         return True, f"Journal submission successful for {today}. New entry created for {next_working_date}."

#     except Exception as e:
#         return False, f"Error processing journal submission: {str(e)}"


# from datetime import datetime, timedelta
# from django.utils import timezone
# from django.db import transaction
# import pytz
# import logging
# from .models import MTTB_LCL_Holiday, STTB_Dates, MTTB_EOC_MAINTAIN, MTTB_Function_Desc, STTB_EOC_DAILY_LOG, ACTB_DAIRY_LOG, MTTB_DATA_Entry
# from rest_framework.decorators import api_view, permission_classes
# from rest_framework.permissions import IsAuthenticated
# from rest_framework.response import Response
# from rest_framework import status

# # Set up logging
# logger = logging.getLogger(__name__)

# @api_view(['POST'])
# @permission_classes([IsAuthenticated])
# def end_of_day_journal_view(request):
#     """
#     API endpoint with transaction support - all operations succeed or fail together.
#     Supports both normal and back-date EOD processing.
#     """
#     try:
#         # Check if this is a back-date submission
#         target_date = request.data.get('target_date')
#         eod_id = request.data.get('eod_id')
        
#         # Determine the processing date and mode
#         if target_date and eod_id:
#             # Back-date mode
#             if isinstance(target_date, str):
#                 processing_date = datetime.strptime(target_date, '%Y-%m-%d').date()
#             else:
#                 processing_date = target_date
            
#             is_back_date = True
#             logger.info(f"Starting BACK-DATE EOD process for date: {processing_date}, EOD ID: {eod_id}, User: {request.user}")
#         else:
#             # Normal mode
#             value_date = request.data.get('value_date')
#             if not value_date:
#                 processing_date = timezone.now().date()
#             elif isinstance(value_date, str):
#                 processing_date = datetime.strptime(value_date, '%Y-%m-%d').date()
#             else:
#                 processing_date = value_date
            
#             is_back_date = False
#             eod_id = None
#             logger.info(f"Starting NORMAL EOD process for date: {processing_date}, User: {request.user}")
        
#         with transaction.atomic():
#             # Step 1: Validate EOD requirements (different logic for back-date)
#             if is_back_date:
#                 validation_success, validation_message = validate_backdate_eod_requirements(processing_date, eod_id)
#             else:
#                 validation_success, validation_message = validate_normal_eod_requirements()
            
#             if not validation_success:
#                 logger.error(f"EOD validation failed: {validation_message}")
#                 raise Exception(validation_message)
            
#             # Step 2: Execute main EOD process
#             eod_success, eod_message = execute_eod_process(request.user, processing_date, is_back_date)
#             if not eod_success:
#                 logger.error(f"EOD process failed: {eod_message}")
#                 raise Exception(eod_message)
            
#             # Step 3: Handle EOD completion
#             if is_back_date:
#                 # Update the existing STTB_Dates record to mark as completed
#                 complete_success, complete_message = complete_backdate_eod(eod_id, request.user)
#                 if not complete_success:
#                     logger.error(f"Back-date EOD completion failed: {complete_message}")
#                     raise Exception(complete_message)
                
#                 # Clear EOD journal for the target date
#                 clear_success, clear_message = clear_eod_journal_with_transaction(processing_date)
#                 if not clear_success:
#                     logger.error(f"EOD clear failed: {clear_message}")
#                     raise Exception(clear_message)
                
#                 final_message = f"ການປະມວນຜົນ EOD ຍ້ອນຫຼັງສຳເລັດແລ້ວ ສຳລັບວັນທີ {processing_date}"
#             else:
#                 # Normal EOD - clear journal and create next working day
#                 clear_success, clear_message = clear_eod_journal_with_transaction(processing_date)
#                 if not clear_success:
#                     logger.error(f"EOD clear failed: {clear_message}")
#                     raise Exception(clear_message)
                
#                 final_message = f"ການປະມວນຜົນ EOD ສຳເລັດແລ້ວສົມບູນ ສຳລັບວັນທີ {processing_date}"
            
#             # All steps successful
#             logger.info(f"Complete EOD process successful for {processing_date} ({'back-date' if is_back_date else 'normal'} mode)")
            
#             return Response({
#                 "message": final_message,
#                 "success": True,
#                 "is_back_date": is_back_date,
#                 "processing_date": processing_date.isoformat(),
#                 "details": {
#                     "validation": validation_message,
#                     "eod_process": eod_message,
#                     "completion": complete_message if is_back_date else clear_message
#                 }
#             }, status=status.HTTP_201_CREATED)
    
#     except Exception as e:
#         logger.error(f"EOD process failed for {processing_date if 'processing_date' in locals() else 'unknown date'}: {str(e)}")
#         return Response({
#             "error": f"ການປະມວນຜົນ EOD ລົ້ມເຫລວ: {str(e)}",
#             "success": False
#         }, status=status.HTTP_400_BAD_REQUEST)

# def validate_normal_eod_requirements():
#     """
#     Validates if normal EOD can be performed (original validation logic)
#     """
#     try:
#         # Set timezone to +07:00 as per user context
#         tz = pytz.timezone('Asia/Bangkok')  # UTC+07:00
#         today = timezone.now().astimezone(tz).date()
#         year_str = str(today.year)
#         month_str = str(today.month).zfill(2)
        
#         # Check MTTB_DATA_Entry for bypass settings
#         try:
#             data_entry = MTTB_DATA_Entry.objects.filter(
#                 # Auth_Status='A'  # Uncomment if needed
#             ).first()
            
#             if data_entry and data_entry.MOD_NO == 'Y':
#                 # Bypass working day check
#                 logger.info("Working day check bypassed (MOD_NO = 'Y')")
#             else:
#                 # Step 1: Check if today is a working day
#                 try:
#                     holiday_record = MTTB_LCL_Holiday.objects.get(
#                         HYear=year_str, HMonth=month_str
#                     )
#                 except MTTB_LCL_Holiday.DoesNotExist:
#                     return False, f"No holiday record found for {year_str}-{month_str}."

#                 holiday_list = holiday_record.Holiday_List
#                 if len(holiday_list) != 31:
#                     return False, "Invalid Holiday_List length. Must be 31 characters."

#                 day_index = today.day - 1
#                 if day_index >= len(holiday_list) or holiday_list[day_index] != 'W':
#                     return False, f"Today ({today}) is not a working day."
        
#         except Exception:
#             # If can't check data entry, use normal validation
#             pass

#         # Step 2: Check the latest STTB_Dates row
#         try:
#             latest_eod = STTB_Dates.objects.latest('date_id')
#         except STTB_Dates.DoesNotExist:
#             return False, "No records found in STTB_Dates."

#         next_working_date = latest_eod.next_working_Day.astimezone(tz).date()
#         if next_working_date != today:
#             return False, f"Today ({today}) does not match the next working day ({next_working_date})."

#         if latest_eod.eod_time != 'Y':
#             return False, f"EOD did not completed for today (eod_time = '{latest_eod.eod_time}')."

#         return True, f"Normal EOD validation passed for {today}"

#     except Exception as e:
#         return False, f"Error in normal EOD validation: {str(e)}"
# def validate_backdate_eod_requirements(target_date, eod_id):
#     """
#     Validates if back-date EOD can be performed
#     """
#     try:
#         tz = pytz.timezone('Asia/Bangkok')
#         today = timezone.now().astimezone(tz).date()
        
#         # Check if BACK_VALUE is enabled
#         try:
#             data_entry = MTTB_DATA_Entry.objects.filter(
#                 # Auth_Status='A'  # Uncomment if needed
#             ).first()
            
#             if not data_entry or data_entry.BACK_VALUE != 'Y':
#                 return False, "Back-date processing is not enabled (BACK_VALUE != 'Y')."
        
#         except Exception:
#             return False, "Could not verify back-date settings."

#         # Verify the EOD record exists and matches
#         try:
#             eod_record = STTB_Dates.objects.get(date_id=eod_id)
#         except STTB_Dates.DoesNotExist:
#             return False, f"EOD record with ID {eod_id} not found."

#         # Check if the target date matches the EOD record
#         eod_next_working = eod_record.Start_Date.astimezone(tz).date()
#         if eod_next_working != target_date:
#             return False, f"Target date ({target_date}) does not match EOD record Start_Date ({eod_next_working})."

#         # Check if this EOD is still pending (not yet completed)
#         if eod_record.eod_time == 'Y':
#             return False, f"EOD for {target_date} is already completed."

#         # Verify that target_date is in the past (back-dating)
#         if target_date >= today:
#             return False, f"Target date ({target_date}) must be in the past for back-dating."

#         return True, f"Back-date EOD validation passed for {target_date} (EOD ID: {eod_id})"

#     except Exception as e:
#         return False, f"Error in back-date EOD validation: {str(e)}"
# def complete_backdate_eod(eod_id, user):
#     """
#     Mark the back-date EOD as completed by updating the STTB_Dates record
#     """
#     try:
#         tz = pytz.timezone('Asia/Bangkok')
#         current_time = timezone.now().astimezone(tz)
        
#         # Update the EOD record to mark as completed
#         eod_record = STTB_Dates.objects.get(date_id=eod_id)
#         eod_record.eod_time = 'Y'  # Mark as completed
#         eod_record.Checker_Id = user.user_name
#         eod_record.Checker_DT_Stamp = current_time
#         eod_record.save()
        
#         logger.info(f"Back-date EOD {eod_id} marked as completed by {user.user_name}")
        
#         return True, f"Back-date EOD {eod_id} marked as completed successfully."
        
#     except STTB_Dates.DoesNotExist:
#         return False, f"EOD record {eod_id} not found."
#     except Exception as e:
#         return False, f"Error completing back-date EOD: {str(e)}"

# def execute_eod_process(user, processing_date, is_back_date=False):
#     """
#     Main EOD execution process that runs all sub-functions in sequence
#     Updated to handle both normal and back-date processing
#     """
#     try:
#         with transaction.atomic():
#             # Get all EOD functions ordered by sequence
#             eod_functions = get_eod_functions()
            
#             if not eod_functions:
#                 return False, "ບໍ່ພົບຟັງຊັນ EOD ທີ່ຕ້ອງປະມວນຜົນ"
            
#             # Execute functions in sequence
#             execution_results = []
#             total_executed = 0
#             total_skipped = 0
            
#             for eod_function in eod_functions:
#                 try:
#                     if should_execute_function(eod_function):
#                         # Execute the function with processing date context
#                         func_success, func_message = execute_eod_function(eod_function, user, processing_date, is_back_date)
                        
#                         if func_success:
#                             total_executed += 1
#                             execution_results.append({
#                                 'function': eod_function.function_id.description_la,
#                                 'status': 'success',
#                                 'message': func_message
#                             })
#                             logger.info(f"EOD Function {eod_function.function_id.function_id} executed successfully for {processing_date}")
#                         else:
#                             # If any critical function fails, stop the process
#                             logger.error(f"EOD Function {eod_function.function_id.function_id} failed: {func_message}")
#                             return False, f"ຟັງຊັນ {eod_function.function_id.description_la} ລົ້ມເຫລວ: {func_message}"
#                     else:
#                         total_skipped += 1
#                         execution_results.append({
#                             'function': eod_function.function_id.description_la,
#                             'status': 'skipped',
#                             'message': 'ຟັງຊັນຖືກປິດ (Record_Status = C)'
#                         })
#                         logger.info(f"EOD Function {eod_function.function_id.function_id} skipped (closed)")
                        
#                 except Exception as e:
#                     logger.error(f"Error executing EOD function {eod_function.function_id.function_id}: {str(e)}")
#                     return False, f"ຂໍ້ຜິດພາດໃນຟັງຊັນ {eod_function.function_id.description_la}: {str(e)}"
            
#             # Only create next working day entry for normal EOD (not back-date)
#             if not is_back_date:
#                 success, message = create_next_working_day_entry(user)
#                 if not success:
#                     return False, f"ບໍ່ສາມາດສ້າງ entry ວັນເຮັດການໃໝ່ໄດ້: {message}"
            
#             # Prepare summary message
#             mode_text = "ຍ້ອນຫຼັງ" if is_back_date else "ປົກກະຕິ"
#             summary_message = f"ປິດບັນຊີ{mode_text}ສຳເລັດແລ້ວສຳລັບ {processing_date} - ປະມວນຜົນ: {total_executed} ຟັງຊັນ, ຂ້າມ: {total_skipped} ຟັງຊັນ"
            
#             return True, summary_message

#     except Exception as e:
#         logger.error(f"Error in EOD process execution: {str(e)}")
#         return False, f"ເກີດຂໍ້ຜິດພາດໃນການປະມວນຜົນ EOD: {str(e)}"
# def get_eod_functions():
#     """
#     Get all EOD functions that should be considered for execution
#     """
#     return MTTB_EOC_MAINTAIN.objects.filter(
#         eoc_type='EOD',
#         Auth_Status='A'  # Only authorized functions
#     ).select_related('function_id', 'module_id').order_by('eoc_seq_no')

# def should_execute_function(eod_function):
#     """
#     Determine if a function should be executed based on its status
#     """
#     # Execute only if Record_Status is 'O' (Open)
#     return eod_function.Record_Status == 'O'


# def execute_eod_function(eod_function, user, processing_date=None, is_back_date=False):
#     """
#     Execute a specific EOD function based on its function_id
#     """
#     function_id = eod_function.function_id.function_id

#     context = f"back-date for {processing_date}" if is_back_date else f"normal for {processing_date or 'today'}"
#     logger.info(f"Executing function {function_id} ({context})")
    
#     try:
#         # Map function IDs to their corresponding execution methods
#         function_mapping = {
#             'FN006': execute_bulk_journal,
#             'EOD_BALANCE': execute_balance_calculation,
#             'EOD_INTEREST': execute_interest_calculation,
#             'EOD_REPORT': execute_report_generation,
#             'EOD_BACKUP': execute_backup_process,
#             # Add more function mappings as needed
#         }
        
#         if function_id in function_mapping:
#             # Execute the mapped function
#             return function_mapping[function_id](eod_function, user)
#         else:
#             # Generic execution for unmapped functions
#             return execute_generic_function(eod_function, user)
            
#     except Exception as e:
#         logger.error(f"Error executing function {function_id}: {str(e)}")
#         return False, f"ຂໍ້ຜິດພາດໃນການປະມວນຜົນ: {str(e)}"

# def get_processing_context():
#     """
#     Helper function that EOD functions can call to get current processing context
#     """
#     # This can be stored in thread-local storage, cache, or request context
#     from threading import local
    
#     if not hasattr(get_processing_context, '_context'):
#         get_processing_context._context = local()
    
#     return getattr(get_processing_context._context, 'eod_context', {
#         'processing_date': timezone.now().date(),
#         'is_back_date': False
#     })

# def set_processing_context(processing_date, is_back_date=False):
#     """
#     Set the current processing context for EOD functions
#     """
#     from threading import local
    
#     if not hasattr(get_processing_context, '_context'):
#         get_processing_context._context = local()
    
#     get_processing_context._context.eod_context = {
#         'processing_date': processing_date,
#         'is_back_date': is_back_date
#     }

# def complete_current_eod_and_create_next(user, processing_date):
#     """
#     Mark current EOD as completed and create next working day entry for normal EOD
#     """
#     try:
#         tz = pytz.timezone('Asia/Bangkok')
#         current_time = timezone.now().astimezone(tz)
        
#         # Get current EOD record
#         try:
#             current_eod = STTB_Dates.objects.latest('date_id')
#         except STTB_Dates.DoesNotExist:
#             return False, "No current EOD record found"
        
#         # Mark current EOD as completed
#         current_eod.eod_time = 'Y'
#         current_eod.Checker_Id = user.user_name
#         current_eod.Checker_DT_Stamp = current_time
#         current_eod.save()
        
#         # Create next working day entry
#         next_success, next_message = create_next_working_day_entry(user, processing_date)
#         if not next_success:
#             return False, f"EOD marked complete but failed to create next day: {next_message}"
        
#         return True, f"EOD {current_eod.date_id} completed and {next_message}"
        
#     except Exception as e:
#         return False, f"Error completing current EOD: {str(e)}"


# from datetime import datetime, timedelta, time
# from django.utils import timezone

# def create_next_working_day_entry(user, current_date=None):
#     """
#     Create the next working day entry in STTB_Dates.
#     Ensures Start_Date, prev_Working_Day, and next_working_Day are all set at 00:00:00
#     """
#     try:
#         tz = pytz.timezone('Asia/Bangkok')

#         # Step 1: Get current date
#         if current_date is None:
#             current_date = timezone.now().astimezone(tz).date()
#         elif isinstance(current_date, str):
#             current_date = datetime.strptime(current_date, '%Y-%m-%d').date()

#         # Step 2: Calculate the start date (next working day after current_date)
#         start_date = calculate_next_working_day(current_date + timedelta(days=1))
#         start_date_dt = tz.localize(datetime.combine(start_date, time(0, 0, 0)))

#         # Step 3: Calculate previous working day (working day before start_date)
#         prev_working_date = calculate_previous_working_day(start_date)
#         prev_working_day_dt = tz.localize(datetime.combine(prev_working_date, time(0, 0, 0)))

#         # Step 4: Calculate next working day (working day after start_date)
#         next_working_date = calculate_next_working_day(start_date + timedelta(days=1))
#         next_working_day_dt = tz.localize(datetime.combine(next_working_date, time(0, 0, 0)))

#         # Step 5: Save to DB
#         new_eod = STTB_Dates.objects.create(
#             Start_Date=start_date_dt,
#             prev_Working_Day=prev_working_day_dt,
#             next_working_Day=next_working_day_dt,
#             eod_time='Y'
#         )

#         logger.info(f"✅ EOD created: ID={new_eod.date_id}, Start={start_date_dt}, Prev={prev_working_day_dt}, Next={next_working_day_dt}")
#         return True, f"Created EOD for {start_date_dt.date()}"

#     except Exception as e:
#         logger.error(f"❌ Error in EOD creation: {e}")
#         return False, str(e)

# def calculate_next_working_day(date):
#     """
#     Calculate the next working day based on holiday calendar
#     """
#     try:
#         current_date = date
#         max_iterations = 10  # Prevent infinite loop
#         iteration = 0
        
#         while iteration < max_iterations:
#             year_str = str(current_date.year)
#             month_str = str(current_date.month).zfill(2)
            
#             try:
#                 holiday_record = MTTB_LCL_Holiday.objects.get(
#                     HYear=year_str, HMonth=month_str
#                 )
#                 holiday_list = holiday_record.Holiday_List
                
#                 if len(holiday_list) >= current_date.day:
#                     day_index = current_date.day - 1
#                     if holiday_list[day_index] == 'W':  # Working day
#                         return current_date
                
#             except MTTB_LCL_Holiday.DoesNotExist:
#                 # If no holiday record, assume it's a working day
#                 return current_date
            
#             # Move to next day
#             current_date = current_date + timedelta(days=1)
#             iteration += 1
        
#         # Fallback: return the original date + 1 if no working day found
#         logger.warning(f"Could not find working day after {max_iterations} iterations, using fallback")
#         return date + timedelta(days=1)
#     except Exception as e:
#         logger.error(f"Error calculating next working day: {str(e)}")
#         # Fallback: return next day    
#         return date + timedelta(days=1)

# def calculate_previous_working_day(date):
#     """
#     Calculate the previous working day based on holiday calendar
#     """
#     try:
#         current_date = date - timedelta(days=1)
#         max_iterations = 10  # Prevent infinite loop
#         iteration = 0
        
#         while iteration < max_iterations:
#             year_str = str(current_date.year)
#             month_str = str(current_date.month).zfill(2)
            
#             try:
#                 holiday_record = MTTB_LCL_Holiday.objects.get(
#                     HYear=year_str, HMonth=month_str
#                 )
#                 holiday_list = holiday_record.Holiday_List
                
#                 if len(holiday_list) >= current_date.day:
#                     day_index = current_date.day - 1
#                     if holiday_list[day_index] == 'W':  # Working day
#                         return current_date
                
#             except MTTB_LCL_Holiday.DoesNotExist:
#                 # If no holiday record, assume it's a working day
#                 return current_date
            
#             # Move to previous day
#             current_date = current_date - timedelta(days=1)
#             iteration += 1
        
#         # Fallback: return the original date - 1 if no working day found
#         logger.warning(f"Could not find previous working day after {max_iterations} iterations, using fallback")
#         return date - timedelta(days=1)
#     except Exception as e:
#         logger.error(f"Error calculating previous working day: {str(e)}")
#         # Fallback: return previous day    
#         return date - timedelta(days=1)

# def clear_eod_journal_with_transaction(value_date):
#     """
#     Your existing clear_eod_journal_with_transaction function
#     (keeping it unchanged as it works correctly)
#     """
#     try:
#         from datetime import datetime
#         from django.db import transaction
#         from .models import DETB_JRNL_LOG, DETB_JRNL_LOG_MASTER
        
#         # Convert value_date to proper format if it's a string
#         if isinstance(value_date, str):
#             value_date = datetime.strptime(value_date, '%Y-%m-%d').date()
        
#         with transaction.atomic():
#             cleared_count = 0
#             cleared_details = []
            
#             # Clear ACTB_DAIRY_LOG for specific date
#             actb_count = ACTB_DAIRY_LOG.objects.filter(value_dt=value_date).count()
#             if actb_count > 0:
#                 ACTB_DAIRY_LOG.objects.filter(value_dt=value_date).delete()
#                 cleared_count += actb_count
#                 cleared_details.append(f"ACTB_DAIRY_LOG: {actb_count}")
            
#             # Clear DETB_JRNL_LOG for specific date
#             jrnl_count = DETB_JRNL_LOG.objects.filter(Value_date=value_date).count()
#             if jrnl_count > 0:
#                 DETB_JRNL_LOG.objects.filter(Value_date=value_date).delete()
#                 cleared_count += jrnl_count
#                 cleared_details.append(f"DETB_JRNL_LOG: {jrnl_count}")
            
#             # Clear DETB_JRNL_LOG_MASTER for specific date
#             master_count = DETB_JRNL_LOG_MASTER.objects.filter(Value_date=value_date).count()
#             if master_count > 0:
#                 DETB_JRNL_LOG_MASTER.objects.filter(Value_date=value_date).delete()
#                 cleared_count += master_count
#                 cleared_details.append(f"DETB_JRNL_LOG_MASTER: {master_count}")
            
#             if cleared_count > 0:
#                 details_str = ", ".join(cleared_details)
#                 message = f"ລຶບຂໍ້ມູນ EOD ສຳເລັດສຳລັບວັນທີ {value_date} (ດ້ວຍ Transaction). ລາຍການທີ່ລຶບ: {details_str}. ລວມ: {cleared_count} ລາຍການ"
#                 logger.info(f"EOD journal cleared with transaction for date {value_date}. Total: {cleared_count}")
#                 return True, message
#             else:
#                 message = f"ບໍ່ມີຂໍ້ມູນ EOD ໃຫ້ລຶບສຳລັບວັນທີ {value_date}"
#                 logger.info(f"No EOD journal entries found for date {value_date}")
#                 return True, message
                
#     except Exception as e:
#         error_message = f"ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນ EOD ດ້ວຍ Transaction ສຳລັບວັນທີ {value_date}: {str(e)}"
#         logger.error(error_message)
#         return False, error_message

from django.db import transaction
from django.core.exceptions import ValidationError
import logging

logger = logging.getLogger(__name__)

def execute_bulk_journal(eod_function, user):
    """
    Execute the bulk journal function (move data from ACTB_DAIRY_LOG to STTB_EOC_DAILY_LOG)
    """
    try:
        with transaction.atomic():
            # Fetch authorized records from ACTB_DAIRY_LOG
            authorized_logs = ACTB_DAIRY_LOG.objects.filter(Auth_Status='A')
            
            if not authorized_logs.exists():
                return True, "ບໍ່ມີ journal ທີ່ຕ້ອງປະມວນຜົນ"
            
            logger.info(f"Processing {authorized_logs.count()} authorized journal entries")
            
            # Prepare bulk create objects
            eoc_logs = []
            processed_ids = []
            
            # Iterate through authorized logs and prepare STTB_EOC_DAILY_LOG objects
            for log in authorized_logs:
                try:
                    # Debug: Print log data to understand the structure
                    logger.debug(f"Processing log ID {log.ac_entry_sr_no}")
                    
                    # Extract ForeignKey values properly
                    # Module field -> module_id
                    module_value = ''
                    if log.module:
                        module_value = str(getattr(log.module, 'module_code', 
                                         getattr(log.module, 'code', 
                                         getattr(log.module, 'module_Id',
                                         getattr(log.module, 'id', '')))))[:2]  # Max 2 chars
                    if not module_value:
                        module_value = 'GL'  # Default module
                    
                    # Transaction reference number - keep as is
                    trn_ref_no_value = ''
                    if log.trn_ref_no:
                        trn_ref_no_value = str(log.trn_ref_no)[:35]  # Max 35 chars
                    else:
                        trn_ref_no_value = f'TRN{log.ac_entry_sr_no}'[:35]
                    
                    # Account number -> ac_no_id
                    ac_no_value = ''
                    if log.ac_no:
                        ac_no_value = str(getattr(log.ac_no, 'gl_sub_code', 
                                        getattr(log.ac_no, 'account_no', 
                                        getattr(log.ac_no, 'account_code',
                                        getattr(log.ac_no, 'code',
                                        getattr(log.ac_no, 'id', ''))))))[:50]  # Max 50 chars
                    if not ac_no_value:
                        ac_no_value = f'AC{log.ac_entry_sr_no}'[:50]
                    
                    # Currency -> ac_ccy_id
                    ac_ccy_value = ''
                    if log.ac_ccy:
                        ac_ccy_value = str(getattr(log.ac_ccy, 'ccy_code', 
                                         getattr(log.ac_ccy, 'currency_code',
                                         getattr(log.ac_ccy, 'code', 
                                         getattr(log.ac_ccy, 'id', '')))))[:3]  # Max 3 chars
                    if not ac_ccy_value:
                        ac_ccy_value = 'LAK'  # Default currency
                    
                    # Transaction code -> trn_code_id
                    trn_code_value = ''
                    if log.trn_code:
                        trn_code_value = str(getattr(log.trn_code, 'trn_code', 
                                           getattr(log.trn_code, 'transaction_code',
                                           getattr(log.trn_code, 'code', 
                                           getattr(log.trn_code, 'id', '')))))[:3]  # Max 3 chars
                    if not trn_code_value:
                        trn_code_value = 'GL'  # Default transaction code
                    
                    # Financial cycle -> financial_cycle_id
                    financial_cycle_value = ''
                    if log.financial_cycle:
                        financial_cycle_value = str(getattr(log.financial_cycle, 'fin_cycle', 
                                                  getattr(log.financial_cycle, 'financial_cycle',
                                                  getattr(log.financial_cycle, 'cycle', 
                                                  getattr(log.financial_cycle, 'id', '')))))[:9]  # Max 9 chars
                    if not financial_cycle_value:
                        financial_cycle_value = '2025'  # Default financial cycle
                    
                    # Period code -> period_code_id
                    period_code_value = ''
                    if log.period_code:
                        period_code_value = str(getattr(log.period_code, 'per_code', 
                                              getattr(log.period_code, 'period_code',
                                              getattr(log.period_code, 'code', 
                                              getattr(log.period_code, 'id', '')))))[:6]  # Max 6 chars
                    if not period_code_value:
                        period_code_value = f'{log.trn_dt.year}{log.trn_dt.month:02d}' if log.trn_dt else '202508'
                    
                    # Maker ID -> Maker_id_id
                    maker_id_value = ''
                    if log.Maker_id:
                        maker_id_value = str(getattr(log.Maker_id, 'user_id', 
                                           getattr(log.Maker_id, 'user_name', 
                                           getattr(log.Maker_id, 'username',
                                           getattr(log.Maker_id, 'id', '')))))[:12]  # Max 12 chars
                    
                    # Checker ID -> Checker_id_id
                    checker_id_value = ''
                    if log.Checker_id:
                        checker_id_value = str(getattr(log.Checker_id, 'user_id', 
                                             getattr(log.Checker_id, 'user_name', 
                                             getattr(log.Checker_id, 'username',
                                             getattr(log.Checker_id, 'id', '')))))[:12]  # Max 12 chars
                    
                    # GL ID -> glid_id
                    glid_value = ''
                    if log.glid:
                        glid_value = str(getattr(log.glid, 'gl_code', 
                                       getattr(log.glid, 'account_code',
                                       getattr(log.glid, 'code', 
                                       getattr(log.glid, 'id', '')))))[:50]  # Max 50 chars
                    
                    # Handle event_sr_no conversion from BigInt to Int
                    event_sr_no_value = log.event_sr_no or 0
                    if event_sr_no_value > 2147483647:  # Max int value
                        event_sr_no_value = 2147483647
                    
                    # Create STTB_EOC_DAILY_LOG object with correct field names
                    eoc_log = STTB_EOC_DAILY_LOG(
                        # Note: ac_entry_sr_no is AutoField, so we don't set it
                        module_id=module_value,                    # Fixed: module -> module_id
                        trn_ref_no=trn_ref_no_value,
                        trn_ref_sub_no=log.trn_ref_sub_no or '',
                        event_sr_no=event_sr_no_value,
                        event=log.event or '',
                        ac_no_id=ac_no_value,                     # Fixed: ac_no -> ac_no_id
                        ac_no_full=log.ac_no_full or '',
                        ac_relative=log.ac_relative or '',        # Fixed: gl_acc_relative -> ac_relative
                        ac_ccy_id=ac_ccy_value,                   # Fixed: ac_ccy -> ac_ccy_id
                        drcr_ind=log.drcr_ind or 'D',
                        trn_code_id=trn_code_value,               # Fixed: trn_code -> trn_code_id
                        fcy_dr=log.fcy_dr or 0,
                        fcy_cr=log.fcy_cr or 0,
                        lcy_dr=log.lcy_dr or 0,
                        lcy_cr=log.lcy_cr or 0,
                        fcy_amount=log.fcy_amount or 0,
                        exch_rate=log.exch_rate or 1,
                        lcy_amount=log.lcy_amount or 0,
                        external_ref_no=(log.external_ref_no or '')[:50],  # Max 50 chars in EOC
                        addl_text=log.addl_text or '',
                        addl_sub_text=log.addl_sub_text or '',
                        trn_dt=log.trn_dt,
                        glid_id=glid_value,                       # Fixed: Added glid_id field
                        glType=log.glType or '',                  # Fixed: type -> glType
                        category=log.category or '',
                        value_dt=log.value_dt,
                        financial_cycle_id=financial_cycle_value,  # Fixed: financial_cycle -> financial_cycle_id
                        period_code_id=period_code_value,         # Fixed: period_code -> period_code_id
                        Maker_id_id=maker_id_value,               # Fixed: Maker_id -> Maker_id_id
                        Maker_DT_Stamp=log.Maker_DT_Stamp,
                        Checker_id_id=checker_id_value,           # Fixed: Checker_id -> Checker_id_id
                        Checker_DT_Stamp=log.Checker_DT_Stamp,
                        Auth_Status=log.Auth_Status or 'U',
                        product=log.product or '',
                        entry_seq_no=log.entry_seq_no,
                        delete_stat=log.delete_stat or ''         # Added delete_stat field
                    )
                    
                    # Validate the object before adding to bulk list
                    eoc_log.full_clean()
                    eoc_logs.append(eoc_log)
                    processed_ids.append(log.ac_entry_sr_no)
                    
                except ValidationError as ve:
                    logger.error(f"Validation error for log ID {log.ac_entry_sr_no}: {ve}")
                    continue
                except Exception as e:
                    logger.error(f"Error processing log ID {log.ac_entry_sr_no}: {str(e)}")
                    import traceback
                    traceback.print_exc()
                    continue
            
            if not eoc_logs:
                return False, "ບໍ່ສາມາດປະມວນຜົນ journal ໃດໆໄດ້"
            
            # Check for existing records to avoid duplicates (optional)
            # You can uncomment this if you want to prevent duplicates
            # existing_ids = set(STTB_EOC_DAILY_LOG.objects.filter(
            #     trn_ref_no__in=[log.trn_ref_no for log in eoc_logs]
            # ).values_list('trn_ref_no', flat=True))
            # eoc_logs = [log for log in eoc_logs if log.trn_ref_no not in existing_ids]
            
            # Bulk create records in STTB_EOC_DAILY_LOG
            try:
                created_records = STTB_EOC_DAILY_LOG.objects.bulk_create(eoc_logs)
                logger.info(f"Successfully bulk created {len(created_records)} records")
            except Exception as bulk_error:
                logger.warning(f"Bulk create failed: {str(bulk_error)}, trying individual inserts...")
                # Fallback to individual creates if bulk create fails
                created_records = []
                failed_individual = []
                
                for i, eoc_log in enumerate(eoc_logs):
                    try:
                        eoc_log.save()
                        created_records.append(eoc_log)
                    except Exception as individual_error:
                        logger.error(f"Failed to create individual record {i}: {str(individual_error)}")
                        failed_individual.append(i)
                        # Remove this ID from processed_ids since it failed
                        if i < len(processed_ids):
                            processed_ids.remove(processed_ids[i])
                
                if failed_individual:
                    logger.warning(f"Failed to create {len(failed_individual)} individual records")
                    
                if not created_records:
                    return False, "ບໍ່ສາມາດບັນທຶກຂໍ້ມູນໃດໆໄດ້"
            
            # Update source records to prevent reprocessing
            # Mark as processed
            # ACTB_DAIRY_LOG.objects.filter(
            #     ac_entry_sr_no__in=processed_ids
            # ).update(Auth_Status='P')  # P for Processed
            
            # Alternative: Delete processed records (uncomment if needed)
            # ACTB_DAIRY_LOG.objects.filter(
            #     ac_entry_sr_no__in=processed_ids
            # ).delete()
            
            logger.info(f"Successfully processed {len(created_records)} journal entries")
            return True, f"ບັນທຶກ journal ສຳເລັດ: {len(created_records)} ລາຍການ"
        
    except Exception as e:
        logger.error(f"Error in execute_bulk_journal: {str(e)}")
        import traceback
        traceback.print_exc()
        return False, f"ຂໍ້ຜິດພາດໃນການບັນທຶກ journal: {str(e)}"

def execute_balance_calculation(eod_function, user):
    """
    Execute balance calculation function
    """
    try:
        # Add your balance calculation logic here
        # This is a placeholder implementation
        
        return True, "ຄິດໄລ່ຍອດເງິນສຳເລັດ"
        
    except Exception as e:
        return False, f"ຂໍ້ຜິດພາດໃນການຄິດໄລ່ຍອດເງິນ: {str(e)}"

def execute_interest_calculation(eod_function, user):
    """
    Execute interest calculation function
    """
    try:
        # Add your interest calculation logic here
        # This is a placeholder implementation
        
        return True, "ຄິດໄລ່ດອກເບ້ຍສຳເລັດ"
        
    except Exception as e:
        return False, f"ຂໍ້ຜິດພາດໃນການຄິດໄລ່ດອກເບ້ຍ: {str(e)}"

def execute_report_generation(eod_function, user):
    """
    Execute report generation function
    """
    try:
        # Add your report generation logic here
        # This is a placeholder implementation
        
        return True, "ສ້າງລາຍງານສຳເລັດ"
        
    except Exception as e:
        return False, f"ຂໍ້ຜິດພາດໃນການສ້າງລາຍງານ: {str(e)}"

def execute_backup_process(eod_function, user):
    """
    Execute backup process function
    """
    try:
        # Add your backup logic here
        # This is a placeholder implementation
        
        return True, "ສຳຮອງຂໍ້ມູນສຳເລັດ"
        
    except Exception as e:
        return False, f"ຂໍ້ຜິດພາດໃນການສຳຮອງຂໍ້ມູນ: {str(e)}"

def execute_generic_function(eod_function, user):
    """
    Generic function execution for unmapped functions
    """
    try:
        # Generic implementation - can be customized based on your needs
        # This could call external scripts, APIs, or other processes
        
        function_name = eod_function.function_id.description_la
        return True, f"ປະມວນຜົນຟັງຊັນ {function_name} ສຳເລັດ"
        
    except Exception as e:
        return False, f"ຂໍ້ຜິດພາດໃນການປະມວນຜົນຟັງຊັນ: {str(e)}"


from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
import pytz
from django.utils import timezone
from datetime import datetime, timedelta
from .models import MTTB_LCL_Holiday, STTB_Dates, MTTB_DATA_Entry

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_eod_target_date(request):
    """
    Enhanced endpoint that returns the target date for EOD operations.
    If BACK_VALUE = 'Y' and there are unsubmitted previous EODs, 
    returns the earliest unsubmitted date. Otherwise returns today.
    """
    try:
        tz = pytz.timezone('Asia/Bangkok')
        today = timezone.now().astimezone(tz).date()
        
        # Get MTTB_DATA_Entry configuration for BACK_VALUE check
        try:
            data_entry = MTTB_DATA_Entry.objects.filter(
                Auth_Status='A'
            ).first()
            
            back_value_enabled = data_entry and data_entry.BACK_VALUE == 'Y'
        except Exception as e:
            back_value_enabled = False

        # If BACK_VALUE is not enabled, return today
        if not back_value_enabled:
            return Response({
                "target_date": today.isoformat(),
                "is_back_date": False,
                "available": True,
                "reason": f"ມື້ນີ້ວັນທີ ({today}) ສາມາດບັນທຶກບັນຊີໄດ້.",
                "back_value_enabled": False
            }, status=status.HTTP_200_OK)

        # Get unsubmitted EOD dates (when BACK_VALUE = 'Y')
        unsubmitted_dates = []
        
        try:
            # Get all EOD records that haven't been submitted (eod_time = 'N')
            unsubmitted_eods = STTB_Dates.objects.filter(
                eod_time='N'
            ).order_by('next_working_Day')
            
            for eod_record in unsubmitted_eods:
                eod_date = eod_record.next_working_Day.astimezone(tz).date()
                # Only include dates that are before or equal to today
                if eod_date <= today:
                    unsubmitted_dates.append({
                        'date': eod_date,
                        'date_id': eod_record.date_id,
                        'is_today': eod_date == today
                    })
        except Exception as e:
            print(f"Error getting unsubmitted EODs: {e}")

        # Determine target date
        if unsubmitted_dates:
            # Get the earliest unsubmitted date
            earliest_unsubmitted = min(unsubmitted_dates, key=lambda x: x['date'])
            target_date = earliest_unsubmitted['date']
            is_back_date = target_date < today
            
            if is_back_date:
                reason = f"ມີການປິດບັນຊີທີ່ຍັງບໍ່ໄດ້ສົ່ງ. ກຳລັງປະມວນຜົນວັນທີ ({target_date}). ອະນຸຍາດໃຫ້ບັນທຶກຍ້ອນຫຼັງ (BACK_VALUE = 'Y')"
            else:
                reason = f"ມື້ນີ້ວັນທີ ({target_date}) ສາມາດບັນທຶກບັນຊີໄດ້. ອະນຸຍາດໃຫ້ບັນທຶກຍ້ອນຫຼັງ (BACK_VALUE = 'Y')"
        else:
            # No unsubmitted EODs, use today
            target_date = today
            is_back_date = False
            reason = f"ມື້ນີ້ວັນທີ ({today}) ສາມາດບັນທຶກບັນຊີໄດ້. ອະນຸຍາດໃຫ້ບັນທຶກຍ້ອນຫຼັງ (BACK_VALUE = 'Y')"

        return Response({
            "target_date": target_date.isoformat(),
            "is_back_date": is_back_date,
            "available": True,
            "reason": reason,
            "back_value_enabled": True,
            "unsubmitted_dates": [
                {
                    "date": item['date'].isoformat(),
                    "date_id": item['date_id'],
                    "is_today": item['is_today']
                } for item in unsubmitted_dates
            ],
            "unsubmitted_count": len(unsubmitted_dates)
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({
            "target_date": today.isoformat(),
            "is_back_date": False,
            "available": False,
            "reason": f"ເກີດຂໍ້ຜິດພາດໃນການກວດສອບວັນທີ: {str(e)}",
            "back_value_enabled": False
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_pending_journals_by_date(request):
    """
    Get pending journals for a specific date.
    If no date provided, uses the target date from get_eod_target_date logic.
    """
    try:
        tz = pytz.timezone('Asia/Bangkok')
        
        # Get target date from query parameter or determine automatically
        target_date_str = request.query_params.get('target_date')
        
        if target_date_str:
            try:
                target_date = datetime.strptime(target_date_str, '%Y-%m-%d').date()
            except ValueError:
                return Response({
                    "error": "Invalid date format. Use YYYY-MM-DD."
                }, status=status.HTTP_400_BAD_REQUEST)
        else:
            # Get target date using the same logic as get_eod_target_date
            target_date_response = get_eod_target_date(request)
            if target_date_response.status_code != 200:
                return target_date_response
            
            target_date_str = target_date_response.data['target_date']
            target_date = datetime.strptime(target_date_str, '%Y-%m-%d').date()

        # Convert target_date to datetime for filtering
        start_datetime = timezone.make_aware(
            datetime.combine(target_date, datetime.min.time()),
            timezone=tz
        )
        end_datetime = start_datetime + timedelta(days=1)

        # Get pending journals for the target date
        from .models import DETB_JRNL_LOG_MASTER
        
        pending_journals = DETB_JRNL_LOG_MASTER.objects.filter(
            Value_date__gte=start_datetime,
            Value_date__lt=end_datetime,
            Auth_Status__in=['U', 'P'],  # Pending approval or pending correction
            delete_stat__isnull=True
        ).exclude(delete_stat='D').select_related(
            'Maker_Id', 'Checker_Id', 'module_id', 'Ccy_cd', 'Txn_code'
        ).order_by('-Maker_DT_Stamp')

        # Serialize the data
        from .serializers import DETB_JRNL_LOG_MASTER_Serializer
        serializer = DETB_JRNL_LOG_MASTER_Serializer(pending_journals, many=True)

        return Response({
            "target_date": target_date.isoformat(),
            "journals": serializer.data,
            "count": len(serializer.data),
            "pending_count": len([j for j in serializer.data if j['Auth_Status'] == 'U']),
            "correction_count": len([j for j in serializer.data if j['Auth_Status'] == 'P'])
        }, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({
            "error": f"ເກີດຂໍ້ຜິດພາດໃນການໂຫຼດຂໍ້ມູນບັນຊີ: {str(e)}"
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


#---------Asset-------------
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.db import transaction
from .models import (FA_Asset_Type,FA_Chart_Of_Asset,FA_Suppliers,FA_Location,FA_Expense_Category,FA_Asset_Lists,FA_Asset_List_Disposal,FA_Asset_Expense,FA_Transfer_Logs,FA_Asset_Photos,FA_Maintenance_Logs,
                     FA_Accounting_Method,FA_Asset_List_Depreciation_Main,FA_Asset_List_Depreciation,FA_Asset_List_Depreciation_InMonth)
from .serializers import (FAAssetTypeSerializer,FAChartOfAssetSerializer,FASuppliersSerializer,FALocationSerializer,FAExpenseCategorySerializer,
    FAAssetListSerializer,FAAssetListDisposalSerializer,FAAssetListDepreciationMainSerializer,FAAssetListDepreciationSerializer,
    FAAssetExpenseSerializer,FATransferLogsSerializer,FAAssetPhotosSerializer,FAMaintenanceLogsSerializer,FAAccountingMethodSerializer,FAAssetListDepreciationInMonthSerializer)
from django.utils import timezone
from django.db.models.functions import Substr

class FAAssetTypeViewSet(viewsets.ModelViewSet):
    serializer_class = FAAssetTypeSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Asset_Type.objects.all().order_by('type_id')
        type_code = self.request.query_params.get('type_code')
        if type_code:
            queryset = queryset.filter(type_code=type_code)
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' """
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_tangible(self, request, pk=None):
        """Allow updating only the is_tangible field"""
        obj = self.get_object()
        new_status = request.data.get('is_tangible')

        if not new_status:
            return Response({'detail': 'is_tangible is required.'}, status=status.HTTP_400_BAD_REQUEST)

        obj.is_tangible = new_status
        obj.Checker_Id = request.user
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()

        serializer = self.get_serializer(obj)
        return Response({
            'message': f'Status updated to "{new_status}".',
            'entry': serializer.data
        })

class FAChartOfAssetViewSet(viewsets.ModelViewSet):
    serializer_class = FAChartOfAssetSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Chart_Of_Asset.objects.select_related('asset_type_id').all().order_by('coa_id')

        asset_code = self.request.query_params.get('asset_code')
        asset_type_id = self.request.query_params.get('asset_type_id')
        is_tangible = self.request.query_params.get('is_tangible')

        if asset_type_id:
            queryset = queryset.filter(asset_type_id=asset_type_id)
        if asset_code:
            queryset = queryset.filter(asset_code=asset_code)
        if is_tangible:
            queryset = queryset.filter(asset_type_id__is_tangible=is_tangible)  # join by asset_type

        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O'"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

class FASuppliersViewSet(viewsets.ModelViewSet):
    serializer_class = FASuppliersSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Suppliers.objects.all().order_by('supplier_id')
        supplier_code = self.request.query_params.get('supplier_code')
        if supplier_code:
            queryset = queryset.filter(supplier_code=supplier_code)
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O'"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

class FALocationViewSet(viewsets.ModelViewSet):
    serializer_class = FALocationSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Location.objects.all().order_by('location_id')
        location_code = self.request.query_params.get('location_code')
        if location_code:
            queryset = queryset.filter(location_code=location_code)
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O'"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

class FAExpenseCategoryViewSet(viewsets.ModelViewSet):
    serializer_class = FAExpenseCategorySerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Expense_Category.objects.all().order_by('ec_id')
        category_code = self.request.query_params.get('category_code')
        if category_code:
            queryset = queryset.filter(category_code=category_code)
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O'"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_y_approve(self, request, pk=None):
        """Set required_approval = 'Y' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.required_approval == 'Y':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.required_approval = 'Y'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_n_approve(self, request, pk=None):
        """Set required_approval = 'N' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.required_approval == 'N':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.required_approval = 'N'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

# views.py
from django.db import transaction
from rest_framework import status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db.models import Max
import logging
from django.db import transaction, connection
from rest_framework import status
from rest_framework.decorators import action
from rest_framework.response import Response
logger = logging.getLogger(__name__)
from rest_framework.decorators import action
from django.db import transaction, connection
from rest_framework import status
from rest_framework.decorators import action
from rest_framework.response import Response
import logging

logger = logging.getLogger(__name__)

class FAAssetListViewSet(viewsets.ModelViewSet):
    serializer_class = FAAssetListSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Asset_Lists.objects.select_related(
            'asset_type_id', 'asset_location_id', 'supplier_id', 'division'
        ).order_by('asset_list_id')

        filters = {}
        asset_tag = self.request.query_params.get('asset_tag')
        asset_type_id = self.request.query_params.get('asset_type_id')
        asset_status = self.request.query_params.get('asset_status')
        Auth_Status = self.request.query_params.get('Auth_Status')

        if asset_tag:
            filters['asset_tag'] = asset_tag
        if asset_type_id:
            filters['asset_type_id'] = asset_type_id
        if asset_status:
            filters['asset_status'] = asset_status
        if Auth_Status:
            filters['Auth_Status'] = Auth_Status

        if filters:
            queryset = queryset.filter(**filters)

        return queryset


    @action(detail=False, methods=['post'], url_path='generate-next-code')
    def generate_next_code(self, request):
        """
        ໂທ SQL Server Stored Procedure
        """
        try:
            with connection.cursor() as cursor:
                # ໂທ stored procedure
                cursor.execute("EXEC GetNextAssetCode")
                
                # ອ່ານຜົນລັບ
                result = cursor.fetchone()
                
                if result and len(result) >= 3:
                    next_code, success, message = result
                    
                    if success == 1:  # success = 1 ແມ່ນສຳເລັດ
                        return Response({
                            'next_code': next_code,
                            'success': True,
                            'message': message or f'Generated: {next_code}'
                        })
                    else:
                        return Response({
                            'error': message or 'Stored procedure failed',
                            'success': False
                        }, status=500)
                else:
                    return Response({
                        'error': 'Invalid response from stored procedure',
                        'success': False
                    }, status=500)
                
        except Exception as e:
            logger.error(f"Stored procedure error: {str(e)}")
            return Response({
                'error': 'Database error',
                'detail': str(e),
                'success': False
            }, status=500)
# class FADepreciationMainViewSet(viewsets.ModelViewSet):
#     serializer_class = FADepreciationMainSerializer
#     permission_classes = [IsAuthenticated]

#     def get_queryset(self):
#         queryset = FA_Depreciation_Main.objects.all().order_by('dm_id')
#         dpca_type = self.request.query_params.get('dpca_type')
#         if dpca_type:
#             queryset = queryset.filter(dpca_type=dpca_type)
#         return queryset
    
#     def perform_create(self, serializer):
#         user = self.request.user
#         serializer.save(
#             Maker_Id=user,
#             Maker_DT_Stamp=timezone.now()
#         )

#     def perform_update(self, serializer):
#         user = self.request.user
#         serializer.save(
#             Checker_Id=user,
#             Checker_DT_Stamp=timezone.now()
#         )
    

# class FADepreciationSubViewSet(viewsets.ModelViewSet):
#     serializer_class = FADepreciationSubSerializer
#     permission_classes = [IsAuthenticated]

#     def get_queryset(self):
#         queryset = FA_Depreciation_Sub.objects.all().order_by('ds_id')
#         m_id = self.request.query_params.get('m_id')
#         if m_id:
#             queryset = queryset.filter(m_id=m_id)
#         return queryset
    
#     def perform_create(self, serializer):
#         user = self.request.user
#         serializer.save(
#             Maker_Id=user,
#             Maker_DT_Stamp=timezone.now()
#         )

#     def perform_update(self, serializer):
#         user = self.request.user
#         serializer.save(
#             Checker_Id=user,
#             Checker_DT_Stamp=timezone.now()
#         )
    

class FAAssetListDepreciationMainViewSet(viewsets.ModelViewSet):
    serializer_class = FAAssetListDepreciationMainSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Asset_List_Depreciation_Main.objects.select_related('asset_list_id')
        asset_list_id = self.request.query_params.get('asset_list_id')
        aldm_month_id = self.request.query_params.get('aldm_month_id')

        if asset_list_id:
            queryset = queryset.filter(asset_list_id=asset_list_id)
        if aldm_month_id:
            queryset = queryset.filter(aldm_month_id=aldm_month_id)

        queryset = queryset.order_by('aldm_id')
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O'"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})
    
class FAAssetListDepreciationViewSet(viewsets.ModelViewSet):
    serializer_class = FAAssetListDepreciationSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Asset_List_Depreciation.objects.all().order_by('ald_id')
        asset_list_id = self.request.query_params.get('asset_list_id')
        if asset_list_id:
            queryset = queryset.filter(asset_list_id=asset_list_id)
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O'"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})
    
class FAAssetListDisposalViewSet(viewsets.ModelViewSet):
    serializer_class = FAAssetListDisposalSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        queryset = FA_Asset_List_Disposal.objects.all().order_by('alds_id')
        asset_list_id = self.request.query_params.get('asset_list_id')
        if asset_list_id:
            queryset = queryset.filter(asset_list_id=asset_list_id)
        return queryset
        
    def perform_create(self, serializer):
        user = self.request.user
        instance = serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )
        
        # ອັບເດດ asset_status ເປັນ 'DS' ໃນຕາຕະລາງ FA_Asset_Lists
        if instance.asset_list_id:
            try:
                # ເຂົ້າເຖິງຜ່ານ ForeignKey relationship
                asset_list = instance.asset_list_id
                asset_list.asset_status = 'DS'
                asset_list.save()
            except Exception as e:
                # ຖ້າມີ error ກໍ່ຜ່ານໄປ
                print(f"Error updating asset status: {e}")
                pass
    
    def perform_update(self, serializer):
        user = self.request.user
        instance = serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )
        
        # ອັບເດດ asset_status ເປັນ 'DS' ໃນຕາຕະລາງ FA_Asset_Lists
        if instance.asset_list_id:
            try:
                # ເຂົ້າເຖິງຜ່ານ ForeignKey relationship
                asset_list = instance.asset_list_id
                asset_list.asset_status = 'DS'
                asset_list.save()
            except Exception as e:
                # ຖ້າມີ error ກໍ່ຜ່ານໄປ
                print(f"Error updating asset status: {e}")
                pass

    def perform_update(self, serializer):
        user = self.request.user
        instance = serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )
        
        # ອັບເດດ asset_status ເປັນ 'DS' ໃນຕາຕະລາງ FA_Asset_Lists
        if instance.asset_list_id:
            try:
                asset_list = FA_Asset_Lists.objects.get(id=instance.asset_list_id)
                asset_list.asset_status = 'DS'
                asset_list.save()
            except FA_Asset_Lists.DoesNotExist:
                # ຖ້າບໍ່ເຈົ້າ record ໃນ FA_Asset_Lists ກໍ່ຜ່ານໄປ
                pass

class FAAssetExpenseViewSet(viewsets.ModelViewSet):
    serializer_class = FAAssetExpenseSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Asset_Expense.objects.all().order_by('ae_id')
        asset_list_id = self.request.query_params.get('asset_list_id')
        if asset_list_id:
            queryset = queryset.filter(asset_list_id=asset_list_id)
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )

# class FATransferLogsViewSet(viewsets.ModelViewSet):
#     serializer_class = FATransferLogsSerializer
#     permission_classes = [IsAuthenticated]

#     def get_queryset(self):
#         queryset = FA_Transfer_Logs.objects.all().order_by('transfer_id')
#         asset_list_id = self.request.query_params.get('asset_list_id')
#         if asset_list_id:
#             queryset = queryset.filter(asset_list_id=asset_list_id)
#         return queryset
    
#     def perform_create(self, serializer):
#         user = self.request.user
#         serializer.save(
#             Maker_Id=user,
#             Maker_DT_Stamp=timezone.now()
#         )

#     def perform_update(self, serializer):
#         user = self.request.user
#         serializer.save(
#             Checker_Id=user,
#             Checker_DT_Stamp=timezone.now()
#         )
# ເພີ່ມ imports ໃນດ້ານເທິງຂອງ file
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from django.utils import timezone
from .models import FA_Transfer_Logs, FA_Asset_Lists  # ເພີ່ມ imports ເຫຼົ່ານີ້
from .serializers import FATransferLogsSerializer
class FATransferLogsViewSet(viewsets.ModelViewSet):
    queryset = FA_Transfer_Logs.objects.all()
    serializer_class = FATransferLogsSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Transfer_Logs.objects.all().order_by('transfer_id')
        asset_list_id = self.request.query_params.get('asset_list_id')
        if asset_list_id:
            queryset = queryset.filter(asset_list_id=asset_list_id)
        return queryset

    def perform_create(self, serializer):
        from django.db import transaction
        import logging
        
        logger = logging.getLogger(__name__)
        user = self.request.user
        
        # Debug request data
        print(f"🔍 Raw request data keys: {list(self.request.data.keys())}")
        print(f"🔍 Raw request data: {dict(self.request.data)}")
        
        with transaction.atomic():
            # ບັນທຶກ transfer log
            print(f"🔍 Serializer validated data: {serializer.validated_data}")
            
            # ຮັບ division ຈາກ validated data
            division_data = serializer.validated_data.get('division')
            print(f"🔍 Division from validated_data: {division_data}")
            
            transfer_log = serializer.save(
                Maker_Id=user,
                Maker_DT_Stamp=timezone.now()
            )
            
            # ດຶງ division ຈາກ serializer ທີ່ເກັບໄວ້
            division_from_serializer = getattr(transfer_log, '_division_for_asset_update', None)
            print(f"🔍 Division from serializer: {division_from_serializer}")
            
            logger.info(f"Transfer log created: {transfer_log.transfer_id}")
            
            try:
                # Debug: ກວດສອບ transfer_log ກ່ອນ
                print(f"🔍 Transfer log asset_list_id: {transfer_log.asset_list_id}")
                print(f"🔍 Transfer log asset_list_id type: {type(transfer_log.asset_list_id)}")
                print(f"🔍 Transfer log asset_list_id pk: {transfer_log.asset_list_id.pk if transfer_log.asset_list_id else 'None'}")
                
                # ກວດສອບວ່າ asset_list_id ບໍ່ເປັນ None
                if not transfer_log.asset_list_id:
                    raise ValueError("Asset list ID is None")
                
                # ໃຊ້ asset object ທີ່ມີຢູ່ແລ້ວ
                asset_obj = transfer_log.asset_list_id
                
                # ລອງ get ແບບລະມັດລະວັງ
                try:
                    asset_obj_fresh = FA_Asset_Lists.objects.get(asset_list_id=asset_obj.asset_list_id)
                    print(f"✅ Successfully got fresh asset object: {asset_obj_fresh.asset_list_id}")
                    asset_obj = asset_obj_fresh
                except FA_Asset_Lists.DoesNotExist:
                    print(f"⚠️ Could not get fresh asset, using existing: {asset_obj.asset_list_id}")
                
                old_location = asset_obj.asset_location_id
                old_division = asset_obj.division
                new_location = transfer_log.to_location_id
                
                print(f"🔥 Asset ID: {asset_obj.asset_list_id}")
                print(f"🔥 Old location: {old_location}")
                print(f"🔥 New location: {new_location}")
                print(f"🔥 Old division: {old_division}")
                print(f"🔥 New location type: {type(new_location)}")
                
                # ກວດສອບວ່າ new_location ບໍ່ເປັນ None
                if new_location is None:
                    error_msg = "New location cannot be None"
                    logger.error(error_msg)
                    print(f"❌ ERROR: {error_msg}")
                    raise ValueError(error_msg)
                
                # ໃຊ້ division ທີ່ສົ່ງມາຈາກ frontend
                new_division = division_from_serializer
                if not new_division:
                    # ຖ້າບໍ່ມີ division ຈາກ serializer, ລອງຈາກ request.data
                    division_id = self.request.data.get('division')
                    if division_id:
                        try:
                            new_division = MTTB_Divisions.objects.get(pk=division_id)
                            print(f"🔥 Got division from request: {new_division}")
                        except MTTB_Divisions.DoesNotExist:
                            new_division = old_division
                            print(f"🔥 Division not found, keeping old: {old_division}")
                    else:
                        new_division = old_division
                        print(f"🔥 No division in request, keeping old: {old_division}")
                else:
                    print(f"🔥 Using division from frontend: {new_division}")
                
                print(f"🔥 Final new_division: {new_division}")
                print(f"🔥 New division type: {type(new_division)}")
                
                # ອັບເດດສະຖານທີ່ແລະ division
                asset_obj.asset_location_id = new_location
                asset_obj.division = new_division
                
                print(f"🔧 Before save - asset location: {asset_obj.asset_location_id}")
                print(f"🔧 Before save - asset division: {asset_obj.division}")
                
                # ບັງຄັບບັນທຶກດ້ວຍ update_fields
                fields_to_update = ['asset_location_id', 'division']
                asset_obj.save(update_fields=fields_to_update)
                
                # ກວດສອບວ່າອັບເດດແລ້ວຈິງບໍ
                asset_obj.refresh_from_db()
                
                print(f"✅ Asset location updated from {old_location} to {asset_obj.asset_location_id}")
                print(f"✅ Asset division updated from {old_division} to {asset_obj.division}")
                logger.info(f"Asset {asset_obj.asset_list_id} moved from {old_location} to {asset_obj.asset_location_id}")
                logger.info(f"Asset {asset_obj.asset_list_id} division changed from {old_division} to {asset_obj.division}")
                
            except FA_Asset_Lists.DoesNotExist:
                error_msg = f"Asset not found: {transfer_log.asset_list_id}"
                logger.error(error_msg)
                raise ValueError(error_msg)
                
            except Exception as e:
                error_msg = f"Failed to update asset location/division: {e}"
                logger.error(error_msg)
                print(f"❌ ERROR: {error_msg}")
                import traceback
                print(traceback.format_exc())
                raise

    # method ສຳລັບກວດສອບຫຼັງການອັບເດດ
    def create(self, request, *args, **kwargs):
        response = super().create(request, *args, **kwargs)
        
        # ກວດສອບວ່າການອັບເດດສຳເລັດແລ້ວ
        if response.status_code == 201:
            transfer_log_id = response.data.get('transfer_id')
            if transfer_log_id:
                try:
                    transfer_log = FA_Transfer_Logs.objects.get(pk=transfer_log_id)
                    asset = transfer_log.asset_list_id
                    
                    print(f"🔍 Final verification - Asset {asset.asset_list_id} location: {asset.asset_location_id}")
                    print(f"🔍 Final verification - Asset {asset.asset_list_id} division: {asset.division}")
                    
                except Exception as e:
                    print(f"⚠️ Verification failed: {e}")
        
        return response

# class FATransferLogsViewSet(viewsets.ModelViewSet):
#     queryset = FA_Transfer_Logs.objects.all()
#     serializer_class = FATransferLogsSerializer
#     permission_classes = [IsAuthenticated]

#     def get_queryset(self):
#         queryset = FA_Transfer_Logs.objects.all().order_by('transfer_id')
#         asset_list_id = self.request.query_params.get('asset_list_id')
#         if asset_list_id:
#             queryset = queryset.filter(asset_list_id=asset_list_id)
#         return queryset

#     def perform_create(self, serializer):
#         from django.db import transaction
#         import logging
        
#         logger = logging.getLogger(__name__)
#         user = self.request.user
        
#         with transaction.atomic():
#             # ບັນທຶກ transfer log
#             transfer_log = serializer.save(
#                 Maker_Id=user,
#                 Maker_DT_Stamp=timezone.now()
#             )
            
#             logger.info(f"Transfer log created: {transfer_log.transfer_id}")
            
#             try:
#                 # Debug: ກວດສອບ transfer_log ກ່ອນ
#                 print(f"🔍 Transfer log asset_list_id: {transfer_log.asset_list_id}")
#                 print(f"🔍 Transfer log asset_list_id type: {type(transfer_log.asset_list_id)}")
#                 print(f"🔍 Transfer log asset_list_id pk: {transfer_log.asset_list_id.pk if transfer_log.asset_list_id else 'None'}")
                
#                 # ກວດສອບວ່າ asset_list_id ບໍ່ເປັນ None
#                 if not transfer_log.asset_list_id:
#                     raise ValueError("Asset list ID is None")
                
#                 # ໃຊ້ asset object ທີ່ມີຢູ່ແລ້ວ
#                 asset_obj = transfer_log.asset_list_id
                
#                 # ຫຼື ລອງ get ແບບລະມັດລະວັງ
#                 try:
#                     asset_obj_fresh = FA_Asset_Lists.objects.get(asset_list_id=asset_obj.asset_list_id)
#                     print(f"✅ Successfully got fresh asset object: {asset_obj_fresh.asset_list_id}")
#                     asset_obj = asset_obj_fresh
#                 except FA_Asset_Lists.DoesNotExist:
#                     print(f"⚠️ Could not get fresh asset, using existing: {asset_obj.asset_list_id}")
#                     # ໃຊ້ asset object ທີ່ມີຢູ່ແລ້ວ
                
#                 old_location = asset_obj.asset_location_id
#                 new_location = transfer_log.to_location_id
                
#                 print(f"🔥 Asset ID: {asset_obj.asset_list_id}")
#                 print(f"🔥 Old location: {old_location}")
#                 print(f"🔥 New location: {new_location}")
#                 print(f"🔥 New location type: {type(new_location)}")
                
               
#                 asset_obj.asset_location_id = new_location
                
                
#                 asset_obj.save(update_fields=['asset_location_id'])
                
                
#                 asset_obj.refresh_from_db()
                
#                 print(f"✅ Asset location updated from {old_location} to {asset_obj.asset_location_id}")
#                 logger.info(f"Asset {asset_obj.asset_list_id} moved from {old_location} to {asset_obj.asset_location_id}")
                
#             except FA_Asset_Lists.DoesNotExist:
#                 error_msg = f"Asset not found: {transfer_log.asset_list_id}"
#                 logger.error(error_msg)
#                 raise ValueError(error_msg)
                
#             except Exception as e:
#                 error_msg = f"Failed to update asset location: {e}"
#                 logger.error(error_msg)
#                 print(f"❌ ERROR: {error_msg}")
#                 import traceback
#                 print(traceback.format_exc())
#                 raise

    
    def create(self, request, *args, **kwargs):
        response = super().create(request, *args, **kwargs)
        
        # ກວດສອບວ່າການອັບເດດສຳເລັດແລ້ວ
        if response.status_code == 201:
            transfer_log_id = response.data.get('transfer_id')
            if transfer_log_id:
                try:
                    
                    from .models import FA_Transfer_Logs  
                    transfer_log = FA_Transfer_Logs.objects.get(pk=transfer_log_id)
                    asset = transfer_log.asset_list_id
                    
                    print(f"🔍 Final verification - Asset {asset.asset_list_id} location: {asset.asset_location_id}")
                    
                except Exception as e:
                    print(f"⚠️ Verification failed: {e}")
        
        return response
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O'"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})
    
class FAAssetPhotosViewSet(viewsets.ModelViewSet):
    serializer_class = FAAssetPhotosSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Asset_Photos.objects.all().order_by('ap_id')
        asset_list_id = self.request.query_params.get('asset_list_id')
        if asset_list_id:
            queryset = queryset.filter(asset_list_id=asset_list_id)
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )

class FAMaintenanceLogsViewSet(viewsets.ModelViewSet):
    serializer_class = FAMaintenanceLogsSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Maintenance_Logs.objects.all().order_by('maintenance_id')
        asset_list_id = self.request.query_params.get('asset_list_id')
        if asset_list_id:
            queryset = queryset.filter(asset_list_id=asset_list_id)
        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O'"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})

# class FAAccountingMethodViewSet(viewsets.ModelViewSet):
#     serializer_class = FAAccountingMethodSerializer
#     permission_classes = [IsAuthenticated]

#     def get_queryset(self):
#         queryset = FA_Accounting_Method.objects.all().order_by('mapping_id')
#         acc_type = self.request.query_params.get('acc_type')
#         if acc_type:
#             queryset = queryset.filter(acc_type=acc_type)
#         return queryset
    
#     def perform_create(self, serializer):
#         user = self.request.user
#         serializer.save(
#             Maker_Id=user,
#             Maker_DT_Stamp=timezone.now()
#         )

#     def perform_update(self, serializer):
#         user = self.request.user
#         serializer.save(
#             Checker_Id=user,
#             Checker_DT_Stamp=timezone.now()
#         )
from django.http import Http404
from rest_framework import status
from rest_framework.response import Response
from django.db import IntegrityError, transaction
from django.utils import timezone
from SAMCSYS.models import MTTB_GLSub, MTTB_GLMaster  # ເພີ່ມ MTTB_GLMaster

class FAAccountingMethodViewSet(viewsets.ModelViewSet):
    serializer_class = FAAccountingMethodSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Accounting_Method.objects.all().order_by('mapping_id')
        acc_type = self.request.query_params.get('acc_type')
        if acc_type:
            queryset = queryset.filter(acc_type=acc_type)
        return queryset
    
    def create_glsub_record(self, account_code, description):
        """ສ້າງ record ໃໝ່ໃນ MTTB_GLSub"""
        try:
           
            if '.' in account_code:
                gl_code = account_code.split('.')[0]
            else:
                gl_code = account_code
            
           
            try:
                gl_master = MTTB_GLMaster.objects.get(gl_code=gl_code)
                gl_code_id = gl_master.glid  
            except MTTB_GLMaster.DoesNotExist:
                raise ValueError(f"ບໍ່ພົບ gl_code '{gl_code}' ໃນ MTTB_GLMaster")
            
            
            glsub_record = MTTB_GLSub.objects.create(
                glsub_code=account_code,
                glsub_Desc_la=description,
                gl_code_id=gl_code_id,
                Maker_Id=self.request.user,
                Maker_DT_Stamp=timezone.now(),
                Record_Status='O',
                Auth_Status='A'   
               
            )
            
            return glsub_record
            
        except Exception as e:
            raise Exception(f"ຜິດພາດໃນການສ້າງ GLSub: {str(e)}")
    
    def create(self, request, *args, **kwargs):
        """Override create method ເພື່ອກວດສອບແລະສ້າງ GLSub records"""
        
        
        debit_account_id = request.data.get('debit_account_id')
        credit_account_id = request.data.get('credit_account_id')
        description = request.data.get('description', '')  # ສຳລັບ glsub_Desc_la
        
        
        if not debit_account_id or not credit_account_id:
            return Response(
                {'error': 'debit_account_id ແລະ credit_account_id ຈຳເປັນຕ້ອງມີ'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
           
            with transaction.atomic():
                
                
                debit_exists = MTTB_GLSub.objects.filter(glsub_code=debit_account_id).exists()
                credit_exists = MTTB_GLSub.objects.filter(glsub_code=credit_account_id).exists()
                
                if debit_exists:
                    return Response(
                        {
                            'error': f'debit_account_id "{debit_account_id}" ມີຢູ່ໃນລະບົບແລ້ວ',
                            'code': 'DUPLICATE_DEBIT_ACCOUNT'
                        }, 
                        status=status.HTTP_501_NOT_IMPLEMENTED
                    )
                
                if credit_exists:
                    return Response(
                        {
                            'error': f'credit_account_id "{credit_account_id}" ມີຢູ່ໃນລະບົບແລ້ວ',
                            'code': 'DUPLICATE_CREDIT_ACCOUNT'
                        }, 
                        status=status.HTTP_501_NOT_IMPLEMENTED
                    )
                
                
                try:
                    
                    debit_glsub = self.create_glsub_record(
                        debit_account_id, 
                        f" {description}"
                    )
                    
                    
                    credit_glsub = self.create_glsub_record(
                        credit_account_id, 
                        f" {description}"
                    )
                    
                    print(f"✅ ສ້າງ GLSub records ສຳເລັດ: {debit_glsub.glsub_code}, {credit_glsub.glsub_code}")
                    
                except Exception as e:
                    return Response(
                        {'error': f'ຜິດພາດໃນການສ້າງ GLSub records: {str(e)}'}, 
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR
                    )
                
                
                response = super().create(request, *args, **kwargs)
                
                
                if response.status_code == 201:
                    response.data['glsub_created'] = {
                        'debit_account': debit_account_id,
                        'credit_account': credit_account_id,
                        'message': 'GLSub records ຖືກສ້າງສຳເລັດ'
                    }
                
                return response
                
        except Exception as e:
            return Response(
                {'error': f'ຜິດພາດໃນການດຳເນີນການ: {str(e)}'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    def perform_create(self, serializer):
        """ບັນທຶກຂໍ້ມູນພ້ອມ Maker info"""
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O'"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})
    
class FAAssetListDepreciationInMonthViewSet(viewsets.ModelViewSet):
    serializer_class = FAAssetListDepreciationInMonthSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Asset_List_Depreciation_InMonth.objects.all()

        # แยกปีและเดือนจาก string "MM-YYYY"
        queryset = queryset.annotate(
            dpca_year=Substr('dpca_month', 4, 4),     # 'YYYY'
            dpca_month_num=Substr('dpca_month', 1, 2) # 'MM'
        ).order_by('-dpca_year', '-dpca_month_num')   # เรียงจากล่าสุดไปเก่าสุด

        dpca_status = self.request.query_params.get('dpca_status')
        if dpca_status:
            queryset = queryset.filter(dpca_status=dpca_status)

        return queryset
    
    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O'"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})
    
#----------------end of Asset-----------------

# Function Get User Login Session

# ---------------------------------------------------------------------------------------------------


from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from rest_framework_simplejwt.token_blacklist.models import OutstandingToken, BlacklistedToken
from django.utils import timezone
from django.db import transaction
from .models import MTTB_USER_ACCESS_LOG, MTTB_Users
from datetime import datetime

# @api_view(["POST"])
# @permission_classes([IsAuthenticated])
# def force_logout_user(request):
#     """
#     Force logout a user by their user_id.
#     Only admins should be able to use this endpoint.
    
#     POST /api/force-logout/
#     Body: { "user_id": "<user_id_to_logout>" }
#     """
#     # Optional: Check if the requesting user has admin privileges
#     # if not request.user.Role_ID or request.user.Role_ID.role_name != 'Admin':
#     #     return Response(
#     #         {"error": "Permission denied. Admin access required."},
#     #         status=status.HTTP_403_FORBIDDEN
#     #     )
    
#     target_user_id = request.data.get("user_id")
#     if not target_user_id:
#         return Response(
#             {"error": "user_id is required"},
#             status=status.HTTP_400_BAD_REQUEST
#         )
    
#     # Check if the target user exists
#     try:
#         target_user = MTTB_Users.objects.get(user_id=target_user_id)
#     except MTTB_Users.DoesNotExist:
#         return Response(
#             {"error": f"User with id {target_user_id} not found"},
#             status=status.HTTP_404_NOT_FOUND
#         )
    
#     # Prevent users from force logging out themselves
#     if request.user.user_id == target_user_id:
#         return Response(
#             {"error": "Cannot force logout yourself. Use normal logout instead."},
#             status=status.HTTP_400_BAD_REQUEST
#         )
    
#     with transaction.atomic():
#         # 1. Find all active sessions for this user
#         active_sessions = MTTB_USER_ACCESS_LOG.objects.filter(
#             user_id=target_user,
#             logout_datetime__isnull=True,
#             login_status='S'  # Only successful logins
#         )
        
#         session_count = active_sessions.count()
        
#         # 2. Blacklist all outstanding tokens for this user
#         blacklisted_count = 0
#         try:
#             # Get all outstanding tokens for this user
#             outstanding_tokens = OutstandingToken.objects.filter(
#                 user__user_id=target_user_id
#             )
            
#             for token in outstanding_tokens:
#                 # Check if already blacklisted
#                 if not BlacklistedToken.objects.filter(token=token).exists():
#                     BlacklistedToken.objects.create(token=token)
#                     blacklisted_count += 1
                    
#         except Exception as e:
#             # If blacklisting fails, still continue with logging out sessions
#             print(f"Error blacklisting tokens: {str(e)}")
        
#         # 3. Update all active sessions to mark them as force logged out
#         current_time = timezone.now()
#         active_sessions.update(
#             logout_datetime=current_time,
#             logout_type='F',  # F = Force logout
#             remarks=f'Force logged out by {request.user.user_id}'
#         )
        
#         # 4. Optional: Create a new log entry for the force logout action
#         MTTB_USER_ACCESS_LOG.objects.create(
#             user_id=request.user,
#             session_id=None,
#             ip_address=get_client_ip(request),
#             user_agent=request.META.get('HTTP_USER_AGENT'),
#             login_status='A',  # A = Admin action
#             remarks=f'Force logged out user {target_user_id}'
#         )
    
#     return Response({
#         "message": f"Successfully force logged out user {target_user_id}",
#         "sessions_terminated": session_count,
#         "tokens_blacklisted": blacklisted_count
#     }, status=status.HTTP_200_OK)

# views.py - Add these views to your existing views

from rest_framework.decorators import api_view, permission_classes
from django.db.models import OuterRef, Subquery, Max
from datetime import timedelta
from rest_framework.permissions import IsAuthenticated, BasePermission
from rest_framework.response import Response
from rest_framework import status, viewsets
from rest_framework.decorators import action
from django.utils import timezone
from django.db import transaction
from django.db.models import Q
from .models import MTTB_USER_ACCESS_LOG, MTTB_Users, MTTB_REVOKED_SESSIONS
from .serializers import UserAccessLogSerializer
from SAMCSYS.authentication import get_jti_from_request
import logging

logger = logging.getLogger(__name__)


# Helper function
def get_client_ip(request):
    """Extract client IP from request"""
    xff = request.META.get('HTTP_X_FORWARDED_FOR')
    if xff:
        return xff.split(',')[0].strip()
    return request.META.get('REMOTE_ADDR', '')


# Custom permission class for admin-only endpoints
class IsAdminUser(BasePermission):
    """
    Custom permission to only allow admin users.
    """
    message = "Only administrators can perform this action."
    
    def has_permission(self, request, view):
        if not request.user or not request.user.is_authenticated:
            return False
        
        print(f"User: {request.user}")
        print(f"Has role attr: {hasattr(request.user, 'role')}")
        if hasattr(request.user, 'role'):
            print(f"Role: {request.user.role}")
            print(f"Role ID: {getattr(request.user.role, 'role_id', 'NOT_FOUND')}")
        
        # Your permission logic here...
        
        return False
@api_view(["GET"])
@permission_classes([IsAuthenticated])
def session_check(request):
    # Optional: verify against revoked session table
    jti = get_jti_from_request(request)
    if MTTB_REVOKED_SESSIONS.objects.filter(jti=jti).exists():
        return Response({"error": "Session revoked"}, status=status.HTTP_401_UNAUTHORIZED)

    return Response({"success": True}, status=status.HTTP_200_OK)


# @api_view(["POST"])
# @permission_classes([IsAuthenticated])
# def force_logout_user(request):
#     """
#     Force logout a user by their user_id.
#     Revokes all their active sessions and tokens.
    
#     POST /api/force-logout/
#     Body: { "user_id": "<user_id_to_logout>" }
#     """
#     target_user_id = request.data.get("user_id")
    
#     # Validation
#     if not target_user_id:
#         return Response(
#             {"error": "user_id is required"},
#             status=status.HTTP_400_BAD_REQUEST
#         )
    
#     # Check if the target user exists
#     try:
#         target_user = MTTB_Users.objects.get(user_id=target_user_id)
#     except MTTB_Users.DoesNotExist:
#         return Response(
#             {"error": f"User with id {target_user_id} not found"},
#             status=status.HTTP_404_NOT_FOUND
#         )
    
#     # Prevent users from force logging out themselves
#     if request.user.user_id == target_user_id:
#         return Response(
#             {"error": "Cannot force logout yourself. Use normal logout instead."},
#             status=status.HTTP_400_BAD_REQUEST
#         )
    
#     with transaction.atomic():
#         # Find all active sessions for this user
#         active_sessions = MTTB_USER_ACCESS_LOG.objects.filter(
#             user_id=target_user,
#             logout_datetime__isnull=True,
#             login_status='S'  # Only successful logins
#         )
        
#         session_count = active_sessions.count()
#         revoked_count = 0
        
#         # Revoke all active sessions
#         for session in active_sessions:
#             if session.session_id:  # session_id contains the JTI
#                 try:
#                     # Create revoked session entry
#                     MTTB_REVOKED_SESSIONS.objects.get_or_create(
#                         jti=session.session_id,
#                         defaults={
#                             'user_id': target_user,
#                             'revoked_by': request.user,
#                             'reason': f'Force logged out by {request.user.user_name}',
#                             'ip_address': get_client_ip(request)
#                         }
#                     )
#                     revoked_count += 1
#                 except Exception as e:
#                     logger.error(f"Error revoking session {session.session_id}: {str(e)}")
        
#         # Update all active sessions to mark them as force logged out
#         current_time = timezone.now()
#         active_sessions.update(
#             logout_datetime=current_time,
#             logout_type='F',  # F = Force logout
#             remarks=f'Force logged out by {request.user.user_name} ({request.user.user_id})'
#         )
        
#         # Log the admin action
#         MTTB_USER_ACCESS_LOG.objects.create(
#             user_id=request.user,
#             session_id=get_jti_from_request(request),
#             ip_address=get_client_ip(request),
#             user_agent=request.META.get('HTTP_USER_AGENT', '')[:255],
#             login_status='A',  # A = Admin action
#             remarks=f'Force logged out user {target_user.user_name} ({target_user_id})'
#         )
    
#     logger.info(f"Admin {request.user.user_id} force logged out user {target_user_id}")
    
#     return Response({
#         "success": True,
#         "message": f"Successfully force logged out user {target_user_id}",
#         "details": {
#             "user_id": target_user_id,
#             "user_name": target_user.user_name,
#             "sessions_terminated": session_count,
#             "tokens_revoked": revoked_count
#         }
#     }, status=status.HTTP_200_OK)

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def force_logout_user(request, user_id=None):
    allowed_roles = ['SYS', 'SYA']
    user_role_id = getattr(getattr(request.user, 'Role_ID', None), 'role_id', None)

    if user_role_id not in allowed_roles:
        return Response({
            "success": False,
            "message": "You do not have permission to perform this action."
        }, status=status.HTTP_403_FORBIDDEN)

    target_user_id = user_id or request.data.get("user_id")
    if not target_user_id:
        return Response({"error": "user_id is required"}, status=status.HTTP_400_BAD_REQUEST)

    if request.user.user_id == target_user_id:
        return Response({"error": "Cannot force logout yourself. Please use normal logout."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        target_user = MTTB_Users.objects.get(user_id=target_user_id)
    except MTTB_Users.DoesNotExist:
        return Response({"error": f"User with id {target_user_id} not found"}, status=status.HTTP_404_NOT_FOUND)

    with transaction.atomic():
        latest_session = MTTB_USER_ACCESS_LOG.objects.filter(
            user_id=target_user,
            logout_datetime__isnull=True,
            login_status='S'
        ).order_by('-login_datetime').first()

        if not latest_session:
            return Response({
                "success": False,
                "message": "No active session found for this user."
            }, status=status.HTTP_404_NOT_FOUND)

        same_session_logs = MTTB_USER_ACCESS_LOG.objects.filter(
            session_id=latest_session.session_id,
            logout_datetime__isnull=True,
            login_status='S'
        )

        forced_users = []
        revoked_count = 0
        current_time = timezone.now()

        for log in same_session_logs:
            uid = log.user_id.user_id if log.user_id else "??"
            forced_users.append(f"({uid})")

            if log.session_id:
                try:
                    MTTB_REVOKED_SESSIONS.objects.get_or_create(
                        jti=log.session_id,
                        defaults={
                            'user_id': log.user_id,
                            'revoked_by': request.user,
                            'reason': f'Force logged out by {request.user.user_name}',
                            'ip_address': get_client_ip(request)
                        }
                    )
                    revoked_count += 1
                except Exception as e:
                    logger.error(f"Error revoking session {log.session_id}: {str(e)}")

            # update remark of user who  force logout
            log.logout_datetime = current_time
            log.logout_type = 'F'
            log.remarks = f"Force logged out by {request.user.user_name} ({request.user.user_id})"
            log.save()

        # update remark in log latest admin (who force logout)
        admin_log = MTTB_USER_ACCESS_LOG.objects.filter(
            user_id=request.user,
            logout_datetime__isnull=True,
            login_status='S'
        ).order_by('-login_datetime').first()

        if admin_log:
            existing_remark = admin_log.remarks or ''

            prefix_all = "Force logout all user"
            prefix_forced = "Force logged out user "

            part_all = ""
            part_forced = ""

            # แยกข้อความ existing_remark
            if existing_remark.startswith(prefix_all):
                if ',' in existing_remark:
                    parts = existing_remark.split(',', 1)
                    part_all = parts[0].strip()
                    part_forced = parts[1].strip()
                else:
                    part_all = existing_remark.strip()
                    part_forced = ""
            else:
                part_forced = existing_remark.strip()

            # แยก user เก่าใน part_forced
            old_users = []
            if part_forced.startswith(prefix_forced):
                old_users_str = part_forced[len(prefix_forced):].strip()
                old_users = [u.strip() for u in old_users_str.split(',') if u.strip()]
            elif part_forced:
                # in case hvae old message is keep it
                pass

            # list user old + new
            combined_users_set = set(old_users)
            combined_users_set.update(forced_users)
            combined_users = sorted(combined_users_set)

            combined_forced_part = prefix_forced + ", ".join(combined_users)

            if part_all:
                combined_remark = f"{part_all}, {combined_forced_part}"
            else:
                combined_remark = combined_forced_part

            # update when have change
            if combined_remark != existing_remark:
                admin_log.remarks = combined_remark
                admin_log.save()
        else:
            logger.warning("No active admin log found to update remarks for force logout action.")

    logger.info(f"Admin {request.user.user_id} force logged out users: {', '.join(forced_users)}")

    return Response({
        "success": True,
        "message": f"Successfully force logged out session {latest_session.log_id}",
        "log_ids": [log.log_id for log in same_session_logs],
        "forced_users": forced_users,
        "admin_remark": admin_log.remarks if admin_log else None,
        "tokens_revoked": revoked_count
    }, status=status.HTTP_200_OK)

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def force_logout_user_test(request, user_id):
    """
    Force logout a user by their user_id from the URL.
    Revokes all their active sessions and tokens.

    POST /api/force-logout/<user_id>/
    """
    # Check if the target user exists
    try:
        target_user = MTTB_Users.objects.get(user_id=user_id)
    except MTTB_Users.DoesNotExist:
        return Response(
            {"error": f"User with id {user_id} not found"},
            status=status.HTTP_404_NOT_FOUND
        )

    # Prevent users from force logging out themselves
    if request.user.user_id == user_id:
        return Response(
            {"error": "Cannot force logout yourself. Use normal logout instead."},
            status=status.HTTP_400_BAD_REQUEST
        )

    with transaction.atomic():
        # Find all active sessions for this user
        active_sessions = MTTB_USER_ACCESS_LOG.objects.filter(
            user_id=target_user,
            logout_datetime__isnull=True,
            login_status='S'  # Only successful logins
        )

        session_count = active_sessions.count()
        revoked_count = 0

        # Revoke all active sessions
        for session in active_sessions:
            if session.session_id:  # session_id contains the JTI
                try:
                    MTTB_REVOKED_SESSIONS.objects.get_or_create(
                        jti=session.session_id,
                        defaults={
                            'user_id': target_user,
                            'revoked_by': request.user,
                            'reason': f'Force logged out by {request.user.user_name}',
                            'ip_address': get_client_ip(request)
                        }
                    )
                    revoked_count += 1
                except Exception as e:
                    logger.error(f"Error revoking session {session.session_id}: {str(e)}")

        # Update all active sessions to mark them as force logged out
        current_time = timezone.now()
        active_sessions.update(
            logout_datetime=current_time,
            logout_type='F',
            remarks=f'Force logged out by {request.user.user_name} ({request.user.user_id})'
        )

        # Log the admin action
        MTTB_USER_ACCESS_LOG.objects.create(
            user_id=request.user,
            session_id=get_jti_from_request(request),
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')[:255],
            login_status='A',
            remarks=f'Force logged out user {target_user.user_name} ({user_id})'
        )

    logger.info(f"Admin {request.user.user_id} force logged out user {user_id}")

    return Response({
        "success": True,
        "message": f"Successfully force logged out user {user_id}",
        "details": {
            "user_id": user_id,
            "user_name": target_user.user_name,
            "sessions_terminated": session_count,
            "tokens_revoked": revoked_count
        }
    }, status=status.HTTP_200_OK)

@api_view(["GET"])
@permission_classes([IsAuthenticated])
def get_active_sessions(request):
    user = request.user

    allowed_roles = ['SYS', 'SYA']
    user_role_id = None
    if hasattr(user, 'Role_ID') and user.Role_ID:
        user_role_id = getattr(user.Role_ID, 'role_id', None)

    if user_role_id not in allowed_roles:
        return Response({
            "success": False,
            "message": "You do not have permission to access this API."
        }, status=status.HTTP_403_FORBIDDEN)

    # user info add on response
    own_user_info = {
        "own_user_id": getattr(user, 'user_id', None),
        "own_user_name": getattr(user, 'user_name', None),
        "own_role_id": user_role_id,
    }

    SESSION_TIMEOUT_MINUTES = 30
    time_limit = timezone.now() - timedelta(minutes=SESSION_TIMEOUT_MINUTES)

    latest_log_id_subquery = MTTB_USER_ACCESS_LOG.objects.filter(
        user_id=OuterRef('user_id')
    ).order_by('-login_datetime').values('log_id')[:1]

    latest_logs = MTTB_USER_ACCESS_LOG.objects.filter(
        log_id__in=Subquery(latest_log_id_subquery),
        login_status='S',
        logout_datetime__isnull=True,
        login_datetime__gte=time_limit
    ).select_related('user_id').order_by('-login_datetime')

    active_user_ids = list(
        latest_logs.values_list('user_id__user_id', flat=True).distinct()
    )

    sessions_data = []
    for session in latest_logs:
        session_info = {
            'log_id': session.log_id,
            'user_id': session.user_id.user_id if session.user_id else None,
            'user_name': session.user_id.user_name if session.user_id else None,
            'login_datetime': session.login_datetime,
            'session_duration': str(timezone.now() - session.login_datetime) if session.login_datetime else None,
            'ip_address': session.ip_address,
        }
        sessions_data.append(session_info)

    return Response({
        "success": True,
        **own_user_info,  # show user_id / user_name / role_id is own
        "active_sessions": sessions_data,
        "total_count": len(sessions_data),
        "total_active_users_all": len(active_user_ids),
        "active_user_ids": active_user_ids,
        "current_time": timezone.now()
    }, status=status.HTTP_200_OK)



# @api_view(["GET"])
# @permission_classes([IsAuthenticated])
# def get_active_sessions(request):
#     """
#     Get all active sessions (users currently logged in).
#     Regular users can only see their own sessions.
#     Admins can see all sessions.
    
#     GET /api/active-sessions/
#     Optional query params:
#     - user_id: Filter by specific user (admin only)
#     - include_details: Include detailed session info
#     """
#     # Check if user is admin
#     is_admin = IsAdminUser().has_permission(request, None)
    
#     # Base query for active sessions
#     query = MTTB_USER_ACCESS_LOG.objects.filter(
#         logout_datetime__isnull=True,
#         login_status='S'
#     ).select_related('user_id')
    
#     # Non-admins can only see their own sessions
#     if not is_admin:
#         query = query.filter(user_id=request.user)
#     else:
#         # Admins can filter by user_id if provided
#         filter_user_id = request.query_params.get('user_id')
#         if filter_user_id:
#             query = query.filter(user_id__user_id=filter_user_id)
    
#     # Order by login time (most recent first)
#     query = query.order_by('-login_datetime')
    
#     # Prepare response data
#     sessions_data = []
#     for session in query:
#         session_info = {
#             'log_id': session.log_id,
#             'user_id': session.user_id.user_id if session.user_id else None,
#             'user_name': session.user_id.user_name if session.user_id else None,
#             'login_datetime': session.login_datetime,
#             'session_duration': str(timezone.now() - session.login_datetime) if session.login_datetime else None,
#             'ip_address': session.ip_address,
#         }
        
#         # Include additional details if requested
#         if request.query_params.get('include_details') == 'true':
#             session_info.update({
#                 'user_agent': session.user_agent,
#                 'session_id': session.session_id[:10] + '...' if session.session_id else None,  # Partial JTI for security
#                 'user_email': session.user_id.user_email if session.user_id else None,
#                 'user_status': session.user_id.User_Status if session.user_id else None,
#             })
        
#         sessions_data.append(session_info)
    
#     return Response({
#         "success": True,
#         "active_sessions": sessions_data,
#         "total_count": len(sessions_data),
#         "is_admin_view": is_admin,
#         "current_time": timezone.now()
#     }, status=status.HTTP_200_OK)

@api_view(["POST"])
@permission_classes([IsAuthenticated])
def force_logout_all_users(request):
    allowed_roles = ['SYS', 'SYA']
    user = request.user
    user_role_id = getattr(getattr(user, 'Role_ID', None), 'role_id', None)

    if user_role_id not in allowed_roles:
        return Response({
            "success": False,
            "message": "You do not have permission to perform this action."
        }, status=status.HTTP_403_FORBIDDEN)

    with transaction.atomic():
        now = timezone.now()

        # log latest of admin
        admin_log = MTTB_USER_ACCESS_LOG.objects.filter(
            user_id=user,
            logout_datetime__isnull=True,
            login_status='S'
        ).order_by('-login_datetime').first()

        # log lest of other user (ยกเว้น admin)
        latest_logs = {}
        sessions = MTTB_USER_ACCESS_LOG.objects.filter(
            logout_datetime__isnull=True,
            login_status='S'
        ).exclude(user_id=user).order_by('user_id', '-login_datetime')

        for log in sessions:
            if log.user_id_id not in latest_logs:
                latest_logs[log.user_id_id] = log

        forced_users = []

        for log in latest_logs.values():
            # Revoke token
            if log.session_id:
                MTTB_REVOKED_SESSIONS.objects.get_or_create(
                    jti=log.session_id,
                    defaults={
                        'user_id': log.user_id,
                        'revoked_by': user,
                        'reason': f'Force logged out by {user.user_name}',
                        'ip_address': get_client_ip(request)
                    }
                )

            # update logout
            log.logout_datetime = now
            log.logout_type = 'F'
            log.remarks = (log.remarks or '') + f' Force logged out by {user.user_name} ({user.user_id})'
            log.save()

            forced_users.append(f"{log.user_id.user_name} ({log.user_id.user_id})")

        # update remark of admin session
        if admin_log:
            old_remark = admin_log.remarks or ''
            if 'Force logout all user' not in old_remark:
                if old_remark.strip():
                    admin_log.remarks = f'Force logout all user, {old_remark}'
                else:
                    admin_log.remarks = 'Force logout all user'
                admin_log.save()

    return Response({
        "success": True,
        "message": "All users have been forcefully logged out.",
        "forced_user_count": len(forced_users),
        "forced_users": forced_users
    }, status=status.HTTP_200_OK)


# @api_view(["POST"])
# @permission_classes([IsAuthenticated])
# def force_logout_all_users(request):
#     """
#     Force logout all users except the requesting admin.
#     Requires explicit confirmation.
    
#     POST /api/force-logout-all/
#     Body: { "confirm": true, "reason": "optional reason" }
#     """
#     # Require explicit confirmation
#     if not request.data.get("confirm"):
#         return Response(
#             {"error": "Confirmation required. Set 'confirm': true in request body."},
#             status=status.HTTP_400_BAD_REQUEST
#         )
    
#     reason = request.data.get("reason", "Mass force logout by administrator")
    
#     # Get current user's JTI to exclude it
#     current_jti = get_jti_from_request(request)
    
#     with transaction.atomic():
#         # Get all active sessions except current user's
#         active_sessions = MTTB_USER_ACCESS_LOG.objects.filter(
#             logout_datetime__isnull=True,
#             login_status='S'
#         ).exclude(
#             Q(user_id=request.user) | Q(session_id=current_jti)
#         ).select_related('user_id')
        
#         session_count = active_sessions.count()
#         revoked_count = 0
#         affected_users = set()
        
#         # Revoke all sessions
#         for session in active_sessions:
#             if session.session_id:
#                 try:
#                     MTTB_REVOKED_SESSIONS.objects.get_or_create(
#                         jti=session.session_id,
#                         defaults={
#                             'user_id': session.user_id,
#                             'revoked_by': request.user,
#                             'reason': reason,
#                             'ip_address': get_client_ip(request)
#                         }
#                     )
#                     revoked_count += 1
#                     if session.user_id:
#                         affected_users.add(session.user_id.user_name)
#                 except Exception as e:
#                     logger.error(f"Error revoking session in mass logout: {str(e)}")
        
#         # Mark all sessions as logged out
#         current_time = timezone.now()
#         active_sessions.update(
#             logout_datetime=current_time,
#             logout_type='F',
#             remarks=f'{reason} by {request.user.user_name}'
#         )
        
#         # Log the mass logout action
#         MTTB_USER_ACCESS_LOG.objects.create(
#             user_id=request.user,
#             session_id=current_jti,
#             ip_address=get_client_ip(request),
#             user_agent=request.META.get('HTTP_USER_AGENT', '')[:255],
#             login_status='A',
#             remarks=f'Performed mass force logout: {reason}'
#         )
    
#     logger.warning(f"Admin {request.user.user_id} performed mass force logout. Affected {len(affected_users)} users.")
    
#     return Response({
#         "success": True,
#         "message": "Successfully force logged out all users",
#         "details": {
#             "sessions_terminated": session_count,
#             "tokens_revoked": revoked_count,
#             "users_affected": len(affected_users),
#             "reason": reason
#         }
#     }, status=status.HTTP_200_OK)


@api_view(["GET"])
@permission_classes([IsAuthenticated])
def verify_token(request):
    """
    Simple endpoint to verify if a token is still valid.
    Used by frontend to check authentication status.
    
    GET /api/verify-token/
    """
    return Response({
        "valid": True,
        "user_id": request.user.user_id,
        "user_name": request.user.user_name,
        "jti": get_jti_from_request(request),
        "timestamp": timezone.now()
    }, status=status.HTTP_200_OK)


@api_view(["GET"])
@permission_classes([IsAuthenticated, IsAdminUser])
def get_revoked_sessions(request):
    """
    Get list of revoked sessions (admin only).
    Useful for audit purposes.
    
    GET /api/revoked-sessions/
    Query params:
    - user_id: Filter by specific user
    - days: Number of days to look back (default: 7)
    """
    days = int(request.query_params.get('days', 7))
    cutoff_date = timezone.now() - timezone.timedelta(days=days)
    
    query = MTTB_REVOKED_SESSIONS.objects.filter(
        revoked_at__gte=cutoff_date
    ).select_related('user_id', 'revoked_by')
    
    # Filter by user if specified
    user_id_filter = request.query_params.get('user_id')
    if user_id_filter:
        query = query.filter(user_id__user_id=user_id_filter)
    
    revoked_sessions = []
    for session in query.order_by('-revoked_at')[:100]:  # Limit to 100 most recent
        revoked_sessions.append({
            'id': session.id,
            'user_id': session.user_id.user_id if session.user_id else None,
            'user_name': session.user_id.user_name if session.user_id else None,
            'revoked_at': session.revoked_at,
            'revoked_by': session.revoked_by.user_name if session.revoked_by else 'System',
            'reason': session.reason,
            'ip_address': session.ip_address
        })
    
    return Response({
        "success": True,
        "revoked_sessions": revoked_sessions,
        "total_count": len(revoked_sessions),
        "date_range": {
            "from": cutoff_date,
            "to": timezone.now()
        }
    }, status=status.HTTP_200_OK)

from rest_framework import viewsets, status, permissions
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.utils import timezone
from django.db.models import Q
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter
from django.db import transaction
import logging
from .models import MTTB_EOC_MAINTAIN, STTB_EOC_DAILY_LOG, MTTB_Function_Desc
from .serializers import EOCMaintainSerializer

logger = logging.getLogger(__name__)

class EOCMaintainViewSet(viewsets.ModelViewSet):
    """
    ViewSet ສໍາລັບການຈັດການ EOC Maintain
    ປະກອບດ້ວຍ CRUD operations ແລະ custom actions
    """
    queryset = MTTB_EOC_MAINTAIN.objects.all()
    serializer_class = EOCMaintainSerializer
    permission_classes = [IsAuthenticated]
    
    # Filtering and searching
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['eoc_type', 'Record_Status', 'Auth_Status', 'Once_Auth', 'module_id', 'function_id']
    search_fields = ['eoc_type', 'module_id__module_name', 'function_id__description_la']
    ordering_fields = ['eoc_id', 'eoc_seq_no', 'Maker_DT_Stamp', 'Checker_DT_Stamp']
    ordering = ['eoc_seq_no', 'eoc_id']  # Changed to order by sequence first

    def get_queryset(self):
        """Custom queryset with optimized joins"""
        return MTTB_EOC_MAINTAIN.objects.select_related(
            'module_id', 'function_id', 'Maker_Id', 'Checker_Id'
        ).all()

    def perform_create(self, serializer):
        """ກໍານົດຄ່າເມື່ອສ້າງ record ໃໝ່"""
        user = self.request.user
        user_id = getattr(user, 'user_id', None)
        
        serializer.save(
            Maker_Id_id=user_id,
            Maker_DT_Stamp=timezone.now(),
            Record_Status='C',  # Default to closed
            Auth_Status='U',  # Default to unauthorized
            Once_Auth='N'     # Default to not authorized once
        )

    def perform_update(self, serializer):
        """ກໍານົດຄ່າເມື່ອອັບເດດ record"""
        user = self.request.user
        user_id = getattr(user, 'user_id', None)
        
        serializer.save(
            Checker_Id_id=user_id,
            Checker_DT_Stamp=timezone.now()
        )

    def create(self, request, *args, **kwargs):
        """Override create to add custom response"""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        
        headers = self.get_success_headers(serializer.data)
        return Response({
            'message': 'ສ້າງ EOC Maintain ສໍາເລັດແລ້ວ',
            'data': serializer.data
        }, status=status.HTTP_201_CREATED, headers=headers)

    def update(self, request, *args, **kwargs):
        """Override update to add custom response"""
        partial = kwargs.pop('partial', False)
        instance = self.get_object()
        
        # Check if record can be updated
        if instance.Auth_Status == 'A' and instance.Record_Status == 'C':
            return Response({
                'error': 'ບໍ່ສາມາດແກ້ໄຂ record ທີ່ຖືກອະນຸມັດແລ້ວ'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        serializer = self.get_serializer(instance, data=request.data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        return Response({
            'message': 'ອັບເດດ EOC Maintain ສໍາເລັດແລ້ວ',
            'data': serializer.data
        })

    def destroy(self, request, *args, **kwargs):
        """Override destroy to add validation"""
        instance = self.get_object()
        
        # Check if record can be deleted
        if instance.Auth_Status == 'A':
            return Response({
                'error': 'ບໍ່ສາມາດລຶບ record ທີ່ຖືກອະນຸມັດແລ້ວ'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        self.perform_destroy(instance)
        return Response({
            'message': 'ລຶບ EOC Maintain ສໍາເລັດແລ້ວ'
        }, status=status.HTTP_204_NO_CONTENT)

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """ເປີດ record (Record_Status = 'O') - ເປີດໃຫ້ປະມວນຜົນໃນ EOD"""
        obj = self.get_object()
        
        if obj.Record_Status == 'O':
            return Response({
                'message': 'Record ເປີດຢູ່ແລ້ວ'
            }, status=status.HTTP_200_OK)
        
        if obj.Auth_Status != 'A':
            return Response({
                'error': 'ບໍ່ສາມາດເປີດໄດ້. ສາມາດເປີດໄດ້ເມື່ອ record ຖືກອະນຸມັດແລ້ວເທົ່ານັ້ນ (Auth_Status = "A")'
            }, status=status.HTTP_400_BAD_REQUEST)

        obj.Record_Status = 'O'
        obj.Checker_Id_id = getattr(request.user, 'user_id', None)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        
        serializer = self.get_serializer(obj)
        return Response({
            'message': f'ເປີດຟັງຊັນ {obj.function_id.description_la} ສໍາເລັດແລ້ວ - ຈະຖືກປະມວນຜົນໃນ EOD',
            'data': serializer.data
        })

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """ປິດ record (Record_Status = 'C') - ປິດບໍ່ໃຫ້ປະມວນຜົນໃນ EOD"""
        obj = self.get_object()

        if obj.Record_Status == 'C':
            return Response({
                'message': 'Record ປິດຢູ່ແລ້ວ'
            }, status=status.HTTP_200_OK)

        obj.Record_Status = 'C'
        obj.Checker_Id_id = getattr(request.user, 'user_id', None)
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        
        serializer = self.get_serializer(obj)
        return Response({
            'message': f'ປິດຟັງຊັນ {obj.function_id.description_la} ສໍາເລັດແລ້ວ - ຈະບໍ່ຖືກປະມວນຜົນໃນ EOD',
            'data': serializer.data
        })

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def authorize(self, request, pk=None):
        """ອະນຸມັດ EOC Maintain"""
        eoc_entry = self.get_object()

        if eoc_entry.Auth_Status == 'A':
            return Response({
                'error': 'Record ຖືກອະນຸມັດແລ້ວ'
            }, status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'A', Once_Auth = 'Y', keep current Record_Status
        eoc_entry.Auth_Status = 'A'
        eoc_entry.Once_Auth = 'Y'
        eoc_entry.Checker_Id_id = getattr(request.user, 'user_id', None)
        eoc_entry.Checker_DT_Stamp = timezone.now()
        eoc_entry.save()

        serializer = self.get_serializer(eoc_entry)
        return Response({
            'message': f'ອະນຸມັດຟັງຊັນ {eoc_entry.function_id.description_la} ສໍາເລັດແລ້ວ',
            'data': serializer.data
        })

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def unauthorize(self, request, pk=None):
        """ຍົກເລີກການອະນຸມັດ EOC Maintain"""
        eoc_entry = self.get_object()

        if eoc_entry.Auth_Status == 'U':
            return Response({
                'error': 'Record ຍັງບໍ່ໄດ້ຮັບການອະນຸມັດ'
            }, status=status.HTTP_400_BAD_REQUEST)

        # Set Auth_Status = 'U', Record_Status = 'C' (closed for safety)
        eoc_entry.Auth_Status = 'U'
        eoc_entry.Record_Status = 'C'
        eoc_entry.Checker_Id_id = getattr(request.user, 'user_id', None)
        eoc_entry.Checker_DT_Stamp = timezone.now()
        eoc_entry.save()

        serializer = self.get_serializer(eoc_entry)
        return Response({
            'message': f'ຍົກເລີກການອະນຸມັດຟັງຊັນ {eoc_entry.function_id.description_la} ສໍາເລັດແລ້ວ',
            'data': serializer.data
        })

    @action(detail=False, methods=['get'], permission_classes=[IsAuthenticated])
    def eod_status(self, request):
        """ກວດສອບສະຖານະຟັງຊັນ EOD ທັງໝົດ"""
        eod_functions = MTTB_EOC_MAINTAIN.objects.filter(
            eoc_type='EOD'
        ).select_related('function_id', 'module_id').order_by('eoc_seq_no')

        if not eod_functions.exists():
            return Response({
                'message': 'ບໍ່ພົບຟັງຊັນ EOD',
                'functions': []
            })

        functions_data = []
        total_functions = eod_functions.count()
        authorized_functions = 0
        open_functions = 0
        ready_for_execution = 0

        for func in eod_functions:
            is_authorized = func.Auth_Status == 'A'
            is_open = func.Record_Status == 'O'
            is_ready = is_authorized and is_open

            if is_authorized:
                authorized_functions += 1
            if is_open:
                open_functions += 1
            if is_ready:
                ready_for_execution += 1

            functions_data.append({
                'eoc_id': func.eoc_id,
                'sequence': func.eoc_seq_no,
                'function_name': func.function_id.description_la,
                'function_id': func.function_id.function_id,
                'module_name': func.module_id.module_name if func.module_id else None,
                'record_status': func.Record_Status,
                'auth_status': func.Auth_Status,
                'is_authorized': is_authorized,
                'is_open': is_open,
                'will_execute': is_ready,
                'status_text': self._get_status_text(func.Record_Status, func.Auth_Status)
            })

        return Response({
            'summary': {
                'total_functions': total_functions,
                'authorized_functions': authorized_functions,
                'open_functions': open_functions,
                'ready_for_execution': ready_for_execution,
                'can_start_eod': ready_for_execution > 0 or total_functions == 0
            },
            'functions': functions_data
        })

    def _get_status_text(self, record_status, auth_status):
        """ສ້າງຂໍ້ຄວາມສະຖານະເປັນພາສາລາວ"""
        if auth_status != 'A':
            return 'ຍັງບໍ່ໄດ້ອະນຸມັດ'
        elif record_status == 'O':
            return 'ພ້ອມປະມວນຜົນ'
        elif record_status == 'C':
            return 'ປິດ - ຈະບໍ່ປະມວນຜົນ'
        else:
            return 'ສະຖານະບໍ່ຮູ້ຈັກ'

    @action(detail=False, methods=['post'], permission_classes=[IsAuthenticated])
    def bulk_open(self, request):
        """ເປີດຟັງຊັນ EOD ທັງໝົດທີ່ຖືກອະນຸມັດແລ້ວ"""
        try:
            with transaction.atomic():
                eod_functions = MTTB_EOC_MAINTAIN.objects.filter(
                    eoc_type='EOD',
                    Auth_Status='A',
                    Record_Status='C'
                )

                if not eod_functions.exists():
                    return Response({
                        'message': 'ບໍ່ມີຟັງຊັນທີ່ສາມາດເປີດໄດ້'
                    })

                user_id = getattr(request.user, 'user_id', None)
                update_time = timezone.now()

                updated_count = eod_functions.update(
                    Record_Status='O',
                    Checker_Id_id=user_id,
                    Checker_DT_Stamp=update_time
                )

                return Response({
                    'message': f'ເປີດຟັງຊັນ EOD ສໍາເລັດ: {updated_count} ຟັງຊັນ',
                    'updated_count': updated_count
                })

        except Exception as e:
            logger.error(f"Error in bulk_open: {str(e)}")
            return Response({
                'error': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @action(detail=False, methods=['post'], permission_classes=[IsAuthenticated])
    def bulk_close(self, request):
        """ປິດຟັງຊັນ EOD ທັງໝົດ"""
        try:
            with transaction.atomic():
                eod_functions = MTTB_EOC_MAINTAIN.objects.filter(
                    eoc_type='EOD',
                    Record_Status='O'
                )

                if not eod_functions.exists():
                    return Response({
                        'message': 'ບໍ່ມີຟັງຊັນທີ່ສາມາດປິດໄດ້'
                    })

                user_id = getattr(request.user, 'user_id', None)
                update_time = timezone.now()

                updated_count = eod_functions.update(
                    Record_Status='C',
                    Checker_Id_id=user_id,
                    Checker_DT_Stamp=update_time
                )

                return Response({
                    'message': f'ປິດຟັງຊັນ EOD ສໍາເລັດ: {updated_count} ຟັງຊັນ',
                    'updated_count': updated_count
                })

        except Exception as e:
            logger.error(f"Error in bulk_close: {str(e)}")
            return Response({
                'error': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    # Keep your existing bulk_journal method but it's now called by the main EOD process
    @action(detail=False, methods=['post'], url_path='bulk-journal', permission_classes=[IsAuthenticated])
    def bulk_journal(self, request, pk=None):
        """
        Legacy method - now this is called automatically by the main EOD process
        But kept for backward compatibility or manual execution
        """
        try:
            from views import execute_bulk_journal
            
            # Create a mock eod_function object for the call
            class MockEODFunction:
                function_id = type('obj', (object,), {'function_id': 'EOD_JOURNAL'})
            
            success, message = execute_bulk_journal(MockEODFunction(), request.user)
            
            if success:
                return Response({
                    'status': 'success',
                    'message': message
                })
            else:
                return Response({
                    'status': 'error',
                    'message': message
                }, status=status.HTTP_400_BAD_REQUEST)
                
        except Exception as e:
            logger.error(f"Error in bulk_journal: {str(e)}")
            return Response({
                'status': 'error',
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    
# from rest_framework import viewsets, permissions
# from rest_framework.permissions import AllowAny, IsAuthenticated
# from django_filters.rest_framework import DjangoFilterBackend
# from .models import MasterType, MasterCode
# from .serializers import MasterTypeSerializer, MasterCodeSerializer

# class MasterTypeViewSet(viewsets.ModelViewSet):
#     queryset = MasterType.objects.all()
#     serializer_class = MasterTypeSerializer
#     filter_backends = [DjangoFilterBackend]
#     filterset_fields = ['M_code', 'M_name_la', 'M_name_en', 'Status']

#     def get_permissions(self):
#         # Allow unauthenticated POST, require auth otherwise
#         if self.request.method == 'POST':
#             return [AllowAny()]
#         return [IsAuthenticated()]

# class MasterCodeViewSet(viewsets.ModelViewSet):
#     queryset = MasterCode.objects.all()
#     serializer_class = MasterCodeSerializer
#     filter_backends = [DjangoFilterBackend]
#     filterset_fields = ['MC_code', 'MC_name_la', 'MC_name_en', 'Status', 'BOL_code', 'BOL_name', 'M_id']

#     def get_permissions(self):
#         # Allow unauthenticated POST, require auth otherwise
#         if self.request.method == 'POST':
#             return [AllowAny()]
#         return [IsAuthenticated()]
    
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend
from .models import MasterType, MasterCode
from .serializers import MasterTypeSerializer, MasterCodeSerializer

class MasterTypeViewSet(viewsets.ModelViewSet):
    queryset = MasterType.objects.all()
    serializer_class = MasterTypeSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['M_code', 'M_name_la', 'M_name_en', 'Status']
    lookup_field = 'M_id'  # Use M_id for standard CRUD operations

    def get_permissions(self):
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    @action(detail=False, methods=['get'], url_path='tree/(?P<m_code>[^/.]+)')
    def get_tree(self, request, m_code=None):
        """
        Retrieve MasterType with related MasterCode entries in a tree structure.
        :param m_code: M_code of the MasterType
        """
        try:
            master_type = MasterType.objects.get(M_code=m_code)  # Fetch by M_code
            master_codes = MasterCode.objects.filter(M_id=master_type)

            # Serialize MasterType
            type_serializer = MasterTypeSerializer(master_type)
            
            # Serialize related MasterCodes
            code_serializer = MasterCodeSerializer(master_codes, many=True)

            # Construct tree response
            tree_data = {
                'MasterType': type_serializer.data,
                'MasterCodes': code_serializer.data
            }

            return Response(tree_data)
        except MasterType.DoesNotExist:
            return Response({'error': 'MasterType not found'}, status=404)

class MasterCodeViewSet(viewsets.ModelViewSet):
    queryset = MasterCode.objects.all()
    serializer_class = MasterCodeSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['MC_code', 'MC_name_la', 'MC_name_en', 'Status', 'BOL_code', 'BOL_name', 'M_id']
    lookup_field = 'MC_code' 

    def get_permissions(self):
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    
# sone perm code.............................................................................



# from rest_framework import viewsets, status
# from rest_framework.decorators import action
# from rest_framework.response import Response
# from rest_framework.permissions import IsAuthenticated
# from rest_framework.request import Request
# from django.db import transaction
# from django.utils import timezone
# from django.test import RequestFactory
# import json

# class YourProcessViewSet(viewsets.ModelViewSet):

#     @action(detail=False, methods=['post'])
#     def process_journal_data(self, request):
#         try:
#             data = request.data
#             glsub_ids = []
#             glsub_map = {}  

            
#             ccy_cd = data.get('Ccy_cd')
#             try:
#                 ccy_record = MTTB_Ccy_DEFN.objects.get(ccy_code=ccy_cd)
#                 alt_ccy_code = ccy_record.ALT_Ccy_Code
#             except MTTB_Ccy_DEFN.DoesNotExist:
#                 return Response({
#                     'success': False,
#                     'message': f'ບໍ່ພົບ currency code: {ccy_cd} ໃນ MTTB_Ccy_DEFN'
#                 }, status=status.HTTP_400_BAD_REQUEST)

#             with transaction.atomic():
#                 for entry in data.get('entries', []):
#                     account_no = entry.get('Account_no')
#                     addl_sub_text = entry.get('Addl_sub_text')

#                     gl_code_part = account_no.split('.')[0] if '.' in account_no else account_no

#                     try:
#                         gl_master = MTTB_GLMaster.objects.get(gl_code=gl_code_part)
#                         gl_code_obj = gl_master  
#                     except MTTB_GLMaster.DoesNotExist:
#                         return Response({
#                             'success': False,
#                             'message': f'ບໍ່ພົບ gl_code: {gl_code_part} ໃນ MTTB_GLMaster'
#                         }, status=status.HTTP_400_BAD_REQUEST)

                    
#                     if entry.get("Dr_cr") == "D":
#                         current_time = timezone.now()
                        
                        
#                         try:
#                             maker_user = MTTB_Users.objects.get(user_id=request.user.user_id)
#                         except MTTB_Users.DoesNotExist:
#                             return Response({
#                                 'success': False,
#                                 'message': f'ບໍ່ພົບຜູ້ໃຊ້: {request.user.user_id}'
#                             }, status=status.HTTP_400_BAD_REQUEST)
                        
#                         glsub_record = MTTB_GLSub.objects.create(
#                             glsub_code=account_no,
#                             glsub_Desc_la=addl_sub_text,
#                             gl_code=gl_code_obj, 
#                             Maker_DT_Stamp=current_time,
#                             Checker_DT_Stamp=current_time,
#                             Maker_Id=maker_user,  
#                             Checker_Id=maker_user, 
#                             Record_Status="O",
#                             Auth_Status="A"
#                         )
#                         glsub_id = glsub_record.glsub_id
#                     else:
                       
#                         try:
#                             glsub = MTTB_GLSub.objects.get(glsub_code=account_no)
#                             glsub_id = glsub.glsub_id
#                         except MTTB_GLSub.DoesNotExist:
#                             return Response({
#                                 'success': False,
#                                 'message': f'ບໍ່ພົບ GLSub ສໍາລັບ Account_no: {account_no}'
#                             }, status=status.HTTP_400_BAD_REQUEST)

#                     glsub_ids.append(glsub_id)
#                     glsub_map[account_no] = glsub_id

#                 processed_data = {
#                     "Reference_No": data.get('Reference_No'),
#                     "Ccy_cd": data.get('Ccy_cd'),
#                     "Txn_code": data.get('Txn_code'),
#                     "Value_date": data.get('Value_date'),
#                     "Addl_text": data.get('Addl_text'),
#                     "fin_cycle": data.get('fin_cycle'),
#                     "Period_code": data.get('Period_code'),
#                     "module_id": data.get('module_id'),
#                     "Maker_Id": request.user.user_id, 
#                     "Record_Status": "O",  
#                     "Auth_Status": "A",   
#                     "entries": []
#                 }

              
#                 for i, entry in enumerate(data.get('entries', [])):
#                     original_acc_no = entry.get("Account_no")
#                     acc_id = glsub_map.get(original_acc_no)
#                     # ac_rel = list(glsub_map.values())[1] if i == 0 else list(glsub_map.values())[0]
#                     # ac_rel = list(glsub_map.keys())[1] if i == 0 else list(glsub_map.keys())[0]
#                     ac_rel = list(glsub_map.keys())[1] if i == 0 else list(glsub_map.keys())[0]

                    
#                     # modified_acc_no = f"{alt_ccy_code}.{original_acc_no}"
#                     # modified_acc_no = f"{alt_ccy_code}.{original_acc_no}"
#                     modified_acc_no = f"{alt_ccy_code}.{original_acc_no}"
#                     all_modified_accounts = [f"{alt_ccy_code}.{acc}" for acc in glsub_map.keys()]
#                     ac_rel = all_modified_accounts[1] if i == 0 else all_modified_accounts[0]

#                     processed_entry = {
#                         "Account": acc_id,
#                         "Account_no": modified_acc_no, 
#                         "Amount": entry.get('Amount'),
#                         "Dr_cr": entry.get('Dr_cr'),
#                         "Addl_sub_text": entry.get('Addl_sub_text'),
#                         # "Ac_relatives": str(ac_rel),
#                         "Ac_relatives": ac_rel,
#                         "Maker_Id": request.user.user_id,  
#                         "Record_Status": "O", 
#                         "Auth_Status": "A"    
#                     }
#                     processed_data["entries"].append(processed_entry)

                
#                 try:
#                     from SAMCSYS.views import JRNLLogViewSet

#                     factory = RequestFactory()
                    
                   
#                     raw_request = factory.post(
#                         '/api/journal-entries/batch_create/',
#                         data=json.dumps(processed_data),
#                         content_type='application/json'
#                     )
#                     raw_request.user = request.user
#                     drf_request = Request(raw_request)

#                     viewset = JRNLLogViewSet()
#                     viewset.request = drf_request
#                     viewset.format_kwarg = None

#                     batch_response = viewset.batch_create(drf_request)

#                     if batch_response.status_code in [200, 201]:
#                         journal_response = {
#                             'success': True,
#                             'status_code': batch_response.status_code,
#                             'data': batch_response.data,
#                             'method': 'internal_batch_create'
#                         }
#                     else:
#                         journal_response = {
#                             'success': False,
#                             'status_code': batch_response.status_code,
#                             'error': batch_response.data,
#                             'method': 'internal_batch_create_failed'
#                         }

#                 except Exception as e:
                    
#                     try:
#                         viewset = JRNLLogViewSet()
                        
#                         viewset.request = request
#                         viewset.format_kwarg = None
                        
                        
#                         from unittest.mock import Mock
#                         mock_request = Mock()
#                         mock_request.data = processed_data
#                         mock_request.user = request.user
                        
#                         batch_response = viewset.batch_create(mock_request)
                        
#                         if batch_response.status_code in [200, 201]:
#                             journal_response = {
#                                 'success': True,
#                                 'status_code': batch_response.status_code,
#                                 'data': batch_response.data,
#                                 'method': 'direct_call'
#                             }
#                         else:
#                             journal_response = {
#                                 'success': False,
#                                 'status_code': batch_response.status_code,
#                                 'error': batch_response.data,
#                                 'method': 'direct_call_failed'
#                             }
#                     except Exception as e2:
#                         journal_response = {
#                             'success': False,
#                             'error': f'ViewSet Error: {str(e)} | Direct call error: {str(e2)}',
#                             'note': 'GLSub records created. Please create journal entry manually.'
#                         }

#                 return Response({
#                     'success': True,
#                     'message': 'ປະມວນຜົນແລະບັນທຶກຂໍ້ມູນສຳເລັດແລ້ວ',
#                     'processed_data': processed_data,
#                     'glsub_ids': glsub_ids,
#                     'alt_ccy_code': alt_ccy_code,  
#                     'journal_response': journal_response
#                 }, status=status.HTTP_201_CREATED)

#         except Exception as e:
#             return Response({
#                 'success': False,
#                 'message': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'
#             }, status=status.HTTP_400_BAD_REQUEST)

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.request import Request
from django.db import transaction
from django.utils import timezone
from django.test import RequestFactory
import json
import requests
class YourProcessViewSet(viewsets.ModelViewSet):

    @action(detail=False, methods=['post'])
    def process_journal_data(self, request):
        try:
            data = request.data
            glsub_ids = []
            glsub_map = {}  

            
            ccy_cd = data.get('Ccy_cd')
            try:
                ccy_record = MTTB_Ccy_DEFN.objects.get(ccy_code=ccy_cd)
                alt_ccy_code = ccy_record.ALT_Ccy_Code
            except MTTB_Ccy_DEFN.DoesNotExist:
                return Response({
                    'success': False,
                    'message': f'ບໍ່ພົບ currency code: {ccy_cd} ໃນ MTTB_Ccy_DEFN'
                }, status=status.HTTP_400_BAD_REQUEST)

            with transaction.atomic():
                for entry in data.get('entries', []):
                    account_no = entry.get('Account_no')
                    addl_sub_text = entry.get('Addl_sub_text')

                    gl_code_part = account_no.split('.')[0] if '.' in account_no else account_no

                    try:
                        gl_master = MTTB_GLMaster.objects.get(gl_code=gl_code_part)
                        gl_code_obj = gl_master  
                    except MTTB_GLMaster.DoesNotExist:
                        return Response({
                            'success': False,
                            'message': f'ບໍ່ພົບ gl_code: {gl_code_part} ໃນ MTTB_GLMaster'
                        }, status=status.HTTP_400_BAD_REQUEST)

                    
                    if entry.get("Dr_cr") == "D":
                        current_time = timezone.now()
                        
                        
                        try:
                            maker_user = MTTB_Users.objects.get(user_id=request.user.user_id)
                        except MTTB_Users.DoesNotExist:
                            return Response({
                                'success': False,
                                'message': f'ບໍ່ພົບຜູ້ໃຊ້: {request.user.user_id}'
                            }, status=status.HTTP_400_BAD_REQUEST)
                        
                        glsub_record = MTTB_GLSub.objects.create(
                            glsub_code=account_no,
                            glsub_Desc_la=addl_sub_text,
                            gl_code=gl_code_obj, 
                            Maker_DT_Stamp=current_time,
                            Checker_DT_Stamp=current_time,
                            Maker_Id=maker_user,  
                            Checker_Id=maker_user, 
                            Record_Status="O",
                            Auth_Status="A"
                        )
                        glsub_id = glsub_record.glsub_id
                    else:
                       
                        try:
                            glsub = MTTB_GLSub.objects.get(glsub_code=account_no)
                            glsub_id = glsub.glsub_id
                        except MTTB_GLSub.DoesNotExist:
                            return Response({
                                'success': False,
                                'message': f'ບໍ່ພົບ GLSub ສໍາລັບ Account_no: {account_no}'
                            }, status=status.HTTP_400_BAD_REQUEST)

                    glsub_ids.append(glsub_id)
                    glsub_map[account_no] = glsub_id

                processed_data = {
                    "Reference_No": data.get('Reference_No'),
                    "Ccy_cd": data.get('Ccy_cd'),
                    "Txn_code": data.get('Txn_code'),
                    "Value_date": data.get('Value_date'),
                    "Addl_text": data.get('Addl_text'),
                    "fin_cycle": data.get('fin_cycle'),
                    "Period_code": data.get('Period_code'),
                    "module_id": data.get('module_id'),
                    "Maker_Id": request.user.user_id, 
                    "Record_Status": "O",  
                    "Auth_Status": "A",   
                    "entries": []
                }

              
                for i, entry in enumerate(data.get('entries', [])):
                    original_acc_no = entry.get("Account_no")
                    acc_id = glsub_map.get(original_acc_no)
                    
                    # ໃຊ້ Ac_relatives ທີ່ສົ່ງມາຈາກ frontend
                    ac_relatives = entry.get('Ac_relatives', '')
                    
                    modified_acc_no = f"{alt_ccy_code}.{original_acc_no}"

                    processed_entry = {
                        "Account": acc_id,
                        "Account_no": modified_acc_no, 
                        "Amount": entry.get('Amount'),
                        "Dr_cr": entry.get('Dr_cr'),
                        "Addl_sub_text": entry.get('Addl_sub_text'),
                        "Ac_relatives": ac_relatives,  # ໃຊ້ຄ່າຈາກ frontend
                        "Maker_Id": request.user.user_id,  
                        "Record_Status": "O", 
                        "Auth_Status": "A"    
                    }
                    processed_data["entries"].append(processed_entry)

                
                try:
                    from SAMCSYS.views import JRNLLogViewSet

                    factory = RequestFactory()
                    
                   
                    raw_request = factory.post(
                        '/api/journal-entries/batch_create/',
                        data=json.dumps(processed_data),
                        content_type='application/json'
                    )
                    raw_request.user = request.user
                    drf_request = Request(raw_request)

                    viewset = JRNLLogViewSet()
                    viewset.request = drf_request
                    viewset.format_kwarg = None

                    batch_response = viewset.batch_create(drf_request)

                    if batch_response.status_code in [200, 201]:
                        journal_response = {
                            'success': True,
                            'status_code': batch_response.status_code,
                            'data': batch_response.data,
                            'method': 'internal_batch_create'
                        }
                    else:
                        journal_response = {
                            'success': False,
                            'status_code': batch_response.status_code,
                            'error': batch_response.data,
                            'method': 'internal_batch_create_failed'
                        }

                except Exception as e:
                    
                    try:
                        viewset = JRNLLogViewSet()
                        
                        viewset.request = request
                        viewset.format_kwarg = None
                        
                        
                        from unittest.mock import Mock
                        mock_request = Mock()
                        mock_request.data = processed_data
                        mock_request.user = request.user
                        
                        batch_response = viewset.batch_create(mock_request)
                        
                        if batch_response.status_code in [200, 201]:
                            journal_response = {
                                'success': True,
                                'status_code': batch_response.status_code,
                                'data': batch_response.data,
                                'method': 'direct_call'
                            }
                        else:
                            journal_response = {
                                'success': False,
                                'status_code': batch_response.status_code,
                                'error': batch_response.data,
                                'method': 'direct_call_failed'
                            }
                    except Exception as e2:
                        journal_response = {
                            'success': False,
                            'error': f'ViewSet Error: {str(e)} | Direct call error: {str(e2)}',
                            'note': 'GLSub records created. Please create journal entry manually.'
                        }

                return Response({
                    'success': True,
                    'message': 'ປະມວນຜົນແລະບັນທຶກຂໍ້ມູນສຳເລັດແລ້ວ',
                    'processed_data': processed_data,
                    'glsub_ids': glsub_ids,
                    'alt_ccy_code': alt_ccy_code,  
                    'journal_response': journal_response
                }, status=status.HTTP_201_CREATED)

        except Exception as e:
            return Response({
                'success': False,
                'message': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'
            }, status=status.HTTP_400_BAD_REQUEST)
        

# from rest_framework import viewsets, status
# from rest_framework.decorators import action
# from rest_framework.response import Response
# from rest_framework.permissions import IsAuthenticated
# from rest_framework.request import Request
# from django.db import transaction
# from django.utils import timezone
# from django.test import RequestFactory
# import json

# class YourProcessViewSet(viewsets.ModelViewSet):

#     @action(detail=False, methods=['post'])
#     def process_journal_data(self, request):
#         try:
#             data = request.data
#             glsub_ids = []
#             glsub_map = {}  

            
#             ccy_cd = data.get('Ccy_cd')
#             try:
#                 ccy_record = MTTB_Ccy_DEFN.objects.get(ccy_code=ccy_cd)
#                 alt_ccy_code = ccy_record.ALT_Ccy_Code
#             except MTTB_Ccy_DEFN.DoesNotExist:
#                 return Response({
#                     'success': False,
#                     'message': f'ບໍ່ພົບ currency code: {ccy_cd} ໃນ MTTB_Ccy_DEFN'
#                 }, status=status.HTTP_400_BAD_REQUEST)

#             with transaction.atomic():
#                 for entry in data.get('entries', []):
#                     account_no = entry.get('Account_no')
#                     addl_sub_text = entry.get('Addl_sub_text')

#                     gl_code_part = account_no.split('.')[0] if '.' in account_no else account_no

#                     try:
#                         gl_master = MTTB_GLMaster.objects.get(gl_code=gl_code_part)
#                         gl_code_id = gl_master.glid
#                     except MTTB_GLMaster.DoesNotExist:
#                         return Response({
#                             'success': False,
#                             'message': f'ບໍ່ພົບ gl_code: {gl_code_part} ໃນ MTTB_GLMaster'
#                         }, status=status.HTTP_400_BAD_REQUEST)

                    
#                     if entry.get("Dr_cr") == "D":
#                         current_time = timezone.now()
#                         glsub_record = MTTB_GLSub.objects.create(
#                             glsub_code=account_no,
#                             glsub_Desc_la=addl_sub_text,
#                             gl_code_id=gl_code_id,
#                             Maker_DT_Stamp=current_time,
#                             Checker_DT_Stamp=current_time,
#                             Record_Status="O",
#                             Auth_Status="A" 
#                         )
#                         glsub_id = glsub_record.glsub_id
#                     else:
                       
#                         try:
#                             glsub = MTTB_GLSub.objects.get(glsub_code=account_no)
#                             glsub_id = glsub.glsub_id
#                         except MTTB_GLSub.DoesNotExist:
#                             return Response({
#                                 'success': False,
#                                 'message': f'ບໍ່ພົບ GLSub ສໍາລັບ Account_no: {account_no}'
#                             }, status=status.HTTP_400_BAD_REQUEST)

#                     glsub_ids.append(glsub_id)
#                     glsub_map[account_no] = glsub_id

#                 processed_data = {
#                     "Reference_No": data.get('Reference_No'),
#                     "Ccy_cd": data.get('Ccy_cd'),
#                     "Txn_code": data.get('Txn_code'),
#                     "Value_date": data.get('Value_date'),
#                     "Addl_text": data.get('Addl_text'),
#                     "fin_cycle": data.get('fin_cycle'),
#                     "Period_code": data.get('Period_code'),
#                     "module_id": data.get('module_id'),
#                     "entries": []
#                 }

              
#                 for i, entry in enumerate(data.get('entries', [])):
#                     original_acc_no = entry.get("Account_no")
#                     acc_id = glsub_map.get(original_acc_no)
#                     ac_rel = list(glsub_map.values())[1] if i == 0 else list(glsub_map.values())[0]

                    
#                     modified_acc_no = f"{alt_ccy_code}.{original_acc_no}"

#                     processed_entry = {
#                         "Account": acc_id,
#                         "Account_no": modified_acc_no, 
#                         "Amount": entry.get('Amount'),
#                         "Dr_cr": entry.get('Dr_cr'),
#                         "Addl_sub_text": entry.get('Addl_sub_text'),
#                         "Ac_relatives": str(ac_rel)
#                     }
#                     processed_data["entries"].append(processed_entry)

                
#                 try:
#                     from SAMCSYS.views import JRNLLogViewSet

#                     factory = RequestFactory()
                    
                   
#                     raw_request = factory.post(
#                         '/api/journal-entries/batch_create/',
#                         data=json.dumps(processed_data),
#                         content_type='application/json'
#                     )
#                     raw_request.user = request.user
#                     drf_request = Request(raw_request)

#                     viewset = JRNLLogViewSet()
#                     viewset.request = drf_request
#                     viewset.format_kwarg = None

#                     batch_response = viewset.batch_create(drf_request)

#                     if batch_response.status_code in [200, 201]:
#                         journal_response = {
#                             'success': True,
#                             'status_code': batch_response.status_code,
#                             'data': batch_response.data,
#                             'method': 'internal_batch_create'
#                         }
#                     else:
#                         journal_response = {
#                             'success': False,
#                             'status_code': batch_response.status_code,
#                             'error': batch_response.data,
#                             'method': 'internal_batch_create_failed'
#                         }

#                 except Exception as e:
                    
#                     try:
#                         viewset = JRNLLogViewSet()
                        
#                         viewset.request = request
#                         viewset.format_kwarg = None
                        
                        
#                         from unittest.mock import Mock
#                         mock_request = Mock()
#                         mock_request.data = processed_data
#                         mock_request.user = request.user
                        
#                         batch_response = viewset.batch_create(mock_request)
                        
#                         if batch_response.status_code in [200, 201]:
#                             journal_response = {
#                                 'success': True,
#                                 'status_code': batch_response.status_code,
#                                 'data': batch_response.data,
#                                 'method': 'direct_call'
#                             }
#                         else:
#                             journal_response = {
#                                 'success': False,
#                                 'status_code': batch_response.status_code,
#                                 'error': batch_response.data,
#                                 'method': 'direct_call_failed'
#                             }
#                     except Exception as e2:
#                         journal_response = {
#                             'success': False,
#                             'error': f'ViewSet Error: {str(e)} | Direct call error: {str(e2)}',
#                             'note': 'GLSub records created. Please create journal entry manually.'
#                         }

#                 return Response({
#                     'success': True,
#                     'message': 'ປະມວນຜົນແລະບັນທຶກຂໍ້ມູນສຳເລັດແລ້ວ',
#                     'processed_data': processed_data,
#                     'glsub_ids': glsub_ids,
#                     'alt_ccy_code': alt_ccy_code,  
#                     'journal_response': journal_response
#                 }, status=status.HTTP_201_CREATED)

#         except Exception as e:
#             return Response({
#                 'success': False,
#                 'message': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'
#             }, status=status.HTTP_400_BAD_REQUEST)
class JournalProcessV2ViewSet(viewsets.ModelViewSet):

    @action(detail=False, methods=['post'])
    def process_journal_data(self, request):
        try:
            # Debug logging
            print(f"Request method: {request.method}")
            print(f"Request data: {request.data}")
            print(f"Request user: {request.user}")
            
            data = request.data
            glsub_ids = []
            glsub_map = {}  

            ccy_cd = data.get('Ccy_cd')
            try:
                ccy_record = MTTB_Ccy_DEFN.objects.get(ccy_code=ccy_cd)
                alt_ccy_code = ccy_record.ALT_Ccy_Code
            except MTTB_Ccy_DEFN.DoesNotExist:
                return Response({
                    'success': False,
                    'message': f'ບໍ່ພົບ currency code: {ccy_cd} ໃນ MTTB_Ccy_DEFN'
                }, status=status.HTTP_400_BAD_REQUEST)

            with transaction.atomic():
                for entry in data.get('entries', []):
                    account_no = entry.get('Account_no')
                    addl_sub_text = entry.get('Addl_sub_text')

                    gl_code_part = account_no.split('.')[0] if '.' in account_no else account_no

                    try:
                        gl_master = MTTB_GLMaster.objects.get(gl_code=gl_code_part)
                        gl_code_obj = gl_master  
                    except MTTB_GLMaster.DoesNotExist:
                        return Response({
                            'success': False,
                            'message': f'ບໍ່ພົບ gl_code: {gl_code_part} ໃນ MTTB_GLMaster'
                        }, status=status.HTTP_400_BAD_REQUEST)

                    current_time = timezone.now()
                    
                    try:
                        maker_user = MTTB_Users.objects.get(user_id=request.user.user_id)
                    except MTTB_Users.DoesNotExist:
                        return Response({
                            'success': False,
                            'message': f'ບໍ່ພົບຜູ້ໃຊ້: {request.user.user_id}'
                        }, status=status.HTTP_400_BAD_REQUEST)
                    
                    # ກວດສອບວ່າມີ GLSub record ຢູ່ແລ້ວຫຼືບໍ່
                    existing_glsub = MTTB_GLSub.objects.filter(glsub_code=account_no).first()
                    
                    if existing_glsub:
                        # ຖ້າມີແລ້ວ, ອັບເດດຂໍ້ມູນ
                        existing_glsub.glsub_Desc_la = addl_sub_text
                        existing_glsub.gl_code = gl_code_obj
                        existing_glsub.Checker_DT_Stamp = current_time
                        existing_glsub.Checker_Id = maker_user
                        existing_glsub.Record_Status = "O"
                        existing_glsub.Auth_Status = "A"
                        existing_glsub.save()
                        
                        glsub_record = existing_glsub
                        action_taken = "updated"
                        
                    else:
                        # ຖ້າບໍ່ມີ, ສ້າງໃໝ່
                        glsub_record = MTTB_GLSub.objects.create(
                            glsub_code=account_no,
                            glsub_Desc_la=addl_sub_text,
                            gl_code=gl_code_obj, 
                            Maker_DT_Stamp=current_time,
                            Checker_DT_Stamp=current_time,
                            Maker_Id=maker_user,  
                            Checker_Id=maker_user, 
                            Record_Status="O",
                            Auth_Status="A"
                        )
                        
                        action_taken = "created"
                    
                    glsub_id = glsub_record.glsub_id
                    glsub_ids.append(glsub_id)
                    glsub_map[account_no] = glsub_id

                processed_data = {
                    "Reference_No": data.get('Reference_No'),
                    "Ccy_cd": data.get('Ccy_cd'),
                    "Txn_code": data.get('Txn_code'),
                    "Value_date": data.get('Value_date'),
                    "Addl_text": data.get('Addl_text'),
                    "fin_cycle": data.get('fin_cycle'),
                    "Period_code": data.get('Period_code'),
                    "module_id": data.get('module_id'),
                    "Maker_Id": request.user.user_id, 
                    "Record_Status": "O",  
                    "Auth_Status": "A",   
                    "entries": []
                }

                for i, entry in enumerate(data.get('entries', [])):
                    original_acc_no = entry.get("Account_no")
                    acc_id = glsub_map.get(original_acc_no)
                    
                    modified_acc_no = f"{alt_ccy_code}.{original_acc_no}"
                    
                    # ໃຊ້ Ac_relatives ທີ່ສົ່ງມາຈາກ frontend
                    ac_relatives = entry.get('Ac_relatives', '')

                    processed_entry = {
                        "Account": acc_id,
                        "Account_no": modified_acc_no, 
                        "Amount": entry.get('Amount'),
                        "Dr_cr": entry.get('Dr_cr'),
                        "Addl_sub_text": entry.get('Addl_sub_text'),
                        "Ac_relatives": ac_relatives,  # ໃຊ້ຄ່າຈາກ frontend
                        "Maker_Id": request.user.user_id,  
                        "Record_Status": "O", 
                        "Auth_Status": "A"    
                    }
                    processed_data["entries"].append(processed_entry)

                try:
                    from SAMCSYS.views import JRNLLogViewSet

                    factory = RequestFactory()
                    raw_request = factory.post(
                        '/api/journal-entries/batch_create/',
                        data=json.dumps(processed_data),
                        content_type='application/json'
                    )
                    raw_request.user = request.user
                    drf_request = Request(raw_request)

                    viewset = JRNLLogViewSet()
                    viewset.request = drf_request
                    viewset.format_kwarg = None

                    batch_response = viewset.batch_create(drf_request)

                    if batch_response.status_code in [200, 201]:
                        journal_response = {
                            'success': True,
                            'status_code': batch_response.status_code,
                            'data': batch_response.data,
                            'method': 'internal_batch_create'
                        }
                    else:
                        journal_response = {
                            'success': False,
                            'status_code': batch_response.status_code,
                            'error': batch_response.data,
                            'method': 'internal_batch_create_failed'
                        }

                except Exception as e:
                    try:
                        viewset = JRNLLogViewSet()
                        viewset.request = request
                        viewset.format_kwarg = None
                        
                        from unittest.mock import Mock
                        mock_request = Mock()
                        mock_request.data = processed_data
                        mock_request.user = request.user
                        
                        batch_response = viewset.batch_create(mock_request)
                        
                        if batch_response.status_code in [200, 201]:
                            journal_response = {
                                'success': True,
                                'status_code': batch_response.status_code,
                                'data': batch_response.data,
                                'method': 'direct_call'
                            }
                        else:
                            journal_response = {
                                'success': False,
                                'status_code': batch_response.status_code,
                                'error': batch_response.data,
                                'method': 'direct_call_failed'
                            }
                    except Exception as e2:
                        journal_response = {
                            'success': False,
                            'error': f'ViewSet Error: {str(e)} | Direct call error: {str(e2)}',
                            'note': 'GLSub records processed. Please create journal entry manually.'
                        }

                return Response({
                    'success': True,
                    'message': 'ປະມວນຜົນແລະບັນທຶກຂໍ້ມູນສຳເລັດແລ້ວ (ກວດສອບ/ອັບເດດ/ສ້າງ GLSub)',
                    'processed_data': processed_data,
                    'glsub_ids': glsub_ids,
                    'alt_ccy_code': alt_ccy_code,  
                    'journal_response': journal_response
                }, status=status.HTTP_201_CREATED)

        except Exception as e:
            # Debug error details
            import traceback
            print(f"Error occurred: {str(e)}")
            print(f"Traceback: {traceback.format_exc()}")
            
            return Response({
                'success': False,
                'message': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}',
                'traceback': traceback.format_exc() if hasattr(traceback, 'format_exc') else str(e)
            }, status=status.HTTP_400_BAD_REQUEST)
# class JournalProcessV2ViewSet(viewsets.ModelViewSet):

#     @action(detail=False, methods=['post'])
#     def process_journal_data(self, request):
#         try:
#             data = request.data
#             glsub_ids = []
#             glsub_map = {}  

#             ccy_cd = data.get('Ccy_cd')
#             try:
#                 ccy_record = MTTB_Ccy_DEFN.objects.get(ccy_code=ccy_cd)
#                 alt_ccy_code = ccy_record.ALT_Ccy_Code
#             except MTTB_Ccy_DEFN.DoesNotExist:
#                 return Response({
#                     'success': False,
#                     'message': f'ບໍ່ພົບ currency code: {ccy_cd} ໃນ MTTB_Ccy_DEFN'
#                 }, status=status.HTTP_400_BAD_REQUEST)

#             with transaction.atomic():
#                 for entry in data.get('entries', []):
#                     account_no = entry.get('Account_no')
#                     addl_sub_text = entry.get('Addl_sub_text')

#                     gl_code_part = account_no.split('.')[0] if '.' in account_no else account_no

#                     try:
#                         gl_master = MTTB_GLMaster.objects.get(gl_code=gl_code_part)
#                         gl_code_obj = gl_master  
#                     except MTTB_GLMaster.DoesNotExist:
#                         return Response({
#                             'success': False,
#                             'message': f'ບໍ່ພົບ gl_code: {gl_code_part} ໃນ MTTB_GLMaster'
#                         }, status=status.HTTP_400_BAD_REQUEST)

                    
#                     current_time = timezone.now()
                    
#                     try:
#                         maker_user = MTTB_Users.objects.get(user_id=request.user.user_id)
#                     except MTTB_Users.DoesNotExist:
#                         return Response({
#                             'success': False,
#                             'message': f'ບໍ່ພົບຜູ້ໃຊ້: {request.user.user_id}'
#                         }, status=status.HTTP_400_BAD_REQUEST)
                    
                    
#                     glsub_record = MTTB_GLSub.objects.create(
#                         glsub_code=account_no,
#                         glsub_Desc_la=addl_sub_text,
#                         gl_code=gl_code_obj, 
#                         Maker_DT_Stamp=current_time,
#                         Checker_DT_Stamp=current_time,
#                         Maker_Id=maker_user,  
#                         Checker_Id=maker_user, 
#                         Record_Status="O",
#                         Auth_Status="A"
#                     )
#                     glsub_id = glsub_record.glsub_id

#                     glsub_ids.append(glsub_id)
#                     glsub_map[account_no] = glsub_id

#                 processed_data = {
#                     "Reference_No": data.get('Reference_No'),
#                     "Ccy_cd": data.get('Ccy_cd'),
#                     "Txn_code": data.get('Txn_code'),
#                     "Value_date": data.get('Value_date'),
#                     "Addl_text": data.get('Addl_text'),
#                     "fin_cycle": data.get('fin_cycle'),
#                     "Period_code": data.get('Period_code'),
#                     "module_id": data.get('module_id'),
#                     "Maker_Id": request.user.user_id, 
#                     "Record_Status": "O",  
#                     "Auth_Status": "A",   
#                     "entries": []
#                 }

#                 for i, entry in enumerate(data.get('entries', [])):
#                     original_acc_no = entry.get("Account_no")
#                     acc_id = glsub_map.get(original_acc_no)
                    
#                     modified_acc_no = f"{alt_ccy_code}.{original_acc_no}"
#                     all_modified_accounts = [f"{alt_ccy_code}.{acc}" for acc in glsub_map.keys()]
#                     ac_rel = all_modified_accounts[1] if i == 0 else all_modified_accounts[0]

#                     processed_entry = {
#                         "Account": acc_id,
#                         "Account_no": modified_acc_no, 
#                         "Amount": entry.get('Amount'),
#                         "Dr_cr": entry.get('Dr_cr'),
#                         "Addl_sub_text": entry.get('Addl_sub_text'),
#                         "Ac_relatives": ac_rel,
#                         "Maker_Id": request.user.user_id,  
#                         "Record_Status": "O", 
#                         "Auth_Status": "A"    
#                     }
#                     processed_data["entries"].append(processed_entry)

#                 try:
#                     from SAMCSYS.views import JRNLLogViewSet

#                     factory = RequestFactory()
#                     raw_request = factory.post(
#                         '/api/journal-entries/batch_create/',
#                         data=json.dumps(processed_data),
#                         content_type='application/json'
#                     )
#                     raw_request.user = request.user
#                     drf_request = Request(raw_request)

#                     viewset = JRNLLogViewSet()
#                     viewset.request = drf_request
#                     viewset.format_kwarg = None

#                     batch_response = viewset.batch_create(drf_request)

#                     if batch_response.status_code in [200, 201]:
#                         journal_response = {
#                             'success': True,
#                             'status_code': batch_response.status_code,
#                             'data': batch_response.data,
#                             'method': 'internal_batch_create'
#                         }
#                     else:
#                         journal_response = {
#                             'success': False,
#                             'status_code': batch_response.status_code,
#                             'error': batch_response.data,
#                             'method': 'internal_batch_create_failed'
#                         }

#                 except Exception as e:
#                     try:
#                         viewset = JRNLLogViewSet()
#                         viewset.request = request
#                         viewset.format_kwarg = None
                        
#                         from unittest.mock import Mock
#                         mock_request = Mock()
#                         mock_request.data = processed_data
#                         mock_request.user = request.user
                        
#                         batch_response = viewset.batch_create(mock_request)
                        
#                         if batch_response.status_code in [200, 201]:
#                             journal_response = {
#                                 'success': True,
#                                 'status_code': batch_response.status_code,
#                                 'data': batch_response.data,
#                                 'method': 'direct_call'
#                             }
#                         else:
#                             journal_response = {
#                                 'success': False,
#                                 'status_code': batch_response.status_code,
#                                 'error': batch_response.data,
#                                 'method': 'direct_call_failed'
#                             }
#                     except Exception as e2:
#                         journal_response = {
#                             'success': False,
#                             'error': f'ViewSet Error: {str(e)} | Direct call error: {str(e2)}',
#                             'note': 'GLSub records created. Please create journal entry manually.'
#                         }

#                 return Response({
#                     'success': True,
#                     'message': 'ປະມວນຜົນແລະບັນທຶກຂໍ້ມູນສຳເລັດແລ້ວ (ສ້າງ GLSub ໃໝ່ທັງໝົດ)',
#                     'processed_data': processed_data,
#                     'glsub_ids': glsub_ids,
#                     'alt_ccy_code': alt_ccy_code,  
#                     'journal_response': journal_response
#                 }, status=status.HTTP_201_CREATED)

#         except Exception as e:
#             return Response({
#                 'success': False,
#                 'message': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'
#             }, status=status.HTTP_400_BAD_REQUEST)
# =====================================
# ຟັງຊັ້ນຄິດຄ່າເສື່ອມລາຄາ Backend ເທົ່ານັ້ນ
# ເພີ່ມໃນ views.py ຂອງທ່ານ
# =====================================



# Import models ຂອງທ່ານ - ເພີ່ມຕາຕະລາງປະຫວັດ
import json
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from decimal import Decimal, ROUND_HALF_UP
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.db import transaction
from django.utils import timezone
from django.db import models  

from .models import (
    FA_Accounting_Method, 
    FA_Asset_Lists,
    FA_Asset_List_Depreciation_Main,
    FA_Asset_List_Depreciation,
    FA_Asset_List_Depreciation_InMonth,
    MTTB_Users,
    
    MTTB_GLMaster 
)
def extract_account_number(account_id):
    """
    ✅ NEW: ດຶງເລກບັນຊີຈາກ account_id
    ຕົວຢ່າງ: 4601125.0000112 → 4601125
    """
    if not account_id:
        return None
    
    account_str = str(account_id)
    if '.' in account_str:
        return account_str.split('.')[0]
    return account_str


def get_last_day_of_month(year, month):
    """ຫາວັນສຸດທ້າຍຂອງເດືອນ"""
    if month == 12:
        return (datetime(year + 1, 1, 1) - timedelta(days=1)).day
    else:
        return (datetime(year, month + 1, 1) - timedelta(days=1)).day

def find_gl_account(account_number):
    """
    ✅ ຄົ້ນຫາ GLID ຈາກ MTTB_GLMaster
    """
    try:
        if not account_number:
            return None
            
        gl_master = MTTB_GLMaster.objects.filter(
            gl_code=account_number
        ).first()
        
        if gl_master:
            return gl_master.glid
        return None
        
    except Exception as e:
        print(f"Error finding GL account for {account_number}: {str(e)}")
        return None
    

# def create_journal_entry_data(asset, accounting_method, depreciation_amount, current_count, total_months):
#     """
#     ✅ ສ້າງຂໍ້ມູນສຳລັບ Journal Entry
#     """
#     try:
#         current_date = timezone.now()
        
     
#         reference_no = f"AS-ARD-{current_date.strftime('%Y%m%d')}-{getattr(asset, 'asset_code', None) or getattr(asset, 'asset_list_code', None) or asset.asset_list_id}"
        
        
#         debit_account_number = extract_account_number(accounting_method.debit_account_id)
#         credit_account_number = extract_account_number(accounting_method.credit_account_id)
        
#         debit_glid = find_gl_account(debit_account_number)
#         credit_glid = find_gl_account(credit_account_number)
        
#         # ສ້າງ Additional Text
#         addl_sub_text = f"ຫັກຄ່າເສື່ອມລາຄາ {asset.asset_spec or 'N/A'} ຄັ້ງທີ່ {current_count} ຈາກ {total_months}"
        
#         # ສ້າງຂໍ້ມູນ Journal Entry
#         journal_data = {
#             "Reference_No": reference_no,
#             "Ccy_cd": asset.asset_currency or "",  
#             "Txn_code": "ARD", 
#             "Value_date": current_date.date().isoformat(),
#             "Addl_text": "ຫັກຄ່າເສື່ອມລາຄາ",
#             "fin_cycle": str(current_date.year),
#             "module_id": "AS",
#             "Period_code": current_date.strftime('%Y%m'),
#             "entries": [
#                 {
#                     "Account": debit_glid,
#                     "Account_no": str(accounting_method.debit_account_id),
#                     "Amount": float(depreciation_amount),
#                     "Dr_cr": "D",
#                     "Addl_sub_text": addl_sub_text,
#                     "Ac_relatives": str(asset.asset_list_id),
#                 },
#                 {
#                     "Account": credit_glid,
#                     "Account_no": str(accounting_method.credit_account_id),
#                     "Amount": float(depreciation_amount),
#                     "Dr_cr": "C",
#                     "Addl_sub_text": addl_sub_text,
#                     "Ac_relatives": str(asset.asset_list_id),
#                 }
#             ]
#         }
        
#         return {
#             'success': True,
#             'journal_data': journal_data,
#             'validation': {
#                 'debit_account_number': debit_account_number,
#                 'credit_account_number': credit_account_number,
#                 'debit_glid': debit_glid,
#                 'credit_glid': credit_glid,
#                 'debit_found': debit_glid is not None,
#                 'credit_found': credit_glid is not None
#             }
#         }
        
#     except Exception as e:
#         return {
#             'success': False,
#             'error': f"Create journal data error: {str(e)}"
#         }
# def create_journal_entry_data(asset, accounting_method, depreciation_amount, current_count, total_months):
#     """
#     ✅ ສ້າງຂໍ້ມູນສຳລັບ Journal Entry
#     """
#     try:
#         current_date = timezone.now()
        
       
#         today_start = current_date.replace(hour=0, minute=0, second=0, microsecond=0)
#         today_end = current_date.replace(hour=23, minute=59, second=59, microsecond=999999)
        
       
#         daily_count = DETB_JRNL_LOG_MASTER.objects.filter(
#             module_id="AS",
#             Maker_DT_Stamp__range=[today_start, today_end]  
#         ).count()
        
      
#         sequence_number = daily_count + 1
        
       
#         reference_no = f"AS-ARD-{current_date.strftime('%Y%m%d')}-{sequence_number:04d}"
        
     
#         debit_account_number = extract_account_number(accounting_method.debit_account_id)
#         credit_account_number = extract_account_number(accounting_method.credit_account_id)
        
#         debit_glid = find_gl_account(debit_account_number)
#         credit_glid = find_gl_account(credit_account_number)
        
      
#         addl_sub_text = f"ຫັກຄ່າເສື່ອມລາຄາ {asset.asset_spec or 'N/A'} ຄັ້ງທີ່ {current_count} ຈາກ {total_months}"
        
      
#         journal_data = {
#             "Reference_No": reference_no,
#             "Ccy_cd": asset.asset_currency or "", 
#             "Txn_code": "ARD", 
#             "Value_date": current_date.date().isoformat(),
#             "Addl_text": "ຫັກຄ່າເສື່ອມລາຄາ",
#             "fin_cycle": str(current_date.year),
#             "module_id": "AS",
#             "Period_code": current_date.strftime('%Y%m'),
#             "entries": [
#                 {
#                     "Account": debit_glid,
#                     "Account_no": str(accounting_method.debit_account_id),
#                     "Amount": float(depreciation_amount),
#                     "Dr_cr": "D",
#                     "Addl_sub_text": addl_sub_text,
#                     "Ac_relatives": str(asset.asset_list_id),
#                 },
#                 {
#                     "Account": credit_glid,
#                     "Account_no": str(accounting_method.credit_account_id),
#                     "Amount": float(depreciation_amount),
#                     "Dr_cr": "C",
#                     "Addl_sub_text": addl_sub_text,
#                     "Ac_relatives": str(asset.asset_list_id),
#                 }
#             ]
#         }
        
#         return {
#             'success': True,
#             'journal_data': journal_data,
#             'validation': {
#                 'debit_account_number': debit_account_number,
#                 'credit_account_number': credit_account_number,
#                 'debit_glid': debit_glid,
#                 'credit_glid': credit_glid,
#                 'debit_found': debit_glid is not None,
#                 'credit_found': credit_glid is not None,
#                 'daily_sequence': sequence_number 
#             }
#         }
        
#     except Exception as e:
#         return {
#             'success': False,
#             'error': f"Create journal data error: {str(e)}"
#         }
import datetime
from django.utils import timezone
from decimal import Decimal

import datetime
from django.utils import timezone
from decimal import Decimal

import datetime
from django.utils import timezone
from decimal import Decimal

def create_journal_entry_data(asset, accounting_method, depreciation_amount, current_count, total_months):
    """
    ✅ ສ້າງຂໍ້ມູນສຳລັບ Journal Entry
    """
    try:
        current_date = timezone.now()
        
        # ✅ ນັບຈຳນວນ records ໃນມື້ດຽວກັນສຳລັບ module_id ດຽວກັນກ່ອນ
        today_start = current_date.replace(hour=0, minute=0, second=0, microsecond=0)
        today_end = current_date.replace(hour=23, minute=59, second=59, microsecond=999999)
        
        # ນັບຈຳນວນ records ທີ່ມີ module_id = "AS" ໃນມື້ນີ້
        daily_count = DETB_JRNL_LOG_MASTER.objects.filter(
            module_id="AS",
            Maker_DT_Stamp__range=[today_start, today_end]
        ).count()
        
        # ເພີ່ມ 1 ສຳລັບ record ໃໝ່ນີ້
        sequence_number = daily_count + 1
        
        # ✅ ສ້າງ reference_no
        reference_no = f"AS-ARD-{current_date.strftime('%Y%m%d')}-{sequence_number:04d}"
        
        # ✅ Debug: ກວດສອບ data types
        print(f"🔍 DEBUG asset.asset_list_id type: {type(asset.asset_list_id)}, value: {asset.asset_list_id}")
        print(f"🔍 DEBUG asset.asset_spec type: {type(asset.asset_spec)}, value: {asset.asset_spec}")
        print(f"🔍 DEBUG current_count type: {type(current_count)}, value: {current_count}")
        print(f"🔍 DEBUG total_months type: {type(total_months)}, value: {total_months}")
        
        # ເອົາສ່ວນທີ່ເຫຼືອແບບເກົ່າ
        debit_account_number = extract_account_number(accounting_method.debit_account_id)
        credit_account_number = extract_account_number(accounting_method.credit_account_id)
        
        debit_glid = find_gl_account(debit_account_number)
        credit_glid = find_gl_account(credit_account_number)
        
        # ✅ ຄິດໄລ່ Amount ຕາມເງື່ອນໄຂ
        try:
            asset_data = FA_Asset_Lists.objects.get(asset_list_id=asset.asset_list_id)
            c_dpac = int(asset_data.C_dpac or 0)
            asset_useful_life = int(asset_data.asset_useful_life or 0)
            
            # ຄຳນວນເດືອນທັງໝົດ
            total_depreciation_months = asset_useful_life * 12
            
            # ✅ ດຶງມູນຄ່າທີ່ຫັກຄ່າເສື່ອມຈິງຈາກ FA_Asset_List_Depreciation
            try:
                depreciation_record = FA_Asset_List_Depreciation.objects.filter(
                    asset_list_id=asset.asset_list_id,
                    dpca_date=asset_data.asset_latest_date_dpca
                ).order_by('-dpca_date').first()
                
                if depreciation_record and depreciation_record.dpca_value:
                    final_amount = float(depreciation_record.dpca_value)
                    print(f"🔍 DEBUG real depreciation amount: {final_amount}")
                else:
                    final_amount = float(depreciation_amount)
                    print(f"🔍 DEBUG no real depreciation amount found, using default: {final_amount}")
            except Exception as dep_error:
                print(f"❌ Depreciation record error: {dep_error}")
                final_amount = float(depreciation_amount)
            
            # ✅ ກຳນົດ start_date ແລະ end_date ໂດຍອີງຕາມ C_dpac
            end_date = current_date  # ໃຊ້ວັນທີປັດຈຸບັນເປັນ end_date
            if c_dpac == 0:
                # ຖ້າ C_dpac == 0, ໃຊ້ dpca_start_date ເປັນ start_date
                start_date = asset_data.dpca_start_date or current_date
            else:
                # ຖ້າ C_dpac != 0, ໃຊ້ asset_latest_date_dpca ເປັນ start_date
                start_date = asset_data.asset_latest_date_dpca or current_date
            
            # ຮູບແບບເດືອນ/ປີ
            start_date_str = start_date.strftime('%m/%Y')
            end_date_str = end_date.strftime('%m/%Y')
            
        except FA_Asset_Lists.DoesNotExist:
            final_amount = float(depreciation_amount)
            c_dpac = 0
            total_depreciation_months = 0
            start_date_str = current_date.strftime('%m/%Y')
            end_date_str = current_date.strftime('%m/%Y')
        except Exception as calc_error:
            print(f"❌ Calc error: {calc_error}")
            final_amount = float(depreciation_amount)
            c_dpac = 0
            total_depreciation_months = 0
            start_date_str = current_date.strftime('%m/%Y')
            end_date_str = current_date.strftime('%m/%Y')
        
        # ✅ ແປງທຸກຄ່າເປັນ string ກ່ອນໃຊ້
        asset_spec_str = str(asset.asset_spec) if asset.asset_spec is not None else 'N/A'
        asset_list_id_str = str(asset.asset_list_id) if asset.asset_list_id is not None else ''
        asset_currency_str = str(asset.asset_currency) if asset.asset_currency is not None else ''
        debit_account_str = str(accounting_method.debit_account_id) if accounting_method.debit_account_id is not None else ''
        credit_account_str = str(accounting_method.credit_account_id) if accounting_method.credit_account_id is not None else ''
        
        # ✅ ສ້າງ Addl_sub_text ໂດຍໃສ່ມູນຄ່າ final_amount
        addl_sub_text = f"ຫັກຄ່າຫຼູ້ຍຫຽ້ນ {asset_list_id_str} {asset_spec_str} ມູນຄ່າ {final_amount:,.2f} ເດືອນທີ່ {start_date_str} ຫາ {end_date_str}"
        
        print(f"🔍 DEBUG addl_sub_text: {addl_sub_text}")
        
        journal_data = {
            "Reference_No": reference_no,
            "Ccy_cd": asset_currency_str,  
            "Txn_code": "ARD", 
            "Value_date": current_date.date().isoformat(),
            "Addl_text": "ຫັກຄ່າຫຼູ້ຍຫຽ້ນ",
            "fin_cycle": str(current_date.year),
            "module_id": "AS",
            "Period_code": current_date.strftime('%Y%m'),
            "entries": [
                {
                    "Account": debit_glid,
                    "Account_no": debit_account_str,
                    "Amount": final_amount,
                    "Dr_cr": "D",
                    "Addl_sub_text": addl_sub_text,
                    "Ac_relatives": asset_list_id_str,
                },
                {
                    "Account": credit_glid,
                    "Account_no": credit_account_str,
                    "Amount": final_amount,
                    "Dr_cr": "C",
                    "Addl_sub_text": addl_sub_text,
                    "Ac_relatives": asset_list_id_str,
                }
            ]
        }
        
        return {
            'success': True,
            'journal_data': journal_data,
            'validation': {
                'debit_account_number': debit_account_number,
                'credit_account_number': credit_account_number,
                'debit_glid': debit_glid,
                'credit_glid': credit_glid,
                'debit_found': debit_glid is not None,
                'credit_found': credit_glid is not None,
                'c_dpac': c_dpac if 'c_dpac' in locals() else 0,
                'total_depreciation_months': total_depreciation_months if 'total_depreciation_months' in locals() else 0,
                'amount_used': final_amount,
                'amount_type': 'real_depreciation',
                'start_date': start_date_str,
                'end_date': end_date_str
            }
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Create journal data error: {str(e)}"
        }
def find_related_journal_entries(asset_list_id):
    """
    ✅ MODIFIED: ຄົ້ນຫາ Journal entries ໂດຍໃຊ້ asset_list_id ໃນ Ac_relatives
    ເງື່ອນໄຂ: Auth_Status = 'U' ແລະ Dr_cr = 'D'
    """
    try:
        # Import DETB_JRNL_LOG model
        try:
            from .models import DETB_JRNL_LOG
            print(f"✅ [DEBUG] Successfully imported DETB_JRNL_LOG")
        except ImportError:
            try:
                from .models import SAMCSYS_detb_jrnl_log as DETB_JRNL_LOG
                print(f"✅ [DEBUG] Successfully imported SAMCSYS_detb_jrnl_log")
            except ImportError:
                print(f"❌ [DEBUG] Cannot import any DETB_JRNL_LOG model")
                return {
                    'success': False,
                    'error': 'DETB_JRNL_LOG model not found',
                    'reference_numbers': []
                }
        
        print(f"🔍 [DEBUG] ຄົ້ນຫາ Journal entries ສຳລັບ asset_list_id: {asset_list_id}")
        
        # ກວດສອບຂໍ້ມູນທີ່ມີຢູ່ກ່ອນ
        total_count = DETB_JRNL_LOG.objects.count()
        target_count = DETB_JRNL_LOG.objects.filter(Auth_Status='U', Dr_cr='D').count()
        print(f"📊 [DEBUG] Total DETB_JRNL_LOG records: {total_count}")
        print(f"📊 [DEBUG] Records with Auth_Status='U' and Dr_cr='D': {target_count}")
        
        # ✅ ຄົ້ນຫາໂດຍກົງໃນ Ac_relatives field ຕາມທີ່ລະບຸ
        print(f"🔎 [DEBUG] Searching for asset_list_id '{asset_list_id}' in Ac_relatives...")
        
        # ✅ ຄົ້ນຫາສະເພາະ Auth_Status='U' ແລະ Dr_cr='D'
        journal_entries = DETB_JRNL_LOG.objects.filter(
            Ac_relatives__icontains=str(asset_list_id),
            Auth_Status='U',  # ✅ ສະເພາະ 'U' ເທົ່ານັ້ນ
            Dr_cr='D'        # ✅ ສະເພາະ 'D' ເທົ່ານັ້ນ
        ).values('Reference_No', 'Ac_relatives', 'JRNLLog_id', 'Auth_Status')
        
        journal_entries_list = list(journal_entries)
        print(f"📊 [DEBUG] Found {len(journal_entries_list)} matching entries (Auth_Status='U' and Dr_cr='D')")
        
        # ເກັບ Reference_No ທີ່ບໍ່ຊ້ຳກັນ
        reference_numbers = []
        for entry in journal_entries_list:
            ref_no = entry['Reference_No']
            if ref_no not in reference_numbers:
                reference_numbers.append(ref_no)
                print(f"📋 [DEBUG] Added Reference_No: {ref_no} (Ac_relatives: {entry['Ac_relatives']}, JRNLLog_id: {entry['JRNLLog_id']})")
        
        print(f"✅ [DEBUG] Final result: {len(reference_numbers)} unique journal entries")
        
        return {
            'success': True,
            'asset_list_id': asset_list_id,
            'total_entries': len(reference_numbers),
            'reference_numbers': reference_numbers,
            'debug_info': {
                'total_records': total_count,
                'target_condition_records': target_count,
                'found_matches': journal_entries_list,
                'search_term': str(asset_list_id)
            }
        }
        
    except Exception as e:
        print(f"💥 [DEBUG] Error finding journal entries: {str(e)}")
        import traceback
        traceback.print_exc()
        return {
            'success': False,
            'error': f"Find journal entries error: {str(e)}",
            'reference_numbers': []
        }

def auto_approve_related_journals(asset_list_id, request=None):
    """
    ✅ ENHANCED: ຄົ້ນຫາ + approve ດ້ວຍ detailed error logging
    """
    try:
        print(f"🔍 Auto approving journals for asset: {asset_list_id}")
        
        # Import DETB_JRNL_LOG
        try:
            from .models import DETB_JRNL_LOG
        except ImportError:
            try:
                from .models import DETB_JRNL_LOG_MASTER as DETB_JRNL_LOG
            except ImportError:
                return {
                    'success': False,
                    'error': 'DETB_JRNL_LOG model not found',
                    'approved_count': 0,
                    'reference_numbers': []
                }
        
        # ✅ ຄົ້ນຫາ journal entries
        journal_entries = DETB_JRNL_LOG.objects.filter(
            Ac_relatives__icontains=str(asset_list_id),
            Auth_Status='U',
            Dr_cr='D'
        ).values_list('Reference_No', flat=True).distinct()
        
        reference_numbers = list(journal_entries)
        print(f"📋 Found {len(reference_numbers)} reference numbers: {reference_numbers}")
        
        if not reference_numbers:
            return {
                'success': True,
                'message': f'ບໍ່ມີ journal entries ທີ່ຕ້ອງ approve ສຳລັບ asset {asset_list_id}',
                'approved_count': 0,
                'reference_numbers': [],
                'failed_count': 0
            }
        
        # ✅ Import ແລະ ເອີ້ນ approve_all ດ້ວຍ detailed logging
        try:
            from SAMCSYS.views import JRNLLogViewSet
            
            # ສ້າງ mock request
            if not request:
                from unittest.mock import Mock
                from .models import MTTB_Users
                
                mock_request = Mock()
                try:
                    user = MTTB_Users.objects.first()
                    mock_request.user = user
                    print(f"👤 Using user: {user.user_id if user else 'None'}")
                except:
                    mock_request.user = None
                    print(f"⚠️ No user found")
                mock_request.method = 'POST'
                request = mock_request
            
            # ✅ เรียก approve_all สำหรับแต่ละ Reference_No
            approved_count = 0
            failed_count = 0
            approval_results = []
            
            for ref_no in reference_numbers:
                try:
                    print(f"📝 ກຳລັງ approve Reference_No: {ref_no}")
                    
                    # ✅ ກວດສອບ journal details ກ່ອນ approve
                    check_result = check_journal_details(ref_no)
                    print(f"🔍 Journal check result: {check_result}")
                    
                    if not check_result.get('can_approve', False):
                        print(f"❌ Cannot approve {ref_no}: {check_result.get('issues', [])}")
                        failed_count += 1
                        approval_results.append({
                            'reference_no': ref_no,
                            'status': 'error',
                            'message': f"Pre-check failed: {check_result.get('issues', ['Unknown issue'])}",
                            'check_details': check_result
                        })
                        continue
                    
                    # ✅ ເຕຍຍມ request data
                    request.data = {'Reference_No': ref_no}
                    
                    # ✅ ເອີ້ນ approve_all function
                    viewset = JRNLLogViewSet()
                    viewset.request = request
                    viewset.format_kwarg = None
                    
                    print(f"📞 Calling approve_all for {ref_no}...")
                    response = viewset.approve_all(request)
                    
                    print(f"📨 Response: status={response.status_code}")
                    if hasattr(response, 'data'):
                        print(f"📨 Response data: {response.data}")
                    
                    if response.status_code in [200, 201]:
                        approved_count += 1
                        approval_results.append({
                            'reference_no': ref_no,
                            'status': 'success',
                            'message': 'Approved successfully',
                            'response_status': response.status_code,
                            'response_data': getattr(response, 'data', None)
                        })
                        print(f"✅ Approved: {ref_no}")
                    else:
                        failed_count += 1
                        error_message = 'Approval failed'
                        if hasattr(response, 'data') and response.data:
                            if isinstance(response.data, dict) and 'error' in response.data:
                                error_message = response.data['error']
                            elif isinstance(response.data, dict) and 'detail' in response.data:
                                error_message = response.data['detail']
                            else:
                                error_message = str(response.data)
                        
                        approval_results.append({
                            'reference_no': ref_no,
                            'status': 'error',
                            'message': error_message,
                            'response_status': response.status_code,
                            'response_data': getattr(response, 'data', None),
                            'check_details': check_result
                        })
                        print(f"❌ Failed: {ref_no} - {error_message}")
                        
                except Exception as approve_error:
                    failed_count += 1
                    error_msg = str(approve_error)
                    approval_results.append({
                        'reference_no': ref_no,
                        'status': 'error',
                        'message': error_msg,
                        'exception': type(approve_error).__name__
                    })
                    print(f"💥 Exception: {ref_no} - {error_msg}")
                    import traceback
                    traceback.print_exc()
            
            return {
                'success': True,
                'message': f'ປະມວນຜົນ {len(reference_numbers)} entries: approve ສຳເລັດ {approved_count}, ຜິດພາດ {failed_count}',
                'asset_list_id': asset_list_id,
                'total_processed': len(reference_numbers),
                'approved_count': approved_count,
                'failed_count': failed_count,
                'reference_numbers': reference_numbers,
                'approval_details': approval_results
            }
            
        except ImportError as import_error:
            print(f"⚠️ Cannot import JRNLLogViewSet: {str(import_error)}")
            return {
                'success': False,
                'error': f'Import error: {str(import_error)}',
                'reference_numbers': reference_numbers,
                'approved_count': 0,
                'failed_count': len(reference_numbers)
            }
            
    except Exception as e:
        print(f"💥 Auto approve error: {str(e)}")
        import traceback
        traceback.print_exc()
        return {
            'success': False,
            'error': f"Auto approve error: {str(e)}",
            'approved_count': 0,
            'failed_count': 0
        }


def get_month_name_la(month_num):
    """ຊື່ເດືອນເປັນພາສາລາວ"""
    months = {
        1: 'ມັງກອນ', 2: 'ກຸມພາ', 3: 'ມີນາ', 4: 'ເມສາ',
        5: 'ພຶດສະພາ', 6: 'ມິຖຸນາ', 7: 'ກໍລະກົດ', 8: 'ສິງຫາ',
        9: 'ກັນຍາ', 10: 'ຕຸລາ', 11: 'ພະຈິກ', 12: 'ທັນວາ'
    }
    return months.get(month_num, f'ເດືອນ {month_num}')
def check_journal_details(reference_no):
    """
    🔍 ກວດສອບລາຍລະອຽດ journal entry ກ່ອນ approve
    """
    try:
        # Import models
        try:
            from .models import DETB_JRNL_LOG
        except ImportError:
            from .models import DETB_JRNL_LOG_MASTER as DETB_JRNL_LOG
        
        # ຫາ journal entries
        entries = DETB_JRNL_LOG.objects.filter(Reference_No=reference_no)
        
        if not entries.exists():
            return {"error": f"No entries found for Reference_No: {reference_no}"}
        
        entries_list = list(entries.values())
        
        # ກວດສອບ balance
        from django.db.models import Sum
        totals = entries.aggregate(
            total_lcy_dr=Sum('lcy_dr'),
            total_lcy_cr=Sum('lcy_cr'),
            total_fcy_dr=Sum('fcy_dr'),
            total_fcy_cr=Sum('fcy_cr')
        )
        
        lcy_balanced = abs((totals['total_lcy_dr'] or 0) - (totals['total_lcy_cr'] or 0)) < 0.01
        fcy_balanced = abs((totals['total_fcy_dr'] or 0) - (totals['total_fcy_cr'] or 0)) < 0.01
        
        # ກວດສອບ required fields
        issues = []
        for entry in entries:
            if not entry.Account_id:
                issues.append(f"JRNLLog_id {entry.JRNLLog_id}: Missing Account_id")
            if not entry.Fcy_Amount:
                issues.append(f"JRNLLog_id {entry.JRNLLog_id}: Missing Fcy_Amount")
            if entry.Auth_Status not in ['U']:
                issues.append(f"JRNLLog_id {entry.JRNLLog_id}: Auth_Status is {entry.Auth_Status}, should be U")
        
        return {
            'success': True,
            'reference_no': reference_no,
            'entry_count': entries.count(),
            'entries': entries_list,
            'balance_check': {
                'lcy_balanced': lcy_balanced,
                'fcy_balanced': fcy_balanced,
                'totals': totals
            },
            'issues': issues,
            'can_approve': len(issues) == 0 and lcy_balanced and fcy_balanced
        }
        
    except Exception as e:
        return {"error": f"Check journal details error: {str(e)}"}


def get_current_user_id():
    """ຫາ user_id ປັດຈຸບັນ"""
    try:
        first_user = MTTB_Users.objects.first()
        return first_user.user_id if first_user else None
    except Exception as e:
        print(f"Get user error: {str(e)}")
        return None
def process_bulk_depreciation_with_journal(mapping_ids, check_only=False, user_id=None, create_journal=True, request=None):
    """
    ✅ MAIN FUNCTION: Bulk processing ພ້ອມ Journal Entry ແລະ Transaction Rollback
    """
    try:
        print(f"🚀 Starting bulk processing: {len(mapping_ids)} items, create_journal: {create_journal}")
        
        if check_only:
            # ສຳລັບ check_only ບໍ່ຕ້ອງສ້າງ Journal
            print("ℹ️ Check-only mode - no journal creation")
            return process_bulk_depreciation(mapping_ids, check_only=True, user_id=user_id)
        
        results = []
        success_count = 0
        error_count = 0
        journal_success_count = 0
        journal_error_count = 0
        
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            print(f"⚠️ Warning: User ID {user_id} ບໍ່ມີຢູ່ - ຈະດຳເນີນການໂດຍບໍ່ມີ user")
        
        # ສ້າງ InMonth Record
        in_month_record_id = None
        if not check_only:
            temp_result_data = {
                'summary': {
                    'total_items': len(mapping_ids),
                    'success_count': 0,
                    'error_count': 0,
                    'check_only': False,
                    'user_id_used': validated_user_id,
                    'success': True
                },
                'details': [],
                'timestamp': timezone.now().isoformat()
            }
            
            in_month_result = create_depreciation_in_month_record(temp_result_data, validated_user_id)
            if in_month_result['success']:
                in_month_record_id = in_month_result['in_month_record_id']
                print(f"📋 Created InMonth record: {in_month_record_id}")
        
        # ປະມວນຜົນແຕ່ລະລາຍການ
        for i, mapping_id in enumerate(mapping_ids, 1):
            print(f"\n🔄 Processing item {i}/{len(mapping_ids)}: mapping_id={mapping_id}")
            
            try:
                # ✅ ໃຊ້ transaction.atomic() ສຳລັບແຕ່ລະລາຍການ
                with transaction.atomic():
                    # ຫັກຄ່າເສື່ອມລາຄາ
                    process_result = process_monthly_depreciation_with_inmonth(mapping_id, validated_user_id, in_month_record_id)
                    
                    if 'error' in process_result:
                        print(f"❌ Depreciation failed for mapping_id {mapping_id}: {process_result['error']}")
                        results.append({
                            'mapping_id': mapping_id,
                            'status': 'error',
                            'message': process_result['error'],
                            'journal_entry': {'success': False, 'error': 'Depreciation failed'}
                        })
                        error_count += 1
                        journal_error_count += 1
                        continue
                    
                    print(f"✅ Depreciation success for mapping_id {mapping_id}")
                    
                    # ສ້າງ Journal Entry (ຖ້າຕ້ອງການ)
                    journal_result = {'success': False, 'error': 'Journal creation disabled'}
                    
                    if create_journal and request:
                        try:
                            print(f"📝 Creating journal for mapping_id {mapping_id}")
                            
                            accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
                            if accounting_method.asset_list_id:
                                asset = accounting_method.asset_list_id
                            else:
                                asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
                            
                            depreciation_amount = Decimal(str(process_result['depreciation_processed']['monthly_depreciation']))
                            current_count = process_result['depreciation_processed']['month_number']
                            total_months = int(asset.asset_useful_life) * 12
                            
                            journal_data_result = create_journal_entry_data(
                                asset, accounting_method, depreciation_amount, current_count, total_months
                            )
                            
                            if journal_data_result['success']:
                                validation = journal_data_result['validation']
                                if validation['debit_found'] and validation['credit_found']:
                                    journal_result = create_journal_entry_via_api(
                                        journal_data_result['journal_data'], request
                                    )
                                    if journal_result['success']:
                                        journal_success_count += 1
                                        print(f"🎉 Journal success for mapping_id {mapping_id}")
                                    else:
                                        journal_error_count += 1
                                        print(f"❌ Journal API failed for mapping_id {mapping_id}")
                                        # ✅ Rollback ການຫັກຄ່າເສື່ອມເພາະ Journal ຜິດພາດ
                                        raise Exception(f"Journal creation failed: {journal_result['error']}")
                                else:
                                    journal_result = {
                                        'success': False,
                                        'error': 'GL Account not found',
                                        'details': validation
                                    }
                                    journal_error_count += 1
                                    print(f"❌ GL Account not found for mapping_id {mapping_id}")
                                    # ✅ Rollback ການຫັກຄ່າເສື່ອມເພາະ GL Account ບໍ່ພົບ
                                    raise Exception(f"GL Account not found: {validation}")
                            else:
                                journal_result = journal_data_result
                                journal_error_count += 1
                                print(f"❌ Journal data creation failed for mapping_id {mapping_id}")
                                # ✅ Rollback ການຫັກຄ່າເສື່ອມເພາະສ້າງ Journal Data ບໍ່ໄດ້
                                raise Exception(f"Journal data creation failed: {journal_data_result['error']}")
                                
                        except Exception as journal_error:
                            print(f"💥 Journal error for mapping_id {mapping_id}: {str(journal_error)}")
                            journal_result = {
                                'success': False,
                                'error': f"Journal creation error: {str(journal_error)}"
                            }
                            journal_error_count += 1
                            # ✅ Re-raise ເພື່ອ rollback transaction
                            raise journal_error
                            
                    elif create_journal and not request:
                        journal_result = {
                            'success': False,
                            'error': 'Request object required for journal creation'
                        }
                        journal_error_count += 1
                        print(f"⚠️ No request object for mapping_id {mapping_id}")
                        # ✅ Rollback ເພາะບໍ່ມີ request object
                        if create_journal:  # ຖ້າຕ້ອງການ journal ແຕ່ບໍ່ມີ request ແມ່ນຜິດພາດ
                            raise Exception("Request object required for journal creation")
                    
                    # ✅ ຖ້າຮອດຈຸດນີ້ແມ່ນທຸກຢ່າງສຳເລັດ
                    # ບັນທຶກຜົນລັບ
                    results.append({
                        'mapping_id': mapping_id,
                        'status': 'success',
                        'message': f"ຫັກເດືອນທີ່ {process_result['depreciation_processed']['month_number']} ສຳເລັດ",
                        'depreciation_processed': process_result['depreciation_processed'],
                        'history_records': process_result.get('history_records', {}),
                        'journal_entry': journal_result
                    })
                    success_count += 1
                    print(f"🎯 Complete success for mapping_id {mapping_id}")
                    
            except Exception as e:
                # ✅ Transaction rollback ເກີດຂຶ້ນອັດຕະໂນມັດ
                print(f"💥 Transaction rolled back for mapping_id {mapping_id}: {str(e)}")
                results.append({
                    'mapping_id': mapping_id,
                    'status': 'error',
                    'message': f"Processing error (rolled back): {str(e)}",
                    'journal_entry': {'success': False, 'error': 'Transaction rolled back'}
                })
                error_count += 1
                journal_error_count += 1
        
        # ອັບເດດ InMonth Record
        if not check_only and in_month_record_id:
            try:
                in_month_record = FA_Asset_List_Depreciation_InMonth.objects.get(aldim_id=in_month_record_id)
                
                total_depreciation = Decimal('0.00')
                for detail in results:
                    if detail['status'] == 'success' and 'depreciation_processed' in detail:
                        total_depreciation += Decimal(str(detail['depreciation_processed']['monthly_depreciation']))
                
                in_month_record.C_dpca = str(success_count)
                in_month_record.dpca_value = total_depreciation.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                in_month_record.dpca_status = 'SUCCESS' if error_count == 0 else 'PARTIAL' if success_count > 0 else 'FAILED'
                in_month_record.save()
                
                print(f"📋 Updated InMonth record: {in_month_record_id}")
                
            except Exception as e:
                print(f"⚠️ Warning: ອັບເດດ InMonth record ຜິດພາດ: {str(e)}")
        
        final_result = {
            'summary': {
                'total_items': len(mapping_ids),
                'success_count': success_count,
                'error_count': error_count,
                'check_only': check_only,
                'user_id_used': validated_user_id,
                'in_month_record_id': in_month_record_id,
                'journal_enabled': create_journal,
                'journal_success_count': journal_success_count,
                'journal_error_count': journal_error_count,
                'success_rate': f"{(success_count/len(mapping_ids)*100):.1f}%" if mapping_ids else "0%",
                'journal_success_rate': f"{(journal_success_count/success_count*100):.1f}%" if success_count > 0 else "0%"
            },
            'details': results,
            'in_month_record': {
                'success': True,
                'in_month_record_id': in_month_record_id,
                'user_id_used': validated_user_id
            } if in_month_record_id else None
        }
        
        print(f"🏁 Bulk processing complete: {success_count}/{len(mapping_ids)} success, {journal_success_count} journals created")
        return final_result
        
    except Exception as e:
        print(f"💥 Bulk processing fatal error: {str(e)}")
        return {"error": f"Bulk processing with journal error: {str(e)}"}

@csrf_exempt
def calculate_depreciation_api_with_journal(request):
    """
    ✅ API ຫຼັກທີ່ຮອງຮັບ Journal Entry
    
    ເພີ່ມ parameters ໃໝ່:
    - create_journal: true/false (default: false)
    
    Actions ທີ່ຮອງຮັບ Journal:
    - process: ຫັກລາຍການດຽວພ້ອມ Journal
    - bulk_process: ຫັກຫຼາຍລາຍການພ້ອມ Journal
    - bulk_process_all: ຫັກທຸກລາຍການພ້ອມ Journal
    - get_monthly_due: ໃໝ່! ດຶງລາຍການທີ່ຕ້ອງຫັກໃນເດືອນ
    """
    try:
        if request.method not in ['POST', 'GET']:
            return JsonResponse({'error': 'ໃຊ້ POST ຫຼື GET method'}, status=400)
        
        if request.method == 'POST':
            if not request.body:
                return JsonResponse({'error': 'ບໍ່ມີ request body'}, status=400)
            
            try:
                data = json.loads(request.body)
            except json.JSONDecodeError as e:
                return JsonResponse({'error': f'JSON error: {str(e)}'}, status=400)
            
            mapping_id = data.get('mapping_id')
            mapping_ids = data.get('mapping_ids', [])
            user_id = data.get('user_id')
            action = data.get('action', 'calculate')
            date = data.get('date')
            create_journal = data.get('create_journal', False)  # ✅ NEW parameter
            target_month = data.get('target_month')  # ✅ NEW
            target_year = data.get('target_year')    # ✅ NEW
        else:  # GET
            mapping_id = request.GET.get('mapping_id')
            mapping_ids_str = request.GET.get('mapping_ids', '')
            mapping_ids = [int(x) for x in mapping_ids_str.split(',') if x] if mapping_ids_str else []
            user_id = request.GET.get('user_id')
            action = request.GET.get('action', 'calculate')
            date = request.GET.get('date')
            create_journal = request.GET.get('create_journal', 'false').lower() == 'true'  # ✅ NEW
            target_month = request.GET.get('target_month')  # ✅ NEW
            target_year = request.GET.get('target_year')    # ✅ NEW
        
        # Actions ທີ່ຮອງຮັບ Journal Entry
        journal_supported_actions = ['process', 'bulk_process', 'bulk_process_all']
        
        if action == 'process':
            if not mapping_id:
                return JsonResponse({'error': 'ໃສ່ mapping_id'}, status=400)
            
            if create_journal:
                result = process_monthly_depreciation_with_journal(
                    mapping_id, user_id, date, create_journal=True, request=request
                )
            else:
                result = process_monthly_depreciation(mapping_id, user_id, date)
                
        elif action == 'bulk_process':
            if not mapping_ids:
                return JsonResponse({'error': 'ໃສ່ mapping_ids'}, status=400)
            
            if create_journal:
                with transaction.atomic():
                    result = process_bulk_depreciation_with_journal(
                        mapping_ids, check_only=False, user_id=user_id, 
                        create_journal=True, request=request
                    )
            else:
                with transaction.atomic():
                    result = process_bulk_depreciation(mapping_ids, check_only=False, user_id=user_id)
                    
        elif action == 'bulk_process_all':
            depreciable_assets = get_depreciable_assets()
            if 'error' in depreciable_assets:
                return JsonResponse(depreciable_assets, status=400)
            
            available_ids = [item['mapping_id'] for item in depreciable_assets['depreciable_items']]
            
            if not available_ids:
                return JsonResponse({
                    'success': True,
                    'message': 'ບໍ່ມີລາຍການທີ່ຕ້ອງຫັກ',
                    'data': {'summary': {'total_items': 0, 'success_count': 0, 'error_count': 0}, 'details': []}
                })
            
            if create_journal:
                with transaction.atomic():
                    result = process_bulk_depreciation_with_journal(
                        available_ids, check_only=False, user_id=user_id,
                        create_journal=True, request=request
                    )
            else:
                with transaction.atomic():
                    result = process_bulk_depreciation(available_ids, check_only=False, user_id=user_id)
                    
        elif action == 'get_monthly_due':
            # ✅ NEW ACTION: ດຶງລາຍການທີ່ຕ້ອງຫັກໃນເດືອນ
            # ແປງເປັນ int ຖ້າມີ
            if target_month:
                target_month = int(target_month)
            if target_year:
                target_year = int(target_year)
            
            result = get_depreciation_due_this_month(target_month, target_year)
            
        else:
            # ໃຊ້ API ເດີມສຳລັບ actions ອື່ນໆ
            return calculate_depreciation_api(request)
        
        if isinstance(result, dict) and 'error' in result:
            return JsonResponse(result, status=400)
        
        return JsonResponse({
            'success': True,
            'action': action,
            'data': result,
            'journal_enabled': create_journal if action in journal_supported_actions else False,
            'timestamp': timezone.now().isoformat()
        })
        
    except Exception as e:
        import traceback
        error_details = {
            'error': str(e),
            'type': type(e).__name__,
            'traceback': traceback.format_exc()
        }
        print("API with Journal Error Details:", error_details)
        return JsonResponse(error_details, status=500)
    

# def process_bulk_depreciation_catch_up(mapping_id, user_id=None, current_date=None):
#     """ຫັກຄ່າເສື່ອມລາຄາແບບລວມ - ຈາກເລີ່ມຕົ້ນຮອດເດືອນປະຈຸບັນ"""
#     try:
#         # ກວດສອບສະຖານະກ່ອນ
#         calc_result = calculate_depreciation_schedule(mapping_id)
#         if 'error' in calc_result:
#             return calc_result
        
#         # ດຶງຂໍ້ມູນ asset
#         accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
#         if accounting_method.asset_list_id:
#             asset = accounting_method.asset_list_id
#         else:
#             asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
        
#         # ✅ ຂໍ້ມູນພື້ນຖານ
#         start_date = asset.dpca_start_date
#         useful_life = int(asset.asset_useful_life)
#         total_months = useful_life * 12
#         end_date = start_date + relativedelta(years=useful_life) - timedelta(days=1)
        
#         # ກຳນົດ current_date
#         if current_date:
#             target_date = datetime.strptime(current_date, '%Y-%m-%d').date()
#         else:
#             target_date = datetime.now().date()
        
#         # ✅ ຄິດໄລຍະເວລາທີ່ຕ້ອງຫັກ
#         actual_end_date = min(end_date, target_date)
        
#         # ຄິດຈຳນວນເດືອນທີ່ຕ້ອງຫັກ
#         months_to_process = []
#         current_month_start = start_date
#         month_counter = 1
        
#         while current_month_start <= actual_end_date:
#             # ວັນເລີ່ມຕົ້ນແລະສິ້ນສຸດຂອງເດືອນ
#             if month_counter == 1:
#                 month_actual_start = start_date
#                 month_end = datetime(start_date.year, start_date.month, 
#                                    get_last_day_of_month(start_date.year, start_date.month)).date()
#             else:
#                 month_actual_start = datetime(current_month_start.year, current_month_start.month, 1).date()
#                 month_end = datetime(current_month_start.year, current_month_start.month,
#                                    get_last_day_of_month(current_month_start.year, current_month_start.month)).date()
            
#             if month_end > actual_end_date:
#                 month_end = actual_end_date
            
#             months_to_process.append({
#                 'month_number': month_counter,
#                 'start_date': month_actual_start,
#                 'end_date': month_end,
#                 'year_month': f"{current_month_start.year}-{current_month_start.month:02d}"
#             })
            
#             current_month_start = current_month_start + relativedelta(months=1)
#             month_counter += 1
            
#             if month_counter > total_months:
#                 break
        
#         # ✅ ຄິດຄ່າເສື່ອມ
#         asset_value = Decimal(str(asset.asset_value or 0))
#         salvage_value = Decimal(str(asset.asset_salvage_value or 0))
#         depreciable_amount = asset_value - salvage_value
#         old_accumulated = Decimal(str(asset.asset_accu_dpca_value or 0))
        
#         annual_depreciation = depreciable_amount / Decimal(str(useful_life))
#         monthly_depreciation = (annual_depreciation / Decimal('12')).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
        
#         # ຄິດຄ່າເສື່ອມແຕ່ລະເດືອນ
#         monthly_details = []
#         total_depreciation = Decimal('0')
#         is_asset_completed = actual_end_date >= end_date
        
#         for i, month_data in enumerate(months_to_process):
#             month_num = month_data['month_number']
#             month_start = month_data['start_date']
#             month_end = month_data['end_date']
            
#             days_in_period = (month_end - month_start + timedelta(days=1)).days
#             total_days_in_month = get_last_day_of_month(month_start.year, month_start.month)
            
#             is_first_month = (month_num == 1)
#             is_last_month_of_asset = (month_num == total_months) and is_asset_completed
            
#             # ✅ ຄິດຄ່າເສື່ອມຕາມປະເພດງວດ
#             if is_first_month:
#                 month_depreciation = (monthly_depreciation * Decimal(str(days_in_period)) / 
#                                     Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
#                 period_type = "ງວດທຳອິດ"
#                 calculation_note = f"({monthly_depreciation:,.2f} × {days_in_period}) ÷ {total_days_in_month} = {month_depreciation:,.2f}"
                
#             elif is_last_month_of_asset:
#                 remaining_to_depreciate = depreciable_amount - (old_accumulated + total_depreciation)
#                 month_depreciation = remaining_to_depreciate.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
#                 period_type = "ງວດສຸດທ້າຍ (ຄົບອາຍຸ)"
#                 calculation_note = f"ປັບໃຫ້ຄົບ {depreciable_amount:,.0f} ກີບ (ເຫຼືອ {remaining_to_depreciate:,.2f})"
                
#             else:
#                 if days_in_period == total_days_in_month:
#                     month_depreciation = monthly_depreciation
#                     period_type = "ງວດປົກກະຕິ (ເຕັມເດືອນ)"
#                     calculation_note = f"ເຕັມເດືອນ = {monthly_depreciation:,.2f}"
#                 else:
#                     month_depreciation = (monthly_depreciation * Decimal(str(days_in_period)) / 
#                                         Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
#                     period_type = "ງວດປົກກະຕິ (ບາງສ່ວນ)"
#                     calculation_note = f"({monthly_depreciation:,.2f} × {days_in_period}) ÷ {total_days_in_month} = {month_depreciation:,.2f}"
            
#             total_depreciation += month_depreciation
            
#             monthly_details.append({
#                 'month_number': month_num,
#                 'period': f"{month_start.strftime('%d/%m/%Y')} - {month_end.strftime('%d/%m/%Y')}",
#                 'month_year': f"{get_month_name_la(month_start.month)} {month_start.year}",
#                 'days_count': days_in_period,
#                 'total_days_in_month': total_days_in_month,
#                 'period_type': period_type,
#                 'monthly_depreciation': float(month_depreciation),
#                 'calculation_note': calculation_note
#             })
        
#         # ✅ ຄິດຜົນລວມ
#         new_accumulated = old_accumulated + total_depreciation
#         new_remaining = asset_value - new_accumulated
        
#         if new_accumulated > depreciable_amount:
#             excess = new_accumulated - depreciable_amount
#             total_depreciation = total_depreciation - excess
#             new_accumulated = depreciable_amount
#             new_remaining = salvage_value
        
#         months_processed = len(months_to_process)
#         is_fully_depreciated = new_accumulated >= depreciable_amount
        
#         return {
#             'success': True,
#             'bulk_depreciation_processed': {
#                 'processing_period': f"{start_date.strftime('%d/%m/%Y')} - {actual_end_date.strftime('%d/%m/%Y')}",
#                 'months_processed': months_processed,
#                 'total_depreciation': float(total_depreciation),
#                 'old_accumulated': float(old_accumulated),
#                 'new_accumulated': float(new_accumulated),
#                 'remaining_value': float(new_remaining),
#                 'is_asset_completed': is_asset_completed,
#                 'is_fully_depreciated': is_fully_depreciated,
#                 'monthly_breakdown': monthly_details,
#                 'summary_note': f"ຫັກຄ່າເສື່ອມ {months_processed} ເດືອນ, ລວມ {total_depreciation:,.2f} ກີບ"
#             },
#             'updated_status': {
#                 'C_dpac': months_processed,
#                 'total_months': total_months,
#                 'remaining_months': max(0, total_months - months_processed),
#                 'is_completed': is_fully_depreciated or months_processed >= total_months,
#                 'completion_status': "ຫັກຄົບແລ້ວ" if is_fully_depreciated else f"ຫັກແລ້ວ {months_processed}/{total_months} ເດືອນ"
#             }
#         }
        
#     except Exception as e:
#         return {"error": f"Bulk depreciation catch-up error: {str(e)}"}

def auto_reject_related_journals(asset_list_id, reason, user_id, request=None):
    """
    🔴 ຄົ້ນຫາ + reject journal entries ດ້ວຍ detailed logging
    """
    try:
        print(f"🔴 Auto rejecting journals for asset: {asset_list_id}")
        
        # Import DETB_JRNL_LOG
        try:
            from .models import DETB_JRNL_LOG
        except ImportError:
            try:
                from .models import DETB_JRNL_LOG_MASTER as DETB_JRNL_LOG
            except ImportError:
                return {
                    'success': False,
                    'error': 'DETB_JRNL_LOG model not found',
                    'rejected_count': 0,
                    'reference_numbers': []
                }
        
        # ✅ ຄົ້ນຫາ journal entries
        journal_entries = DETB_JRNL_LOG.objects.filter(
            Ac_relatives__icontains=str(asset_list_id),
            Auth_Status='U',
            Dr_cr='D'
        ).values_list('Reference_No', flat=True).distinct()
        
        reference_numbers = list(journal_entries)
        print(f"📋 Found {len(reference_numbers)} reference numbers: {reference_numbers}")
        
        if not reference_numbers:
            return {
                'success': True,
                'message': f'ບໍ່ມີ journal entries ທີ່ຕ້ອງ reject ສຳລັບ asset {asset_list_id}',
                'rejected_count': 0,
                'reference_numbers': []
            }
        
        # ✅ Auto reject ແຕ່ລະ Reference_No
        rejected_count = 0
        current_time = timezone.now()
        
        for ref_no in reference_numbers:
            try:
                print(f"📝 ກຳລັງ reject Reference_No: {ref_no}")
                
                entries_updated = DETB_JRNL_LOG.objects.filter(
                    Reference_No=ref_no,
                    Ac_relatives__icontains=str(asset_list_id),
                    Auth_Status='U'
                ).update(
                    Auth_Status='R',
                    detail=reason,
                    Checker_Id_id=user_id,
                    Checker_DT_Stamp=current_time
                )
                
                if entries_updated > 0:
                    rejected_count += 1
                    print(f"✅ Rejected: {ref_no} ({entries_updated} entries)")
                else:
                    print(f"❌ Failed: {ref_no} - No entries found")
                    
            except Exception as reject_error:
                print(f"💥 Exception: {ref_no} - {str(reject_error)}")
        
        return {
            'success': True,
            'message': f'ປະມວນຜົນ {len(reference_numbers)} entries: reject ສຳເລັດ {rejected_count}',
            'rejected_count': rejected_count,
            'reference_numbers': reference_numbers,
            'reason_applied': reason
        }
        
    except Exception as e:
        print(f"💥 Auto reject error: {str(e)}")
        return {
            'success': False,
            'error': f"Auto reject error: {str(e)}",
            'rejected_count': 0
        }


def update_journal_status_to_pending(asset_list_id, reason, user_id):
    """
    🟡 ອັບເດດສະຖານະ journal entries ເປັນ Pending (P)
    """
    try:
        print(f"🟡 Updating journal status to P for asset: {asset_list_id}")
        
        # Import DETB_JRNL_LOG
        try:
            from .models import DETB_JRNL_LOG
        except ImportError:
            try:
                from .models import DETB_JRNL_LOG_MASTER as DETB_JRNL_LOG
            except ImportError:
                return {
                    'success': False,
                    'error': 'DETB_JRNL_LOG model not found',
                    'updated_count': 0
                }
        
        # ✅ ຄົ້ນຫາແລະອັບເດດ
        journal_entries = DETB_JRNL_LOG.objects.filter(
            Ac_relatives__icontains=str(asset_list_id),
            Auth_Status='U',
            Dr_cr='D'
        )
        
        reference_numbers = list(journal_entries.values_list('Reference_No', flat=True).distinct())
        print(f"📋 Found {len(reference_numbers)} reference numbers: {reference_numbers}")
        
        if not reference_numbers:
            return {
                'success': True,
                'message': f'ບໍ່ມີ journal entries ທີ່ຕ້ອງອັບເດດເປັນ P',
                'updated_count': 0
            }
        
        current_time = timezone.now()
        updated_count = 0
        
        for ref_no in reference_numbers:
            try:
                entries_updated = DETB_JRNL_LOG.objects.filter(
                    Reference_No=ref_no,
                    Ac_relatives__icontains=str(asset_list_id),
                    Auth_Status='U'
                ).update(
                    Auth_Status='P',
                    detail=reason,
                    Checker_Id_id=user_id,
                    Checker_DT_Stamp=current_time
                )
                
                if entries_updated > 0:
                    updated_count += 1
                    print(f"✅ Updated to P: {ref_no} ({entries_updated} entries)")
                    
            except Exception as update_error:
                print(f"💥 Error: {str(update_error)}")
        
        return {
            'success': True,
            'message': f'ອັບເດດ {updated_count} entries ເປັນ Pending ສຳເລັດ',
            'updated_count': updated_count,
            'reference_numbers': reference_numbers
        }
        
    except Exception as e:
        print(f"💥 Update to pending error: {str(e)}")
        return {
            'success': False,
            'error': f"Update to pending error: {str(e)}",
            'updated_count': 0
        }
# ✅ Helper function ສຳລັບທົດສອບ
def test_bulk_depreciation():
    """ຟັງຊັນທົດສອບ bulk depreciation"""
    
    # Test data
    test_cases = [
        {
            'name': 'Case 1: ເລີ່ມ 2023, 3 ປີ, ຕອນນີ້ 2025',
            'start_date': '2023-01-15',
            'useful_life': 3,
            'asset_value': 1000000,
            'salvage_value': 100000,
            'current_date': '2025-08-31'
        },
        {
            'name': 'Case 2: ເລີ່ມ 2024, 5 ປີ, ຕອນນີ້ 2025', 
            'start_date': '2024-03-01',
            'useful_life': 5,
            'asset_value': 2000000,
            'salvage_value': 200000,
            'current_date': '2025-08-31'
        },
        {
            'name': 'Case 3: ເລີ່ມ 2022, 3 ປີ (ຄົບແລ້ວ)',
            'start_date': '2022-06-15', 
            'useful_life': 3,
            'asset_value': 1500000,
            'salvage_value': 150000,
            'current_date': '2025-08-31'
        }
    ]
    
    print("🧪 ການທົດສອບ Bulk Depreciation Function")
    print("=" * 60)
    
    for case in test_cases:
        print(f"\n📋 {case['name']}")
        print(f"   ເລີ່ມ: {case['start_date']}")
        print(f"   ອາຍຸ: {case['useful_life']} ປີ") 
        print(f"   ມູນຄ່າ: {case['asset_value']:,} ກີບ")
        print(f"   Salvage: {case['salvage_value']:,} ກີບ")
        print(f"   ປະຈຸບັນ: {case['current_date']}")
        
        # ຄິດໄລ່ຄ່າພຽງພະບົງ
        depreciable = case['asset_value'] - case['salvage_value']
        annual_dep = depreciable / case['useful_life']
        monthly_dep = annual_dep / 12
        
        print(f"   → ຫັກໄດ້: {depreciable:,} ກີບ")
        print(f"   → ຕໍ່ປີ: {annual_dep:,.0f} ກີບ")
        print(f"   → ຕໍ່ເດືອນ: {monthly_dep:,.2f} ກີບ")
        
        # ຄິດເດືອນທີ່ຄວນຫັກ
        from datetime import datetime
        start = datetime.strptime(case['start_date'], '%Y-%m-%d').date()
        current = datetime.strptime(case['current_date'], '%Y-%m-%d').date()
        end_of_life = start + relativedelta(years=case['useful_life']) - timedelta(days=1)
        
        actual_end = min(end_of_life, current)
        
        print(f"   → ສິ້ນສຸດອາຍຸ: {end_of_life}")
        print(f"   → ຫັກຮອດ: {actual_end}")
        
    return test_cases
def process_bulk_depreciation_catch_up_with_journal(mapping_id, user_id=None, current_date=None, create_journal=False, request=None):
    """ຫັກຄ່າເສື່ອມລາຄາແບບລວມ ພ້ອມສ້າງ Journal Entry"""
    try:
        # ເອີ້ນຟັງຊັນຫັກຄ່າເສື່ອມ
        result = process_bulk_depreciation_catch_up(mapping_id, user_id, current_date)
        
        if not result.get('success'):
            return result
        
        # ຖ້າຕ້ອງການສ້າງ Journal Entry
        if create_journal and result.get('success'):
            depreciation_data = result['bulk_depreciation_processed']
            total_depreciation = depreciation_data['total_depreciation']
            
            if total_depreciation > 0:
                # ດຶງຂໍ້ມູນ asset ສຳລັບ Journal
                accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
                if accounting_method.asset_list_id:
                    asset = accounting_method.asset_list_id
                else:
                    asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
                
                # ສ້າງ Journal Entry
                journal_result = create_journal_entry_data(
                    asset=asset,
                    depreciation_amount=total_depreciation,
                    period_info=f"Catch-up: {depreciation_data['processing_period']} ({depreciation_data['months_processed']} ເດືອນ)",
                    user_id=user_id,
                    request=request,
                    is_bulk_entry=True
                )
                
                # ເພີ່ມຂໍ້ມູນ Journal ເຂົ້າໃນ result
                result['journal_entry'] = journal_result
        
        return result
        
    except Exception as e:
        return {"error": f"Catch-up with journal error: {str(e)}"}


# def process_bulk_depreciation_catch_up(mapping_id, user_id=None, current_date=None):
#     """ຫັກຄ່າເສື່ອມລາຄາແບບລວມ - ຈາກເລີ່ມຕົ້ນຮອດເດືອນປະຈຸບັນ"""
#     try:
#         # ກວດສອບສະຖານະກ່ອນ
#         calc_result = calculate_depreciation_schedule(mapping_id)
#         if 'error' in calc_result:
#             return calc_result
        
#         # ດຶງຂໍ້ມູນ asset
#         accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
#         if accounting_method.asset_list_id:
#             asset = accounting_method.asset_list_id
#         else:
#             asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
        
#         # ✅ ຂໍ້ມູນພື້ນຖານ
#         start_date = asset.dpca_start_date
#         useful_life = int(asset.asset_useful_life)
#         total_months = useful_life * 12
#         end_date = start_date + relativedelta(years=useful_life) - timedelta(days=1)
        
#         # ກຳນົດ current_date
#         if current_date:
#             target_date = datetime.strptime(current_date, '%Y-%m-%d').date()
#         else:
#             target_date = datetime.now().date()
        
#         # ✅ ຄິດໄລຍະເວລາທີ່ຕ້ອງຫັກ
#         # ເລືອກວັນທີ່ທີ່ນ້ອຍກວ່າ: ວັນສິ້ນສຸດອາຍຸການໃຊ້ ຫຼື ວັນທີ່ປະຈຸບັນ
#         actual_end_date = min(end_date, target_date)
        
#         # ຄິດຈຳນວນເດືອນທີ່ຕ້ອງຫັກ
#         months_to_process = []
#         current_month_start = start_date
#         month_counter = 1
        
#         while current_month_start <= actual_end_date:
#             # ວັນເລີ່ມຕົ້ນແລະສິ້ນສຸດຂອງເດືອນ
#             if month_counter == 1:
#                 # ງວດທຳອິດ: ເລີ່ມຈາກວັນທີ່ start_date
#                 month_actual_start = start_date
#                 month_end = datetime(start_date.year, start_date.month, 
#                                    get_last_day_of_month(start_date.year, start_date.month)).date()
#             else:
#                 # ງວດອື່ນໆ: ເລີ່ມວັນທີ່ 1
#                 month_actual_start = datetime(current_month_start.year, current_month_start.month, 1).date()
#                 month_end = datetime(current_month_start.year, current_month_start.month,
#                                    get_last_day_of_month(current_month_start.year, current_month_start.month)).date()
            
#             # ປັບ month_end ຖ້າເກີນ actual_end_date
#             if month_end > actual_end_date:
#                 month_end = actual_end_date
            
#             months_to_process.append({
#                 'month_number': month_counter,
#                 'start_date': month_actual_start,
#                 'end_date': month_end,
#                 'year_month': f"{current_month_start.year}-{current_month_start.month:02d}"
#             })
            
#             # ເລື່ອນໄປເດືອນຕໍ່ໄປ
#             current_month_start = current_month_start + relativedelta(months=1)
#             month_counter += 1
            
#             # ຢຸດຖ້າເກີນອາຍຸການໃຊ້
#             if month_counter > total_months:
#                 break
        
#         # ✅ ຄິດຄ່າເສື່ອມ
#         asset_value = Decimal(str(asset.asset_value or 0))
#         salvage_value = Decimal(str(asset.asset_salvage_value or 0))
#         depreciable_amount = asset_value - salvage_value
#         old_accumulated = Decimal(str(asset.asset_accu_dpca_value or 0))
        
#         # ຄ່າເສື່ອມຕໍ່ປີ ແລະ ຕໍ່ເດືອນ
#         annual_depreciation = depreciable_amount / Decimal(str(useful_life))
#         monthly_depreciation = (annual_depreciation / Decimal('12')).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
        
#         # ຄິດຄ່າເສື່ອມແຕ່ລະເດືອນ
#         monthly_details = []
#         total_depreciation = Decimal('0')
#         is_asset_completed = actual_end_date >= end_date
        
#         for i, month_data in enumerate(months_to_process):
#             month_num = month_data['month_number']
#             month_start = month_data['start_date']
#             month_end = month_data['end_date']
            
#             # ຄິດຈຳນວນວັນ
#             days_in_period = (month_end - month_start + timedelta(days=1)).days
#             total_days_in_month = get_last_day_of_month(month_start.year, month_start.month)
            
#             # ກຳນົດປະເພດງວດ
#             is_first_month = (month_num == 1)
#             is_last_month_of_asset = (month_num == total_months) and is_asset_completed
#             is_current_final_month = (i == len(months_to_process) - 1) and not is_asset_completed
            
#             # ✅ ຄິດຄ່າເສື່ອມຕາມປະເພດງວດ
#             if is_first_month:
#                 # 🎯 ງວດທຳອິດ: pro-rated
#                 month_depreciation = (monthly_depreciation * Decimal(str(days_in_period)) / 
#                                     Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
#                 period_type = "ງວດທຳອິດ"
#                 calculation_note = f"({monthly_depreciation:,.2f} × {days_in_period}) ÷ {total_days_in_month} = {month_depreciation:,.2f}"
                
#             elif is_last_month_of_asset:
#                 # 🎯 ງວດສຸດທ້າຍຂອງຊັບສິນ: ປັບໃຫ້ຄົບ depreciable_amount
#                 remaining_to_depreciate = depreciable_amount - (old_accumulated + total_depreciation)
#                 month_depreciation = remaining_to_depreciate.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
#                 period_type = "ງວດສຸດທ້າຍ (ຄົບອາຍຸ)"
#                 calculation_note = f"ປັບໃຫ້ຄົບ {depreciable_amount:,.0f} ກີບ (ເຫຼືອ {remaining_to_depreciate:,.2f})"
                
#             else:
#                 # 🎯 ງວດປົກກະຕິ: ຫັກຕາມວັນຈິງ
#                 if days_in_period == total_days_in_month:
#                     # ເຕັມເດືອນ
#                     month_depreciation = monthly_depreciation
#                     period_type = "ງວດປົກກະຕິ (ເຕັມເດືອນ)"
#                     calculation_note = f"ເຕັມເດືອນ = {monthly_depreciation:,.2f}"
#                 else:
#                     # ບໍ່ເຕັມເດືອນ (pro-rated)
#                     month_depreciation = (monthly_depreciation * Decimal(str(days_in_period)) / 
#                                         Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
#                     period_type = "ງວດປົກກະຕິ (ບາງສ່ວນ)"
#                     calculation_note = f"({monthly_depreciation:,.2f} × {days_in_period}) ÷ {total_days_in_month} = {month_depreciation:,.2f}"
            
#             total_depreciation += month_depreciation
            
#             monthly_details.append({
#                 'month_number': month_num,
#                 'period': f"{month_start.strftime('%d/%m/%Y')} - {month_end.strftime('%d/%m/%Y')}",
#                 'month_year': f"{get_month_name_la(month_start.month)} {month_start.year}",
#                 'days_count': days_in_period,
#                 'total_days_in_month': total_days_in_month,
#                 'period_type': period_type,
#                 'monthly_depreciation': float(month_depreciation),
#                 'calculation_note': calculation_note
#             })
        
#         # ✅ ຄິດຜົນລວມ
#         new_accumulated = old_accumulated + total_depreciation
#         new_remaining = asset_value - new_accumulated
        
#         # ກວດສອບບໍ່ໃຫ້ເກີນ depreciable_amount
#         if new_accumulated > depreciable_amount:
#             excess = new_accumulated - depreciable_amount
#             total_depreciation = total_depreciation - excess
#             new_accumulated = depreciable_amount
#             new_remaining = salvage_value
        
#         # ✅ ກຳນົດສະຖານະໃໝ່
#         months_processed = len(months_to_process)
#         is_fully_depreciated = new_accumulated >= depreciable_amount
        
#         return {
#             'success': True,
#             'bulk_depreciation_processed': {
#                 'processing_period': f"{start_date.strftime('%d/%m/%Y')} - {actual_end_date.strftime('%d/%m/%Y')}",
#                 'months_processed': months_processed,
#                 'total_depreciation': float(total_depreciation),
#                 'old_accumulated': float(old_accumulated),
#                 'new_accumulated': float(new_accumulated),
#                 'remaining_value': float(new_remaining),
#                 'is_asset_completed': is_asset_completed,
#                 'is_fully_depreciated': is_fully_depreciated,
#                 'monthly_breakdown': monthly_details,
#                 'summary_note': f"ຫັກຄ່າເສື່ອມ {months_processed} ເດືອນ, ລວມ {total_depreciation:,.2f} ກີບ"
#             },
#             'updated_status': {
#                 'C_dpac': months_processed,
#                 'total_months': total_months,
#                 'remaining_months': max(0, total_months - months_processed),
#                 'is_completed': is_fully_depreciated or months_processed >= total_months,
#                 'completion_status': "ຫັກຄົບແລ້ວ" if is_fully_depreciated else f"ຫັກແລ້ວ {months_processed}/{total_months} ເດືອນ"
#             }
#         }
        
#     except Exception as e:
#         return {"error": f"Bulk depreciation error: {str(e)}"}

def process_bulk_depreciation_catch_up(mapping_id, user_id=None, current_date=None):
    """ຫັກຄ່າເສື່ອມລາຄາແບບລວມ - ຈາກເລີ່ມຕົ້ນຮອດ latest EOD date"""
    try:
        # ກວດສອບສະຖານະກ່ອນ
        calc_result = calculate_depreciation_schedule(mapping_id)
        if 'error' in calc_result:
            return calc_result
        
        # ດຶງຂໍ້ມູນ asset
        accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
        if accounting_method.asset_list_id:
            asset = accounting_method.asset_list_id
        else:
            asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
        
        # ✅ ຂໍ້ມູນພື້ນຖານ
        start_date = asset.dpca_start_date
        useful_life = int(asset.asset_useful_life)
        total_months = useful_life * 12
        end_date = start_date + relativedelta(years=useful_life) - timedelta(days=1)
        
        # 🎯 ປ່ຽນການກຳນົດ target_date ເປັນ latest EOD date
        if current_date:
            target_date = datetime.strptime(current_date, '%Y-%m-%d').date()
        else:
            # ຫາ Start_Date ທີ່ມີ date_id ໃຫຍ່ສຸດ ແລະ eod_time = 'Y'
            try:
                latest_eod = STTB_Dates.objects.filter(eod_time='Y').order_by('-date_id').first()
                if latest_eod and latest_eod.Start_Date:
                    target_date = latest_eod.Start_Date.date()
                    print(f"🎯 Using latest EOD date: {target_date} (date_id: {latest_eod.date_id})")
                else:
                    # Fallback ໃຊ້ມື້ປະຈຸບັນຖ້າບໍ່ພົບ EOD record
                    target_date = datetime.now().date()
                    print(f"⚠️ No EOD record found, using current date: {target_date}")
            except Exception as eod_error:
                print(f"⚠️ Error getting EOD date: {str(eod_error)}, using current date")
                target_date = datetime.now().date()
        
        # ✅ ຄິດໄລຍະເວລາທີ່ຕ້ອງຫັກ
        # ເລືອກວັນທີ່ທີ່ນ້ອຍກວ່າ: ວັນສິ້ນສຸດອາຍຸການໃຊ້ ຫຼື target_date (EOD date)
        actual_end_date = min(end_date, target_date)
        
        # ຄິດຈຳນວນເດືອນທີ່ຕ້ອງຫັກ
        months_to_process = []
        current_month_start = start_date
        month_counter = 1
        
        while current_month_start <= actual_end_date:
            # ວັນເລີ່ມຕົ້ນແລະສິ້ນສຸດຂອງເດືອນ
            if month_counter == 1:
                # ງວດທຳອິດ: ເລີ່ມຈາກວັນທີ່ start_date
                month_actual_start = start_date
                month_end = datetime(start_date.year, start_date.month, 
                                   get_last_day_of_month(start_date.year, start_date.month)).date()
            else:
                # ງວດອື່ນໆ: ເລີ່ມວັນທີ່ 1
                month_actual_start = datetime(current_month_start.year, current_month_start.month, 1).date()
                month_end = datetime(current_month_start.year, current_month_start.month,
                                   get_last_day_of_month(current_month_start.year, current_month_start.month)).date()
            
            # ປັບ month_end ຖ້າເກີນ actual_end_date
            if month_end > actual_end_date:
                month_end = actual_end_date
            
            months_to_process.append({
                'month_number': month_counter,
                'start_date': month_actual_start,
                'end_date': month_end,
                'year_month': f"{current_month_start.year}-{current_month_start.month:02d}"
            })
            
            # ເລື່ອນໄປເດືອນຕໍ່ໄປ
            current_month_start = current_month_start + relativedelta(months=1)
            month_counter += 1
            
            # ຢຸດຖ້າເກີນອາຍຸການໃຊ້
            if month_counter > total_months:
                break
        
        # ✅ ຄິດຄ່າເສື່ອມ
        asset_value = Decimal(str(asset.asset_value or 0))
        salvage_value = Decimal(str(asset.asset_salvage_value or 0))
        depreciable_amount = asset_value - salvage_value
        old_accumulated = Decimal(str(asset.asset_accu_dpca_value or 0))
        
        # ຄ່າເສື່ອມຕໍ່ປີ ແລະ ຕໍ່ເດືອນ
        annual_depreciation = depreciable_amount / Decimal(str(useful_life))
        monthly_depreciation = (annual_depreciation / Decimal('12')).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
        
        # ຄິດຄ່າເສື່ອມແຕ່ລະເດືອນ
        monthly_details = []
        total_depreciation = Decimal('0')
        is_asset_completed = actual_end_date >= end_date
        
        for i, month_data in enumerate(months_to_process):
            month_num = month_data['month_number']
            month_start = month_data['start_date']
            month_end = month_data['end_date']
            
            # ຄິດຈຳນວນວັນ
            days_in_period = (month_end - month_start + timedelta(days=1)).days
            total_days_in_month = get_last_day_of_month(month_start.year, month_start.month)
            
            # ກຳນົດປະເພດງວດ
            is_first_month = (month_num == 1)
            is_last_month_of_asset = (month_num == total_months) and is_asset_completed
            is_current_final_month = (i == len(months_to_process) - 1) and not is_asset_completed
            
            # ✅ ຄິດຄ່າເສື່ອມຕາມປະເພດງວດ
            if is_first_month:
                # 🎯 ງວດທຳອິດ: pro-rated
                month_depreciation = (monthly_depreciation * Decimal(str(days_in_period)) / 
                                    Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                period_type = "ງວດທຳອິດ"
                calculation_note = f"({monthly_depreciation:,.2f} × {days_in_period}) ÷ {total_days_in_month} = {month_depreciation:,.2f}"
                
            elif is_last_month_of_asset:
                # 🎯 ງວດສຸດທ້າຍຂອງຊັບສິນ: ປັບໃຫ້ຄົບ depreciable_amount
                remaining_to_depreciate = depreciable_amount - (old_accumulated + total_depreciation)
                month_depreciation = remaining_to_depreciate.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                period_type = "ງວດສຸດທ້າຍ (ຄົບອາຍຸ)"
                calculation_note = f"ປັບໃຫ້ຄົບ {depreciable_amount:,.0f} ກີບ (ເຫຼືອ {remaining_to_depreciate:,.2f})"
                
            else:
                # 🎯 ງວດປົກກະຕິ: ຫັກຕາມວັນຈິງ
                if days_in_period == total_days_in_month:
                    # ເຕັມເດືອນ
                    month_depreciation = monthly_depreciation
                    period_type = "ງວດປົກກະຕິ (ເຕັມເດືອນ)"
                    calculation_note = f"ເຕັມເດືອນ = {monthly_depreciation:,.2f}"
                else:
                    # ບໍ່ເຕັມເດືອນ (pro-rated)
                    month_depreciation = (monthly_depreciation * Decimal(str(days_in_period)) / 
                                        Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                    period_type = "ງວດປົກກະຕິ (ບາງສ່ວນ)"
                    calculation_note = f"({monthly_depreciation:,.2f} × {days_in_period}) ÷ {total_days_in_month} = {month_depreciation:,.2f}"
            
            total_depreciation += month_depreciation
            
            monthly_details.append({
                'month_number': month_num,
                'period': f"{month_start.strftime('%d/%m/%Y')} - {month_end.strftime('%d/%m/%Y')}",
                'month_year': f"{get_month_name_la(month_start.month)} {month_start.year}",
                'days_count': days_in_period,
                'total_days_in_month': total_days_in_month,
                'period_type': period_type,
                'monthly_depreciation': float(month_depreciation),
                'calculation_note': calculation_note
            })
        
        # ✅ ຄິດຜົນລວມ
        new_accumulated = old_accumulated + total_depreciation
        new_remaining = asset_value - new_accumulated
        
        # ກວດສອບບໍ່ໃຫ້ເກີນ depreciable_amount
        if new_accumulated > depreciable_amount:
            excess = new_accumulated - depreciable_amount
            total_depreciation = total_depreciation - excess
            new_accumulated = depreciable_amount
            new_remaining = salvage_value
        
        # ✅ ກຳນົດສະຖານະໃໝ່
        months_processed = len(months_to_process)
        is_fully_depreciated = new_accumulated >= depreciable_amount
        
        # 🎯 ເພີ່ມຂໍ້ມູນ EOD date ໃນ return
        eod_info = None
        try:
            latest_eod = STTB_Dates.objects.filter(eod_time='Y').order_by('-date_id').first()
            if latest_eod:
                eod_info = {
                    'date_id': latest_eod.date_id,
                    'eod_date': latest_eod.Start_Date.strftime('%d/%m/%Y') if latest_eod.Start_Date else None,
                    'used_as_target': target_date.strftime('%d/%m/%Y')
                }
        except:
            eod_info = {'error': 'Could not get EOD info'}
        
        return {
            'success': True,
            'bulk_depreciation_processed': {
                'processing_period': f"{start_date.strftime('%d/%m/%Y')} - {actual_end_date.strftime('%d/%m/%Y')}",
                'months_processed': months_processed,
                'total_depreciation': float(total_depreciation),
                'old_accumulated': float(old_accumulated),
                'new_accumulated': float(new_accumulated),
                'remaining_value': float(new_remaining),
                'is_asset_completed': is_asset_completed,
                'is_fully_depreciated': is_fully_depreciated,
                'monthly_breakdown': monthly_details,
                'summary_note': f"ຫັກຄ່າເສື່ອມ {months_processed} ເດືອນ, ລວມ {total_depreciation:,.2f} ກີບ",
                'eod_date_info': eod_info  # ເພີ່ມຂໍ້ມູນ EOD
            },
            'updated_status': {
                'C_dpac': months_processed,
                'total_months': total_months,
                'remaining_months': max(0, total_months - months_processed),
                'is_completed': is_fully_depreciated or months_processed >= total_months,
                'completion_status': "ຫັກຄົບແລ້ວ" if is_fully_depreciated else f"ຫັກແລ້ວ {months_processed}/{total_months} ເດືອນ"
            }
        }
        
    except Exception as e:
        return {"error": f"Bulk depreciation error: {str(e)}"}
# ✅ Helper function ສຳລັບທົດສອບ
def test_bulk_depreciation():
    """ຟັງຊັນທົດສອບ bulk depreciation"""
    
    # Test data
    test_cases = [
        {
            'name': 'Case 1: ເລີ່ມ 2023, 3 ປີ, ຕອນນີ້ 2025',
            'start_date': '2023-01-15',
            'useful_life': 3,
            'asset_value': 1000000,
            'salvage_value': 100000,
            'current_date': '2025-08-31'
        },
        {
            'name': 'Case 2: ເລີ່ມ 2024, 5 ປີ, ຕອນນີ້ 2025', 
            'start_date': '2024-03-01',
            'useful_life': 5,
            'asset_value': 2000000,
            'salvage_value': 200000,
            'current_date': '2025-08-31'
        },
        {
            'name': 'Case 3: ເລີ່ມ 2022, 3 ປີ (ຄົບແລ້ວ)',
            'start_date': '2022-06-15', 
            'useful_life': 3,
            'asset_value': 1500000,
            'salvage_value': 150000,
            'current_date': '2025-08-31'
        }
    ]
    
    print("🧪 ການທົດສອບ Bulk Depreciation Function")
    print("=" * 60)
    
    for case in test_cases:
        print(f"\n📋 {case['name']}")
        print(f"   ເລີ່ມ: {case['start_date']}")
        print(f"   ອາຍຸ: {case['useful_life']} ປີ") 
        print(f"   ມູນຄ່າ: {case['asset_value']:,} ກີບ")
        print(f"   Salvage: {case['salvage_value']:,} ກີບ")
        print(f"   ປະຈຸບັນ: {case['current_date']}")
        
        # ຄິດໄລ່ຄ່າພຽງພະບົງ
        depreciable = case['asset_value'] - case['salvage_value']
        annual_dep = depreciable / case['useful_life']
        monthly_dep = annual_dep / 12
        
        print(f"   → ຫັກໄດ້: {depreciable:,} ກີບ")
        print(f"   → ຕໍ່ປີ: {annual_dep:,.0f} ກີບ")
        print(f"   → ຕໍ່ເດືອນ: {monthly_dep:,.2f} ກີບ")
        
        # ຄິດເດືອນທີ່ຄວນຫັກ
        from datetime import datetime
        start = datetime.strptime(case['start_date'], '%Y-%m-%d').date()
        current = datetime.strptime(case['current_date'], '%Y-%m-%d').date()
        end_of_life = start + relativedelta(years=case['useful_life']) - timedelta(days=1)
        
        actual_end = min(end_of_life, current)
        
        print(f"   → ສິ້ນສຸດອາຍຸ: {end_of_life}")
        print(f"   → ຫັກຮອດ: {actual_end}")
        
    return test_cases
def create_journal_entry_via_api(journal_data, request):
    """
    ✅ ສ້າງ Journal Entry ຜ່ານ process_journal_data (ແກ້ໄຂ GLSub Foreign Key)
    """
    try:
        print(f"📝 Creating journal via process_journal_data...")
        print(f"📊 Journal data: {json.dumps(journal_data, indent=2)}")
        
        # ✅ ໃຊ້ process_journal_data API ແທນ batch_create
        try:
            from SAMCSYS.views import JournalProcessV2ViewSet
            
            # ✅ ຫາ MTTB_Users instance ທີ່ຖືກຕ້ອງ
            from .models import MTTB_Users
            
            actual_user = None
            
            # ພະຍາຍາມຫາ user ທີ່ຖືກຕ້ອງ
            if hasattr(request, 'user') and hasattr(request.user, 'user_id'):
                try:
                    actual_user = MTTB_Users.objects.get(user_id=request.user.user_id)
                    print(f"✅ Found user from request: {actual_user.user_id}")
                except:
                    pass
            
            # ເອົາ user ທຳອິດຖ້າບໍ່ພົບ
            if not actual_user:
                try:
                    actual_user = MTTB_Users.objects.first()
                    print(f"⚠️ Using first user: {actual_user.user_id if actual_user else 'None'}")
                except:
                    pass
            
            if not actual_user:
                return {
                    'success': False,
                    'error': 'No valid MTTB_Users found in system',
                    'method': 'no_user_error'
                }
            
            # ✅ ສ້າງ mock request object
            from unittest.mock import Mock
            mock_request = Mock()
            mock_request.data = journal_data  # ໃຊ້ journal_data ໂດຍກົງ
            mock_request.user = actual_user   # ໃຊ້ MTTB_Users instance
            mock_request.method = 'POST'
            
            print(f"👤 Using user: {actual_user.user_id} ({type(actual_user)})")
            
            # ✅ ເອີ້ນ process_journal_data ແທນ batch_create
            viewset = JournalProcessV2ViewSet()
            viewset.request = mock_request
            viewset.format_kwarg = None
            
            # ໃຊ້ process_journal_data ທີ່ຈະສ້າງ GLSub ອັດຕະໂນມັດ
            process_response = viewset.process_journal_data(mock_request)
            
            if process_response.status_code in [200, 201]:
                print(f"✅ Process Journal Success: {process_response.status_code}")
                return {
                    'success': True,
                    'status_code': process_response.status_code,
                    'data': process_response.data,
                    'method': 'process_journal_data_success',
                    'user_used': actual_user.user_id
                }
            else:
                print(f"❌ Process Journal Error: {process_response.status_code}")
                print(f"❌ Error details: {process_response.data}")
                return {
                    'success': False,
                    'status_code': process_response.status_code,
                    'error': process_response.data,
                    'method': 'process_journal_data_error',
                    'user_used': actual_user.user_id
                }
                
        except ImportError as e:
            print(f"⚠️ Cannot import JournalProcessV2ViewSet: {str(e)}")
            return {
                'success': False,
                'error': f'JournalProcessV2ViewSet import error: {str(e)}',
                'method': 'import_error'
            }
            
    except Exception as e:
        print(f"💥 Journal Creation Fatal Error: {str(e)}")
        return {
            'success': False,
            'error': f"Journal creation fatal error: {str(e)}",
            'method': 'fatal_error'
        }
def process_monthly_depreciation_with_journal(mapping_id, user_id=None, date=None, create_journal=True, request=None):
    """
    ✅ ຫັກຄ່າເສື່ອມລາຄາພ້ອມສ້າງ Journal Entry
    """
    try:
        print(f"🎯 Processing mapping_id: {mapping_id}, create_journal: {create_journal}")
        
        # ດຳເນີນການຫັກຄ່າເສື່ອມລາຄາປົກກະຕິ
        depreciation_result = process_monthly_depreciation_with_inmonth(mapping_id, user_id, None, date)
        
        if not depreciation_result.get('success'):
            print(f"❌ Depreciation failed for mapping_id {mapping_id}")
            return depreciation_result
        
        print(f"✅ Depreciation success for mapping_id {mapping_id}")
        
       
        if not create_journal:
            print(f"ℹ️ Journal creation disabled for mapping_id {mapping_id}")
            depreciation_result['journal_entry'] = {'success': False, 'message': 'Journal creation disabled'}
            return depreciation_result
        
        
        if not request:
            print(f"⚠️ No request object for mapping_id {mapping_id}")
            depreciation_result['journal_entry'] = {
                'success': False,
                'error': 'Request object required for journal entry creation'
            }
            return depreciation_result
        
        try:
            print(f"📝 Creating journal entry for mapping_id {mapping_id}")
            
           
            accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
            if accounting_method.asset_list_id:
                asset = accounting_method.asset_list_id
            else:
                asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
            
           
            depreciation_processed = depreciation_result['depreciation_processed']
            depreciation_amount = Decimal(str(depreciation_processed['monthly_depreciation']))
            current_count = depreciation_processed['month_number']
            total_months = int(asset.asset_useful_life) * 12
            
            print(f"💰 Amount: {depreciation_amount}, Month: {current_count}/{total_months}")
            
          
            journal_data_result = create_journal_entry_data(
                asset, accounting_method, depreciation_amount, current_count, total_months
            )
            
            if not journal_data_result['success']:
                print(f"❌ Journal data creation failed: {journal_data_result['error']}")
                depreciation_result['journal_entry'] = journal_data_result
                return depreciation_result
            
            # ກວດສອບວ່າພົບ GL Accounts ທັງຄູ່ບໍ
            validation = journal_data_result['validation']
            if not validation['debit_found'] or not validation['credit_found']:
                print(f"❌ GL Accounts not found: Debit={validation['debit_found']}, Credit={validation['credit_found']}")
                depreciation_result['journal_entry'] = {
                    'success': False,
                    'error': 'GL Account not found',
                    'details': {
                        'debit_account': validation['debit_account_number'],
                        'credit_account': validation['credit_account_number'],
                        'debit_found': validation['debit_found'],
                        'credit_found': validation['credit_found']
                    }
                }
                return depreciation_result
            
            print(f"✅ GL Accounts found: Debit GLID={validation['debit_glid']}, Credit GLID={validation['credit_glid']}")
            
            # ສ້າງ Journal Entry
            journal_response = create_journal_entry_via_api(
                journal_data_result['journal_data'], request
            )
            
            # ເພີ່ມຜົນລັບ Journal Entry ໃສ່ຜົນລັບການຫັກຄ່າເສື່ອມ
            depreciation_result['journal_entry'] = journal_response
            depreciation_result['journal_entry']['journal_data'] = journal_data_result['journal_data']
            depreciation_result['journal_entry']['validation'] = validation
            
            if journal_response['success']:
                print(f"🎉 Complete success for mapping_id {mapping_id}")
            else:
                print(f"⚠️ Depreciation success but journal failed for mapping_id {mapping_id}")
            
            return depreciation_result
            
        except Exception as journal_error:
            print(f"💥 Journal creation error for mapping_id {mapping_id}: {str(journal_error)}")
            # ຖ້າການສ້າງ Journal Entry ຜິດພາດ ແຕ່ການຫັກຄ່າເສື່ອມສຳເລັດແລ້ວ
            depreciation_result['journal_entry'] = {
                'success': False,
                'error': f"Journal creation failed: {str(journal_error)}",
                'depreciation_success': True  # ການຫັກຄ່າເສື່ອມຍັງສຳເລັດ
            }
            return depreciation_result
        
    except Exception as e:
        print(f"💥 General error for mapping_id {mapping_id}: {str(e)}")
        return {"error": f"Process with journal error: {str(e)}"}

def validate_user_id(user_id):
    """ກວດສອບວ່າ user_id ມີຢູ່ບໍ"""
    if not user_id:
        return None
    try:
        user = MTTB_Users.objects.get(user_id=user_id)
        return user.user_id
    except MTTB_Users.DoesNotExist:
        print(f"User ID {user_id} ບໍ່ມີຢູ່")
        return None
    except Exception as e:
        print(f"Validate user error: {str(e)}")
        return None

def create_depreciation_daily_log(depreciation_record, user_id=None):
    """
    ✅ ສ້າງ Daily Log entries ສຳລັບການຫັກຄ່າເສື່ອມ
    """
    try:
        from django.utils import timezone
        
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        current_time = timezone.now()
        
        # ດຶງຂໍ້ມູນຈາກ depreciation record
        asset = depreciation_record.asset_list_id
        
        # ຫາ accounting method ສຳລັບເອົາ debit/credit accounts
        try:
            accounting_method = FA_Accounting_Method.objects.filter(
                Q(asset_list_id=asset) | Q(ref_id=str(asset.asset_list_id))
            ).first()
            
            if not accounting_method:
                # ພະຍາຍາມຫາແບບແຍກ
                accounting_method = FA_Accounting_Method.objects.filter(
                    asset_list_id=asset
                ).first()
                
                if not accounting_method:
                    accounting_method = FA_Accounting_Method.objects.filter(
                        ref_id=str(asset.asset_list_id)
                    ).first()
            
            if not accounting_method:
                return {
                    'success': False,
                    'error': 'Accounting method not found for asset'
                }
        except Exception as e:
            return {
                'success': False,
                'error': f'Error finding accounting method: {str(e)}'
            }
        
        # ຄຳນວນ amounts
        depreciation_amount = float(depreciation_record.dpca_value)
        
        # ສ້າງ Daily Log entries (2 entries: Debit & Credit)
        daily_log_entries_created = 0
        daily_log_hist_entries_created = 0
        
        try:
            # ພະຍາຍາມໃຊ້ ACTB_DAIRY_LOG models (ຖ້າມີ)
            try:
                from .models import ACTB_DAIRY_LOG, ACTB_DAIRY_LOG_HISTORY
                
                # 1. Debit Entry (Depreciation Expense)
                debit_entry_data = {
                    'module': 'AS',
                    'trn_ref_no': f"DEP-{depreciation_record.aldm_id}",
                    'trn_ref_sub_no': 1,
                    'event_sr_no': 1,
                    'event': 'DPCA',
                    'ac_no': accounting_method.debit_account_id,
                    'ac_no_full': accounting_method.debit_account_id,
                    'ac_relative': f"ASSET-{asset.asset_list_id}",
                    'ac_ccy': asset.asset_currency or 'LAK',
                    'drcr_ind': 'D',
                    'trn_code': 'ARD',
                    'fcy_amount': depreciation_amount,
                    'exch_rate': 1.0,
                    'lcy_amount': depreciation_amount,
                    'fcy_dr': depreciation_amount,
                    'fcy_cr': 0.0,
                    'lcy_dr': depreciation_amount,
                    'lcy_cr': 0.0,
                    'external_ref_no': f"DPCA-{asset.asset_code or asset.asset_list_id}",
                    'addl_text': f"ຫັກຄ່າຫຼູ້ຍຫຽ້ນ {asset.asset_spec or 'N/A'}",
                    'addl_sub_text': depreciation_record.dpca_desc[:50] if depreciation_record.dpca_desc else '',
                    'trn_dt': depreciation_record.dpca_date,
                    'value_dt': depreciation_record.dpca_date,
                    'financial_cycle': str(depreciation_record.dpca_date.year),
                    'period_code': depreciation_record.dpca_month,
                    'Maker_id': validated_user_id,
                    'Maker_DT_Stamp': current_time,
                    'Checker_id': validated_user_id,
                    'Checker_DT_Stamp': current_time,
                    'Auth_Status': 'A',
                    'product': 'AS',
                    'entry_seq_no': 1,
                    'delete_stat': None
                }
                
                # 2. Credit Entry (Accumulated Depreciation)
                credit_entry_data = debit_entry_data.copy()
                credit_entry_data.update({
                    'trn_ref_sub_no': 2,
                    'event_sr_no': 2,
                    'ac_no': accounting_method.credit_account_id,
                    'ac_no_full': accounting_method.credit_account_id,
                    'drcr_ind': 'C',
                    'fcy_dr': 0.0,
                    'fcy_cr': depreciation_amount,
                    'lcy_dr': 0.0,
                    'lcy_cr': depreciation_amount,
                    'entry_seq_no': 2
                })
                
                # ສ້າງ ACTB_DAIRY_LOG entries
                try:
                    debit_log_entry = ACTB_DAIRY_LOG.objects.create(**debit_entry_data)
                    credit_log_entry = ACTB_DAIRY_LOG.objects.create(**credit_entry_data)
                    daily_log_entries_created = 2
                    print(f"✅ ສ້າງ ACTB_DAIRY_LOG entries: 2")
                except Exception as log_error:
                    print(f"❌ ACTB_DAIRY_LOG error: {str(log_error)}")
                
                # ສ້າງ ACTB_DAIRY_LOG_HISTORY entries
                try:
                    debit_hist_entry = ACTB_DAIRY_LOG_HISTORY.objects.create(**debit_entry_data)
                    credit_hist_entry = ACTB_DAIRY_LOG_HISTORY.objects.create(**credit_entry_data)
                    daily_log_hist_entries_created = 2
                    print(f"✅ ສ້າງ ACTB_DAIRY_LOG_HISTORY entries: 2")
                except Exception as hist_error:
                    print(f"❌ ACTB_DAIRY_LOG_HISTORY error: {str(hist_error)}")
                
            except ImportError:
                print("ℹ️ ACTB_DAIRY_LOG models ບໍ່ມີ - ສ້າງ custom log")
                
                # ສ້າງ simple log record
                log_entry = {
                    'transaction_type': 'DEPRECIATION',
                    'reference_no': f"DEP-{depreciation_record.aldm_id}",
                    'asset_id': asset.asset_list_id,
                    'asset_name': asset.asset_spec,
                    'depreciation_amount': depreciation_amount,
                    'debit_account': accounting_method.debit_account_id,
                    'credit_account': accounting_method.credit_account_id,
                    'transaction_date': depreciation_record.dpca_date,
                    'description': depreciation_record.dpca_desc,
                    'created_by': validated_user_id,
                    'created_at': current_time,
                    'status': 'APPROVED'
                }
                daily_log_entries_created = 1
                print(f"✅ ສ້າງ Custom Daily Log: 1")
                
        except Exception as daily_log_error:
            print(f"❌ Daily Log creation error: {str(daily_log_error)}")
        
        return {
            'success': True,
            'daily_log_entries_created': daily_log_entries_created,
            'daily_log_hist_entries_created': daily_log_hist_entries_created,
            'debit_account': accounting_method.debit_account_id,
            'credit_account': accounting_method.credit_account_id,
            'amount': depreciation_amount,
            'reference_no': f"DEP-{depreciation_record.aldm_id}"
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Daily log creation error: {str(e)}"
        }

def confirm_depreciation(aldm_id, status, reason=None, user_id=None):
    """
    ✅ FORCED DEBUG: ຢືນຢັນການຫັກຄ່າເສື່ອມ + ບັງຄັບ debug + Fixed C_dpac calculation
    """
    try:
        print(f"🎯 [FORCE] confirm_depreciation called: aldm_id={aldm_id}, status={status}")
        
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        if status not in ['A', 'R', 'P']:
            return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
        if status in ['R', 'P'] and not reason:
            return {"error": "ຕ້ອງລະບຸ reason ສຳລັບ Rejected ຫຼື Pending Revision"}
        
        with transaction.atomic():
            main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
            
            if main_record.Auth_Status not in ['U', 'P']:
                return {"error": f"ບໍ່ສາມາດປ່ຽນສະຖານະຂອງບັນທຶກທີ່ມີ Auth_Status = {main_record.Auth_Status}"}
            
            current_time = timezone.now()
            
            # ✅ 1. ອັບເດດ Main Record
            main_record.Auth_Status = status
            main_record.detail = reason if status in ['R', 'P'] else None
            main_record.Checker_Id_id = validated_user_id
            main_record.Checker_DT_Stamp = current_time
            main_record.save()
            print(f"✅ [FORCE] Updated main_record: {aldm_id}")
            
            # ✅ 2. ອັບເດດ Detail Record
            FA_Asset_List_Depreciation.objects.filter(
                asset_list_id=main_record.asset_list_id,
                dpca_date=main_record.dpca_date,
                dpca_value=main_record.dpca_value
            ).update(
                Auth_Status=status,
                detail=reason if status in ['R', 'P'] else None,
                Checker_Id_id=validated_user_id,
                Checker_DT_Stamp=current_time
            )
            print(f"✅ [FORCE] Updated detail records")
            
            # ✅ 3. ຖ້າຢືນຢັນ (A), ອັບເດດ FA_Asset_Lists + Auto Approve Journals
            journal_auto_approval = None
            
            if status == 'A':
                print(f"🔍 [FORCE] Status is A, proceeding...")
                asset = main_record.asset_list_id
                asset_list_id = asset.asset_list_id
                print(f"🔍 [FORCE] Asset ID: {asset_list_id}")
                
                # 3.1 ອັບເດດ FA_Asset_Lists - ✨ ວິທີການໃໝ່ສຳລັບ C_dpac
                dpca_no_of_days = main_record.dpca_no_of_days or 0
                print(f"🔍 [FORCE-C_DPAC-DEBUG] dpca_no_of_days: {dpca_no_of_days}")
                print(f"🔍 [FORCE-C_DPAC-DEBUG] Asset current C_dpac: {asset.C_dpac}")
                
                if dpca_no_of_days <= 31:
                    # ຖ້າ <= 31 ວັນ: ເພີ່ມ 1
                    c_dpac_increment = 1
                    print(f"📊 [FORCE-C_DPAC-DEBUG] dpca_no_of_days <= 31, increment by 1")
                else:
                    # ຖ້າ > 31 ວັນ: ຫານດ້ວຍ 30 ແລ້ວປັດເປັນເລກຖ້ວນ
                    c_dpac_increment = round(dpca_no_of_days / 30)
                    print(f"📊 [FORCE-C_DPAC-DEBUG] dpca_no_of_days > 31, increment by round({dpca_no_of_days}/30) = {c_dpac_increment}")
                
                # ອັບເດດຄ່າໃນ database
                current_c_dpac = Decimal(str(asset.C_dpac or 0))
                new_c_dpac = current_c_dpac + Decimal(str(c_dpac_increment))
                
                print(f"🎯 [FORCE-C_DPAC-DEBUG] CALCULATION: {current_c_dpac} + {c_dpac_increment} = {new_c_dpac}")
                
                # ✨ ຄິດໄລ່ asset_latest_date_dpca ໃໝ່ຕາມ C_dpac
                from dateutil.relativedelta import relativedelta
                from datetime import datetime
                
                try:
                    # ດຶງ dpca_start_date ຈາກ asset
                    dpca_start_date = asset.dpca_start_date
                    print(f"📅 [FORCE-DATE-DEBUG] dpca_start_date: {dpca_start_date}")
                    
                    if dpca_start_date:
                        # ບວກ C_dpac (ເດືອນ) ເຂົ້າກັບ dpca_start_date
                        calculated_latest_date = dpca_start_date + relativedelta(months=int(new_c_dpac))
                        print(f"📅 [FORCE-DATE-DEBUG] Calculated date: {dpca_start_date} + {int(new_c_dpac)} months = {calculated_latest_date}")
                        
                        # ອັບເດດ asset_latest_date_dpca
                        asset.asset_latest_date_dpca = calculated_latest_date
                        print(f"📅 [FORCE-DATE-DEBUG] Updated asset_latest_date_dpca to: {calculated_latest_date}")
                    else:
                        # ຖ້າບໍ່ມີ dpca_start_date ໃຫ້ໃຊ້ dpca_date ຈາກ main_record
                        asset.asset_latest_date_dpca = main_record.dpca_date
                        print(f"⚠️ [FORCE-DATE-DEBUG] No dpca_start_date, using dpca_date: {main_record.dpca_date}")
                        
                except Exception as date_error:
                    print(f"⚠️ [FORCE-DATE-DEBUG] Date calculation error: {str(date_error)}")
                    # Fallback ໃຊ້ dpca_date ແທນ
                    asset.asset_latest_date_dpca = main_record.dpca_date
                    print(f"⚠️ [FORCE-DATE-DEBUG] Using fallback dpca_date: {main_record.dpca_date}")
                
                # ອັບເດດທຸກຄ່າ
                asset.C_dpac = str(new_c_dpac)
                asset.asset_accu_dpca_value = Decimal(str(main_record.accumulated_dpca))
                asset.asset_value_remain = Decimal(str(main_record.remaining_value))
                asset.save()
                
                print(f"✅ [FORCE-C_DPAC-DEBUG] ອັບເດດ FA_Asset_Lists ສຳເລັດ - Asset ID: {asset.asset_list_id}")
                print(f"📊 [FORCE-C_DPAC-DEBUG] FINAL C_dpac: {new_c_dpac}")
                print(f"📅 [FORCE-C_DPAC-DEBUG] FINAL asset_latest_date_dpca: {asset.asset_latest_date_dpca}")
                print(f"🎯 [FORCE-C_DPAC-DEBUG] ===== C_DPAC CALCULATION COMPLETE =====")
                
                # ✅ 3.2 ບັງຄັບກວດສອບ journal entries ກ່ອນ
                print(f"🔍 [FORCE] Checking journal entries for asset: {asset_list_id}")
                try:
                    check_result = check_journal_entries_for_asset(asset_list_id)
                    print(f"📊 [FORCE] Check result: {check_result}")
                except:
                    check_result = {'error': 'check_journal_entries_for_asset function not found'}
                    print(f"⚠️ [FORCE] Could not check journal entries: {check_result}")
                
                # ✅ 3.3 ອັດຕະໂນມັດ approve journal entries
                try:
                    print(f"🔍 [FORCE] About to call auto_approve_related_journals...")
                    
                    # ✅ ບັງຄັບເອີ້ນ function
                    try:
                        journal_auto_approval = auto_approve_related_journals(asset_list_id)
                    except:
                        print(f"⚠️ [FORCE] auto_approve_related_journals function not found, using fallback")
                        journal_auto_approval = {
                            'success': False,
                            'message': 'auto_approve_related_journals function not available',
                            'approved_count': 0,
                            'reference_numbers': []
                        }
                    
                    print(f"📊 [FORCE] auto_approve_related_journals result: {journal_auto_approval}")
                    
                    if journal_auto_approval and journal_auto_approval.get('success') and journal_auto_approval.get('approved_count', 0) > 0:
                        print(f"✅ [FORCE] Auto approved {journal_auto_approval['approved_count']} journals")
                    else:
                        print(f"ℹ️ [FORCE] No journals approved or function failed")
                        # ✅ ບັງຄັບສ້າງ result ຖ້າເປັນ None
                        if journal_auto_approval is None:
                            journal_auto_approval = {
                                'success': False,
                                'message': 'auto_approve_related_journals returned None',
                                'approved_count': 0,
                                'reference_numbers': [],
                                'debug_check': check_result if 'check_result' in locals() else None
                            }
                        
                except Exception as journal_error:
                    print(f"⚠️ [FORCE] Journal auto approval error: {str(journal_error)}")
                    import traceback
                    traceback.print_exc()
                    journal_auto_approval = {
                        'success': False,
                        'error': f"Journal auto approval error: {str(journal_error)}",
                        'approved_count': 0,
                        'reference_numbers': [],
                        'debug_check': check_result if 'check_result' in locals() else None
                    }
            elif status == 'R':
                print(f"🔴 [FORCE] Status is R, processing auto rejection...")
                asset = main_record.asset_list_id
                asset_list_id = asset.asset_list_id
                print(f"🔍 [FORCE] Asset ID: {asset_list_id}")
                
                # ✅ กวดສອບ journal entries ກ່ອນ
                print(f"🔍 [FORCE] Checking journal entries for asset: {asset_list_id}")
                try:
                    check_result = check_journal_entries_for_asset(asset_list_id)
                    print(f"📊 [FORCE] Check result: {check_result}")
                except:
                    check_result = {'error': 'check_journal_entries_for_asset function not found'}
                    print(f"⚠️ [FORCE] Could not check journal entries: {check_result}")
                
                # ✅ ອັດຕະໂນມັດ reject journal entries
                try:
                    print(f"🔍 [FORCE] About to call auto_reject_related_journals...")
                    
                    # ✅ ບັງຄັບເອີ້ນ function
                    try:
                        journal_auto_approval = auto_reject_related_journals(asset_list_id, reason, validated_user_id)
                        # ປ່ຽນ rejected_count ເປັນ approved_count ເພື່ອໃຊ້ logic ດຽວກັບ A
                        if journal_auto_approval and journal_auto_approval.get('success'):
                            journal_auto_approval['approved_count'] = journal_auto_approval.get('rejected_count', 0)
                    except:
                        print(f"⚠️ [FORCE] auto_reject_related_journals function not found, using fallback")
                        journal_auto_approval = {
                            'success': False,
                            'message': 'auto_reject_related_journals function not available',
                            'approved_count': 0,
                            'reference_numbers': []
                        }
                    
                    print(f"📊 [FORCE] auto_reject_related_journals result: {journal_auto_approval}")
                    
                    if journal_auto_approval and journal_auto_approval.get('success') and journal_auto_approval.get('approved_count', 0) > 0:
                        print(f"✅ [FORCE] Auto rejected {journal_auto_approval['approved_count']} journals")
                    else:
                        print(f"ℹ️ [FORCE] No journals rejected or function failed")
                        # ✅ ບັງຄັບສ້າງ result ຖ້າເປັນ None
                        if journal_auto_approval is None:
                            journal_auto_approval = {
                                'success': False,
                                'message': 'auto_reject_related_journals returned None',
                                'approved_count': 0,
                                'reference_numbers': [],
                                'debug_check': check_result if 'check_result' in locals() else None
                            }
                        
                except Exception as journal_error:
                    print(f"⚠️ [FORCE] Journal auto rejection error: {str(journal_error)}")
                    import traceback
                    traceback.print_exc()
                    journal_auto_approval = {
                        'success': False,
                        'error': f"Journal auto rejection error: {str(journal_error)}",
                        'approved_count': 0,
                        'reference_numbers': [],
                        'debug_check': check_result if 'check_result' in locals() else None
                    }
                    
            elif status == 'P':
                print(f"🟡 [FORCE] Status is P, processing pending update...")
                asset = main_record.asset_list_id
                asset_list_id = asset.asset_list_id
                print(f"🔍 [FORCE] Asset ID: {asset_list_id}")
                
                # ✅ อัพเดทสถานะ journal เป็น P
                try:
                    journal_auto_approval = update_journal_status_to_pending(asset_list_id, reason, validated_user_id)
                    # ปรับ field name เพื่อให้ logic เดิมใช้ได้
                    if journal_auto_approval and journal_auto_approval.get('success'):
                        journal_auto_approval['approved_count'] = journal_auto_approval.get('updated_count', 0)
                except:
                    journal_auto_approval = {
                        'success': False,
                        'message': 'update_journal_status_to_pending function not available',
                        'approved_count': 0,
                        'reference_numbers': []
                    }
                    
            else:
                print(f"🔍 [FORCE] Status is {status}, skipping journal processing")
                journal_auto_approval = {
                    'success': False,
                    'message': f'Unknown status {status}',
                    'approved_count': 0,
                    'reference_numbers': []
                }
            
            # ✅ 4. ສ້າງ message ທີ່ລວມ journal approval
            base_message = f"ບັນທຶກ {aldm_id} ອັບເດດເປັນ {status} ສຳເລັດ"
            
            if journal_auto_approval and journal_auto_approval.get('success') and journal_auto_approval.get('approved_count', 0) > 0:
                if status == 'A':
                    base_message += f" + Auto approved {journal_auto_approval['approved_count']} journal entries"
                elif status == 'R':
                    base_message += f" + Auto rejected {journal_auto_approval['approved_count']} journal entries"
                elif status == 'P':
                    base_message += f" + Updated {journal_auto_approval['approved_count']} journal entries to Pending"
            print(f"✅ [FORCE] Final journal_auto_approval: {journal_auto_approval}")
            
            return {
                'success': True,
                'message': base_message,
                'user_id_used': validated_user_id,
                'status_set': status,
                'reason_set': reason if status in ['R', 'P'] else None,
                'fa_asset_updated': status == 'A',
                'fa_accounting_method_updated': False,  # ✅ ປ່ຽນເປັນ False
                'accounting_method_info': None,  # ✅ ປ່ຽນເປັນ None  
                'c_dpac_calculation': {  # ✨ ເພີ່ມຂໍ້ມູນການຄິດໄລ່ໃໝ່
                    'dpca_no_of_days': dpca_no_of_days,
                    'increment_value': c_dpac_increment,
                    'previous_c_dpac': float(current_c_dpac),
                    'new_c_dpac': float(new_c_dpac)
                } if status == 'A' else None,
                'journal_auto_approval': journal_auto_approval  # ✅ ຈະບໍ່ເປັນ null ແລ້ວ
            }
        
    except Exception as e:
        print(f"💥 [FORCE] Confirm depreciation error: {str(e)}")
        import traceback
        traceback.print_exc()
        return {"error": f"Confirm depreciation error: {str(e)}"}
# ✅ ແກ້ໄຂ confirm_depreciation ໂດຍກົງ (debug ໃນ function)
# def confirm_depreciation(aldm_id, status, reason=None, user_id=None):
#     """
#     ✅ DIRECT FIX: ຢືນຢັນການຫັກຄ່າເສື່ອມ + debug journal approval
#     """
#     try:
#         print(f"🎯 [DEBUG] confirm_depreciation START: aldm_id={aldm_id}, status={status}")
        
#         validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
#         if not validated_user_id:
#             return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
#         if status not in ['A', 'R', 'P']:
#             return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
#         if status in ['R', 'P'] and not reason:
#             return {"error": "ຕ້ອງລະບຸ reason ສຳລັບ Rejected ຫຼື Pending Revision"}
        
#         with transaction.atomic():
#             main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
            
#             if main_record.Auth_Status not in ['U', 'P']:
#                 return {"error": f"ບໍ່ສາມາດປ່ຽນສະຖານະຂອງບັນທຶກທີ່ມີ Auth_Status = {main_record.Auth_Status}"}
            
#             current_time = timezone.now()
            
#             # ✅ 1. ອັບເດດ Main Record
#             main_record.Auth_Status = status
#             main_record.detail = reason if status in ['R', 'P'] else None
#             main_record.Checker_Id_id = validated_user_id
#             main_record.Checker_DT_Stamp = current_time
#             main_record.save()
#             print(f"✅ [DEBUG] Updated main_record: {aldm_id}")
            
#             # ✅ 2. ອັບເດດ Detail Record
#             FA_Asset_List_Depreciation.objects.filter(
#                 asset_list_id=main_record.asset_list_id,
#                 dpca_date=main_record.dpca_date,
#                 dpca_value=main_record.dpca_value
#             ).update(
#                 Auth_Status=status,
#                 detail=reason if status in ['R', 'P'] else None,
#                 Checker_Id_id=validated_user_id,
#                 Checker_DT_Stamp=current_time
#             )
#             print(f"✅ [DEBUG] Updated detail records")
            
#             # ✅ 3. ຖ້າຢືນຢັນ (A), ອັບເດດທຸກຢ່າງ + Auto Approve Journals
#             journal_auto_approval = None
#             accounting_method_updated = False
#             accounting_method_info = None
            
#             if status == 'A':
#                 print(f"🔍 [DEBUG] Status is A, processing...")
#                 asset = main_record.asset_list_id
#                 asset_list_id = asset.asset_list_id
#                 print(f"🔍 [DEBUG] Asset ID: {asset_list_id}")
                
#                 # 3.1 ອັບເດດ FA_Asset_Lists
#                 asset.C_dpac = str(int(asset.C_dpac or 0) + 1)
#                 asset.asset_accu_dpca_value = Decimal(str(main_record.accumulated_dpca))
#                 asset.asset_value_remain = Decimal(str(main_record.remaining_value))
#                 asset.asset_latest_date_dpca = main_record.dpca_date
#                 asset.save()
#                 print(f"✅ ອັບເດດ FA_Asset_Lists ສຳເລັດ - Asset ID: {asset.asset_list_id}")
                
#                 # 3.2 ອັບເດດ FA_Accounting_Method
#                 try:
#                     accounting_method = FA_Accounting_Method.objects.filter(
#                         Q(asset_list_id=asset) | Q(ref_id=str(asset.asset_list_id))
#                     ).first()
                    
#                     if accounting_method:
#                         accounting_method.amount_end = main_record.remaining_value
#                         accounting_method.amount = main_record.dpca_value
#                         accounting_method.transaction_date = main_record.dpca_date
#                         accounting_method.description = f"ອັບເດດຈາກການຢືນຢັນການຫັກຄ່າເສື່ອມ - {main_record.dpca_desc}"
#                         accounting_method.Checker_Id_id = validated_user_id
#                         accounting_method.Checker_DT_Stamp = current_time
#                         accounting_method.save()
                        
#                         accounting_method_updated = True
#                         accounting_method_info = {
#                             'mapping_id': accounting_method.mapping_id,
#                             'amount_end_updated': float(accounting_method.amount_end),
#                             'amount_updated': float(accounting_method.amount),
#                             'transaction_date_updated': accounting_method.transaction_date.strftime('%d/%m/%Y')
#                         }
#                         print(f"✅ ອັບເດດ FA_Accounting_Method ສຳເລັດ - Mapping ID: {accounting_method.mapping_id}")
                        
#                 except Exception as acc_error:
#                     print(f"❌ ອັບເດດ FA_Accounting_Method ຜິດພາດ: {str(acc_error)}")
#                     accounting_method_info = {'error': str(acc_error)}
                
#                 # ✅ 3.3 Debug + Auto Approve Journal Entries
#                 try:
#                     print(f"🔍 [DEBUG] Starting journal approval for asset: {asset_list_id}")
                    
#                     # ✅ ກວດສອບ DETB_JRNL_LOG ກ່ອນ
#                     try:
#                         from .models import DETB_JRNL_LOG
#                         print(f"✅ [DEBUG] DETB_JRNL_LOG imported successfully")
#                     except ImportError:
#                         try:
#                             from .models import DETB_JRNL_LOG_MASTER as DETB_JRNL_LOG
#                             print(f"✅ [DEBUG] DETB_JRNL_LOG_MASTER imported successfully")
#                         except ImportError:
#                             print(f"❌ [DEBUG] Cannot import DETB_JRNL_LOG models")
#                             journal_auto_approval = {
#                                 'success': False,
#                                 'error': 'DETB_JRNL_LOG model not found',
#                                 'approved_count': 0,
#                                 'reference_numbers': []
#                             }
#                             return self._build_response(...)  # Continue to return
                    
#                     # ✅ ກວດສອບ journal entries
#                     total_journals = DETB_JRNL_LOG.objects.count()
#                     print(f"📊 [DEBUG] Total journal entries in database: {total_journals}")
                    
#                     with_asset = DETB_JRNL_LOG.objects.filter(
#                         Ac_relatives__icontains=str(asset_list_id)
#                     ).count()
#                     print(f"📊 [DEBUG] Entries with asset_list_id '{asset_list_id}': {with_asset}")
                    
#                     target_entries = DETB_JRNL_LOG.objects.filter(
#                         Ac_relatives__icontains=str(asset_list_id),
#                         Auth_Status='U',
#                         Dr_cr='D'
#                     )
#                     target_count = target_entries.count()
#                     print(f"📊 [DEBUG] Target entries (Auth_Status='U', Dr_cr='D'): {target_count}")
                    
#                     if target_count > 0:
#                         # ສະແດງ sample
#                         sample = list(target_entries.values('Reference_No', 'Ac_relatives', 'Auth_Status', 'Dr_cr')[:3])
#                         print(f"📋 [DEBUG] Sample entries: {sample}")
                        
#                         # ດຶງ Reference_No
#                         reference_numbers = list(target_entries.values_list('Reference_No', flat=True).distinct())
#                         print(f"📋 [DEBUG] Reference numbers to approve: {reference_numbers}")
                        
#                         # ✅ ເອີ້ນ approve_all
#                         try:
#                             from SAMCSYS.views import JRNLLogViewSet
#                             from unittest.mock import Mock
#                             from .models import MTTB_Users
                            
#                             # ສ້າງ mock request
#                             mock_request = Mock()
#                             mock_request.user = MTTB_Users.objects.first()
#                             mock_request.method = 'POST'
                            
#                             approved_count = 0
#                             failed_count = 0
#                             approval_results = []
                            
#                             for ref_no in reference_numbers:
#                                 try:
#                                     print(f"📝 [DEBUG] Approving Reference_No: {ref_no}")
                                    
#                                     mock_request.data = {'Reference_No': ref_no}
                                    
#                                     viewset = JRNLLogViewSet()
#                                     viewset.request = mock_request
#                                     viewset.format_kwarg = None
                                    
#                                     response = viewset.approve_all(mock_request)
#                                     print(f"📨 [DEBUG] Response: status={response.status_code}")
                                    
#                                     if response.status_code in [200, 201]:
#                                         approved_count += 1
#                                         approval_results.append({
#                                             'reference_no': ref_no,
#                                             'status': 'success'
#                                         })
#                                         print(f"✅ [DEBUG] Approved: {ref_no}")
#                                     else:
#                                         failed_count += 1
#                                         print(f"❌ [DEBUG] Failed: {ref_no}")
                                        
#                                 except Exception as approve_error:
#                                     failed_count += 1
#                                     print(f"💥 [DEBUG] Approve error: {ref_no} - {str(approve_error)}")
                            
#                             journal_auto_approval = {
#                                 'success': True,
#                                 'message': f'ປະມວນຜົນ {len(reference_numbers)} entries: approve ສຳເລັດ {approved_count}, ຜິດພາດ {failed_count}',
#                                 'asset_list_id': asset_list_id,
#                                 'total_processed': len(reference_numbers),
#                                 'approved_count': approved_count,
#                                 'failed_count': failed_count,
#                                 'reference_numbers': reference_numbers,
#                                 'approval_details': approval_results,
#                                 'debug_info': {
#                                     'total_journals': total_journals,
#                                     'with_asset': with_asset,
#                                     'target_count': target_count
#                                 }
#                             }
                            
#                         except ImportError as import_error:
#                             print(f"⚠️ [DEBUG] Cannot import JRNLLogViewSet: {str(import_error)}")
#                             journal_auto_approval = {
#                                 'success': False,
#                                 'error': f'Import error: {str(import_error)}',
#                                 'approved_count': 0,
#                                 'reference_numbers': reference_numbers,
#                                 'debug_info': {
#                                     'total_journals': total_journals,
#                                     'with_asset': with_asset,
#                                     'target_count': target_count
#                                 }
#                             }
#                     else:
#                         print(f"ℹ️ [DEBUG] No journal entries found to approve")
#                         journal_auto_approval = {
#                             'success': True,
#                             'message': f'ບໍ່ມີ journal entries ທີ່ຕ້ອງ approve ສຳລັບ asset {asset_list_id}',
#                             'approved_count': 0,
#                             'reference_numbers': [],
#                             'debug_info': {
#                                 'total_journals': total_journals,
#                                 'with_asset': with_asset,
#                                 'target_count': target_count
#                             }
#                         }
                        
#                 except Exception as journal_error:
#                     print(f"⚠️ [DEBUG] Journal error: {str(journal_error)}")
#                     import traceback
#                     traceback.print_exc()
#                     journal_auto_approval = {
#                         'success': False,
#                         'error': f"Journal error: {str(journal_error)}",
#                         'approved_count': 0,
#                         'reference_numbers': []
#                     }
#             else:
#                 print(f"🔍 [DEBUG] Status is {status}, skipping journal approval")
#                 journal_auto_approval = {
#                     'success': False,
#                     'message': f'Skipped journal approval - status is {status}, not A',
#                     'approved_count': 0,
#                     'reference_numbers': []
#                 }
            
#             # ✅ 4. ສ້າງ message
#             base_message = f"ບັນທຶກ {aldm_id} ອັບເດດເປັນ {status} ສຳເລັດ"
#             if status == 'A' and journal_auto_approval and journal_auto_approval.get('approved_count', 0) > 0:
#                 base_message += f" + Auto approved {journal_auto_approval['approved_count']} journal entries"
            
#             print(f"✅ [DEBUG] Final result: journal_auto_approval = {journal_auto_approval}")
            
#             return {
#                 'success': True,
#                 'message': base_message,
#                 'user_id_used': validated_user_id,
#                 'status_set': status,
#                 'reason_set': reason if status in ['R', 'P'] else None,
#                 'fa_asset_updated': status == 'A',
#                 'fa_accounting_method_updated': accounting_method_updated,
#                 'accounting_method_info': accounting_method_info,
#                 'journal_auto_approval': journal_auto_approval  # ✅ ບໍ່ເປັນ null ແລ້ວ
#             }
        
#     except Exception as e:
#         print(f"💥 [DEBUG] Error: {str(e)}")
#         import traceback
#         traceback.print_exc()
#         return {"error": f"Confirm depreciation error: {str(e)}"}
def check_journal_entries_for_asset(asset_list_id):
    """
    🔍 ກວດສອບວ່າມີ journal entries ສຳລັບ asset ນີ້ບໍ່
    """
    try:
        print(f"🔍 Checking journal entries for asset: {asset_list_id}")
        
        # Import DETB_JRNL_LOG
        try:
            from .models import DETB_JRNL_LOG
            print(f"✅ Successfully imported DETB_JRNL_LOG")
        except ImportError:
            try:
                from .models import DETB_JRNL_LOG_MASTER as DETB_JRNL_LOG
                print(f"✅ Successfully imported DETB_JRNL_LOG_MASTER")
            except ImportError:
                return {"error": "Cannot import DETB_JRNL_LOG models"}
        
        # ກວດສອບທັງໝົດ
        total_count = DETB_JRNL_LOG.objects.count()
        print(f"📊 Total DETB_JRNL_LOG records: {total_count}")
        
        # ກວດສອບທີ່ມີ asset_list_id ໃນ Ac_relatives
        with_asset = DETB_JRNL_LOG.objects.filter(
            Ac_relatives__icontains=str(asset_list_id)
        ).count()
        print(f"📊 Records with asset_list_id '{asset_list_id}' in Ac_relatives: {with_asset}")
        
        # ກວດສອບທີ່ມີ Auth_Status = U
        with_u = DETB_JRNL_LOG.objects.filter(
            Ac_relatives__icontains=str(asset_list_id),
            Auth_Status='U'
        ).count()
        print(f"📊 Records with Auth_Status='U': {with_u}")
        
        # ກວດສອບທີ່ມີ Dr_cr = D
        with_d = DETB_JRNL_LOG.objects.filter(
            Ac_relatives__icontains=str(asset_list_id),
            Auth_Status='U',
            Dr_cr='D'
        ).count()
        print(f"📊 Records with Dr_cr='D': {with_d}")
        
        # ສະແດງ sample data
        sample_entries = DETB_JRNL_LOG.objects.filter(
            Ac_relatives__icontains=str(asset_list_id)
        ).values('Reference_No', 'Ac_relatives', 'Auth_Status', 'Dr_cr')[:5]
        
        sample_list = list(sample_entries)
        print(f"📋 Sample entries: {sample_list}")
        
        return {
            'success': True,
            'asset_list_id': asset_list_id,
            'total_count': total_count,
            'with_asset': with_asset,
            'with_u': with_u,
            'with_d': with_d,
            'sample_entries': sample_list
        }
        
    except Exception as e:
        print(f"💥 Error checking journal entries: {str(e)}")
        return {"error": str(e)}

def create_depreciation_daily_log_fixed(depreciation_record, user_id=None):
    """
    ✅ FIXED: ແກ້ໄຂ asset_code attribute error
    """
    try:
        from django.utils import timezone
        
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        current_time = timezone.now()
        
        # ດຶງຂໍ້ມູນຈາກ depreciation record
        asset = depreciation_record.asset_list_id
        
        # ຫາ accounting method ສຳລັບເອົາ debit/credit accounts
        try:
            accounting_method = FA_Accounting_Method.objects.filter(
                Q(asset_list_id=asset) | Q(ref_id=str(asset.asset_list_id))
            ).first()
            
            if not accounting_method:
                # ພະຍາຍາມຫາແບບແຍກ
                accounting_method = FA_Accounting_Method.objects.filter(
                    asset_list_id=asset
                ).first()
                
                if not accounting_method:
                    accounting_method = FA_Accounting_Method.objects.filter(
                        ref_id=str(asset.asset_list_id)
                    ).first()
            
            if not accounting_method:
                return {
                    'success': False,
                    'error': 'Accounting method not found for asset'
                }
        except Exception as e:
            return {
                'success': False,
                'error': f'Error finding accounting method: {str(e)}'
            }
        
        # ຄຳນວນ amounts
        depreciation_amount = float(depreciation_record.dpca_value)
        
        # ✅ FIXED: ໃຊ້ asset_list_id ແທນ asset_code ທີ່ບໍ່ມີ
        asset_code = getattr(asset, 'asset_code', None) or str(asset.asset_list_id).zfill(7)
        
        # ສ້າງ Daily Log entries (2 entries: Debit & Credit)
        daily_log_entries_created = 0
        daily_log_hist_entries_created = 0
        
        try:
            # ພະຍາຍາມໃຊ້ ACTB_DAIRY_LOG models (ຖ້າມີ)
            try:
                from .models import ACTB_DAIRY_LOG, ACTB_DAIRY_LOG_HISTORY
                
                # 1. Debit Entry (Depreciation Expense)
                debit_entry_data = {
                    'module': 'AS',
                    'trn_ref_no': f"DEP-{depreciation_record.aldm_id}",
                    'trn_ref_sub_no': 1,
                    'event_sr_no': 1,
                    'event': 'DPCA',
                    'ac_no': accounting_method.debit_account_id,
                    'ac_no_full': accounting_method.debit_account_id,
                    'ac_relative': f"ASSET-{asset.asset_list_id}",
                    'ac_ccy': asset.asset_currency or 'LAK',
                    'drcr_ind': 'D',
                    'trn_code': 'ARD',
                    'fcy_amount': depreciation_amount,
                    'exch_rate': 1.0,
                    'lcy_amount': depreciation_amount,
                    'fcy_dr': depreciation_amount,
                    'fcy_cr': 0.0,
                    'lcy_dr': depreciation_amount,
                    'lcy_cr': 0.0,
                    'external_ref_no': f"DPCA-{asset_code}",  # ✅ ໃຊ້ asset_code ທີ່ fixed ແລ້ວ
                    'addl_text': f"ຫັກຄ່າຫຼູ້ຍຫຽ້ນ {asset.asset_spec or 'N/A'}",
                    'addl_sub_text': depreciation_record.dpca_desc[:50] if depreciation_record.dpca_desc else '',
                    'trn_dt': depreciation_record.dpca_date,
                    'value_dt': depreciation_record.dpca_date,
                    'financial_cycle': str(depreciation_record.dpca_date.year),
                    'period_code': depreciation_record.dpca_month,
                    'Maker_id': validated_user_id,
                    'Maker_DT_Stamp': current_time,
                    'Checker_id': validated_user_id,
                    'Checker_DT_Stamp': current_time,
                    'Auth_Status': 'A',
                    'product': 'AS',
                    'entry_seq_no': 1,
                    'delete_stat': None
                }
                
                # 2. Credit Entry (Accumulated Depreciation)
                credit_entry_data = debit_entry_data.copy()
                credit_entry_data.update({
                    'trn_ref_sub_no': 2,
                    'event_sr_no': 2,
                    'ac_no': accounting_method.credit_account_id,
                    'ac_no_full': accounting_method.credit_account_id,
                    'drcr_ind': 'C',
                    'fcy_dr': 0.0,
                    'fcy_cr': depreciation_amount,
                    'lcy_dr': 0.0,
                    'lcy_cr': depreciation_amount,
                    'entry_seq_no': 2
                })
                
                # ສ້າງ ACTB_DAIRY_LOG entries
                try:
                    debit_log_entry = ACTB_DAIRY_LOG.objects.create(**debit_entry_data)
                    credit_log_entry = ACTB_DAIRY_LOG.objects.create(**credit_entry_data)
                    daily_log_entries_created = 2
                    print(f"✅ ສ້າງ ACTB_DAIRY_LOG entries: 2")
                except Exception as log_error:
                    print(f"❌ ACTB_DAIRY_LOG error: {str(log_error)}")
                
                # ສ້າງ ACTB_DAIRY_LOG_HISTORY entries
                try:
                    debit_hist_entry = ACTB_DAIRY_LOG_HISTORY.objects.create(**debit_entry_data)
                    credit_hist_entry = ACTB_DAIRY_LOG_HISTORY.objects.create(**credit_entry_data)
                    daily_log_hist_entries_created = 2
                    print(f"✅ ສ້າງ ACTB_DAIRY_LOG_HISTORY entries: 2")
                except Exception as hist_error:
                    print(f"❌ ACTB_DAIRY_LOG_HISTORY error: {str(hist_error)}")
                
            except ImportError:
                print("ℹ️ ACTB_DAIRY_LOG models ບໍ່ມີ - ສ້າງ custom log")
                
                # ສ້າງ simple log record
                log_entry = {
                    'transaction_type': 'DEPRECIATION',
                    'reference_no': f"DEP-{depreciation_record.aldm_id}",
                    'asset_id': asset.asset_list_id,
                    'asset_name': asset.asset_spec,
                    'asset_code': asset_code,  # ✅ ໃຊ້ asset_code ທີ່ fixed ແລ້ວ
                    'depreciation_amount': depreciation_amount,
                    'debit_account': accounting_method.debit_account_id,
                    'credit_account': accounting_method.credit_account_id,
                    'transaction_date': depreciation_record.dpca_date,
                    'description': depreciation_record.dpca_desc,
                    'created_by': validated_user_id,
                    'created_at': current_time,
                    'status': 'APPROVED'
                }
                daily_log_entries_created = 1
                print(f"✅ ສ້າງ Custom Daily Log: 1")
                
        except Exception as daily_log_error:
            print(f"❌ Daily Log creation error: {str(daily_log_error)}")
        
        return {
            'success': True,
            'daily_log_entries_created': daily_log_entries_created,
            'daily_log_hist_entries_created': daily_log_hist_entries_created,
            'debit_account': accounting_method.debit_account_id,
            'credit_account': accounting_method.credit_account_id,
            'amount': depreciation_amount,
            'reference_no': f"DEP-{depreciation_record.aldm_id}",
            'asset_code_used': asset_code  # ✅ ສະແດງວ່າໃຊ້ asset_code ອັນໃດ
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Daily log creation error: {str(e)}"
        }
def update_related_journal_entries_safe(depreciation_record, status, user_id=None):
    """
    ✅ IMPROVED: ອັບເດດ Journal Entries ທີ່ປອດໄພກວ່າເດີມ
    """
    try:
        from django.utils import timezone
        
        asset = depreciation_record.asset_list_id
        current_time = timezone.now()
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        
        # ✅ ໃຊ້ asset_list_id ແທນ asset_code
        asset_code = getattr(asset, 'asset_code', None) or str(asset.asset_list_id).zfill(7)
        
        # ສ້າງ search patterns
        asset_reference = f"ASSET-{asset.asset_list_id}"
        ref_no_pattern = f"AS-ARD-{depreciation_record.dpca_date.strftime('%Y%m%d')}"
        dep_reference = f"DEP-{depreciation_record.aldm_id}"
        
        updated_entries = []
        
        try:
            # ພະຍາຍາມ import Journal models
            from .models import SAMCSYS_detb_jrnl_log, SAMCSYS_detb_jrnl_batch
            
            print(f"🔍 ຊອກຫາ Journal entries:")
            print(f"   - Asset reference: {asset_reference}")
            print(f"   - Ref pattern: {ref_no_pattern}")
            print(f"   - DEP reference: {dep_reference}")
            
            # ✅ 1. ອັບເດດ SAMCSYS_detb_jrnl_log (ຫຼາຍແບບ)
            try:
                journal_entries = SAMCSYS_detb_jrnl_log.objects.filter(
                    Q(Ac_relatives=asset_reference) |
                    Q(Ac_relatives__icontains=str(asset.asset_list_id)) |
                    Q(Reference_No__startswith=ref_no_pattern) |
                    Q(Reference_No__icontains=dep_reference)
                )
                
                if journal_entries.exists():
                    log_updated = journal_entries.update(
                        Auth_Status=status,
                        Checker_Id_id=validated_user_id,
                        Checker_DT_Stamp=current_time
                    )
                    updated_entries.append(f"LOG: {log_updated} entries")
                    print(f"✅ ອັບເດດ SAMCSYS_detb_jrnl_log: {log_updated} entries")
                else:
                    print(f"ℹ️ ບໍ່ພົບ Journal LOG entries")
                    
            except Exception as log_error:
                print(f"❌ ອັບເດດ Journal LOG ຜິດພາດ: {str(log_error)}")
            
            # ✅ 2. ອັບເດດ SAMCSYS_detb_jrnl_batch (ຫຼາຍແບບ)
            try:
                batch_entries = SAMCSYS_detb_jrnl_batch.objects.filter(
                    Q(Reference_No__startswith=ref_no_pattern) |
                    Q(Reference_No__icontains=dep_reference)
                )
                
                if batch_entries.exists():
                    batch_updated = batch_entries.update(
                        Auth_Status=status,
                        Checker_Id_id=validated_user_id,
                        Checker_DT_Stamp=current_time
                    )
                    updated_entries.append(f"BATCH: {batch_updated} entries")
                    print(f"✅ ອັບເດດ SAMCSYS_detb_jrnl_batch: {batch_updated} entries")
                else:
                    print(f"ℹ️ ບໍ່ພົບ Journal BATCH entries")
                    
            except Exception as batch_error:
                print(f"❌ ອັບເດດ Journal BATCH ຜິດພາດ: {str(batch_error)}")
            
            return {
                'success': True,
                'updated_entries': updated_entries,
                'search_criteria': {
                    'asset_reference': asset_reference,
                    'ref_no_pattern': ref_no_pattern,
                    'dep_reference': dep_reference,
                    'asset_code_used': asset_code
                },
                'status_applied': status
            }
            
        except ImportError:
            print("⚠️ Journal models ບໍ່ມີ - ຂ້າມການອັບເດດ Journal")
            return {
                'success': False,
                'error': 'Journal models not available',
                'skipped': True
            }
            
    except Exception as e:
        print(f"💥 ອັບເດດ Journal entries ຜິດພາດ: {str(e)}")
        return {
            'success': False,
            'error': f"Journal update error: {str(e)}"
        }

def confirm_depreciation_fixed(aldm_id, status, reason=None, user_id=None):
    """
    ✅ FULLY FIXED: ຢືນຢັນການຫັກຄ່າເສື່ອມ + ແກ້ໄຂບັນຫາທັງໝົດ
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        if status not in ['A', 'R', 'P']:
            return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
        if status in ['R', 'P'] and not reason:
            return {"error": "ຕ້ອງລະບຸ reason ສຳລັບ Rejected ຫຼື Pending Revision"}
        
        with transaction.atomic():
            main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
            
            if main_record.Auth_Status not in ['U', 'P']:
                return {"error": f"ບໍ່ສາມາດປ່ຽນສະຖານະຂອງບັນທຶກທີ່ມີ Auth_Status = {main_record.Auth_Status}"}
            
            current_time = timezone.now()
            
            # ✅ 1. ອັບເດດ Main Record
            main_record.Auth_Status = status
            main_record.detail = reason if status in ['R', 'P'] else None
            main_record.Checker_Id_id = validated_user_id
            main_record.Checker_DT_Stamp = current_time
            main_record.save()
            
            # ✅ 2. ອັບເດດ Detail Record
            FA_Asset_List_Depreciation.objects.filter(
                asset_list_id=main_record.asset_list_id,
                dpca_date=main_record.dpca_date,
                dpca_value=main_record.dpca_value
            ).update(
                Auth_Status=status,
                detail=reason if status in ['R', 'P'] else None,
                Checker_Id_id=validated_user_id,
                Checker_DT_Stamp=current_time
            )
            
            # ✅ 3. ອັບເດດ Journal Entries (ແບບປອດໄພ)
            print(f"📝 ກຳລັງອັບເດດ Journal entries...")
            journal_update_result = update_related_journal_entries_safe(main_record, status, user_id)
            
            # ✅ 4. ຖ້າຢືນຢັນ (A), ອັບເດດທຸກຢ່າງ
            daily_log_result = None
            accounting_method_updated = False
            accounting_method_info = None
            
            if status == 'A':
                asset = main_record.asset_list_id
                
                # ອັບເດດ FA_Asset_Lists
                asset.C_dpac = str(int(asset.C_dpac or 0) + 1)
                asset.asset_accu_dpca_value = Decimal(str(main_record.accumulated_dpca))
                asset.asset_value_remain = Decimal(str(main_record.remaining_value))
                asset.asset_latest_date_dpca = main_record.dpca_date
                asset.save()
                print(f"✅ ອັບເດດ FA_Asset_Lists ສຳເລັດ")
                
                
                try:
                    accounting_method = FA_Accounting_Method.objects.filter(
                        Q(asset_list_id=asset) | Q(ref_id=str(asset.asset_list_id))
                    ).first()
                    
                    if accounting_method:
                        accounting_method.amount_end = main_record.remaining_value
                        accounting_method.amount = main_record.dpca_value
                        accounting_method.transaction_date = main_record.dpca_date
                        accounting_method.description = f"ອັບເດດຈາກການຢືນຢັນການຫັກຄ່າເສື່ອມ - {main_record.dpca_desc}"
                        accounting_method.Checker_Id_id = validated_user_id
                        accounting_method.Checker_DT_Stamp = current_time
                        accounting_method.save()
                        
                        accounting_method_updated = True
                        accounting_method_info = {
                            'mapping_id': accounting_method.mapping_id,
                            'amount_end_updated': float(accounting_method.amount_end),
                            'amount_updated': float(accounting_method.amount),
                            'transaction_date_updated': accounting_method.transaction_date.strftime('%d/%m/%Y')
                        }
                        print(f"✅ ອັບເດດ FA_Accounting_Method ສຳເລັດ")
                        
                except Exception as acc_error:
                    print(f"❌ ອັບເດດ FA_Accounting_Method ຜິດພາດ: {str(acc_error)}")
                    accounting_method_info = {'error': str(acc_error)}
                
                
                print(f"📊 ກຳລັງສ້າງ Daily Log entries...")
                daily_log_result = create_depreciation_daily_log_fixed(main_record, validated_user_id)
            
            return {
                'success': True,
                'message': f"ບັນທຶກ {aldm_id} ອັບເດດເປັນ {status} ສຳເລັດ",
                'user_id_used': validated_user_id,
                'status_set': status,
                'reason_set': reason if status in ['R', 'P'] else None,
                'fa_asset_updated': status == 'A',
                'fa_accounting_method_updated': accounting_method_updated,
                'accounting_method_info': accounting_method_info,
                'journal_entries_updated': journal_update_result,  
                'daily_log_created': daily_log_result if status == 'A' else None 
            }
        
    except Exception as e:
        return {"error": f"Fixed confirm depreciation error: {str(e)}"}

def bulk_confirm_depreciation_fixed(aldm_ids, status, reason=None, user_id=None):
    """
    ✅ FULLY FIXED: Bulk ຢືນຢັນ + ແກ້ໄຂບັນຫາທັງໝົດ
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        if status not in ['A', 'R', 'P']:
            return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
        if not aldm_ids or not isinstance(aldm_ids, list):
            return {"error": "ໃສ່ aldm_ids ເປັນ array"}
        
        results = []
        success_count = 0
        error_count = 0
        journal_updates_summary = []
        daily_log_summaries = []
        current_time = timezone.now()
        
        with transaction.atomic():
            for aldm_id in aldm_ids:
                # ໃຊ້ function ທີ່ fixed ແລ້ວ
                result = confirm_depreciation_fixed(aldm_id, status, reason, user_id)
                
                if result.get('success'):
                    results.append({
                        'aldm_id': aldm_id,
                        'status': 'success',
                        'message': result['message'],
                        'journal_entries_updated': result.get('journal_entries_updated'),
                        'daily_log_created': result.get('daily_log_created')
                    })
                    success_count += 1
                    
                    # ເກັບສະຫຼຸບ Journal updates
                    if result.get('journal_entries_updated'):
                        journal_updates_summary.append({
                            'aldm_id': aldm_id,
                            'journal_update': result['journal_entries_updated']
                        })
                    
                    # ເກັບສະຫຼຸບ Daily Log
                    if result.get('daily_log_created') and result['daily_log_created']['success']:
                        daily_log_summaries.append({
                            'aldm_id': aldm_id,
                            'daily_log': result['daily_log_created']
                        })
                else:
                    results.append({
                        'aldm_id': aldm_id,
                        'status': 'error',
                        'message': result.get('error', 'Unknown error')
                    })
                    error_count += 1
        
        # ຄຳນວນສະຖິຕິ
        total_journal_updates = len([j for j in journal_updates_summary if j['journal_update']['success']])
        total_daily_logs = len(daily_log_summaries)
        
        return {
            'success': True,
            'summary': {
                'total_items': len(aldm_ids),
                'success_count': success_count,
                'error_count': error_count,
                'status_applied': status,
                'reason_applied': reason if status in ['R', 'P'] else None,
                'processed_by': validated_user_id,
                'processed_at': current_time.strftime('%d/%m/%Y %H:%M:%S'),
                'journal_entries_updated': total_journal_updates,
                'daily_log_transactions': total_daily_logs
            },
            'details': results,
            'journal_updates_summary': journal_updates_summary,
            'daily_log_summaries': daily_log_summaries
        }
        
    except Exception as e:
        return {"error": f"Fixed bulk confirm error: {str(e)}"}


def bulk_confirm_depreciation_enhanced(aldm_ids, status, reason=None, user_id=None):
    """
    ✅ ENHANCED: Bulk ຢືນຢັນ + Journal + Daily Log
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        if status not in ['A', 'R', 'P']:
            return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
        if not aldm_ids or not isinstance(aldm_ids, list):
            return {"error": "ໃສ່ aldm_ids ເປັນ array"}
        
        results = []
        success_count = 0
        error_count = 0
        journal_updates_summary = []
        daily_log_summaries = []
        current_time = timezone.now()
        
        with transaction.atomic():
            for aldm_id in aldm_ids:
                # ໃຊ້ enhanced function
                result = confirm_depreciation_enhanced(aldm_id, status, reason, user_id)
                
                if result.get('success'):
                    results.append({
                        'aldm_id': aldm_id,
                        'status': 'success',
                        'message': result['message'],
                        'journal_entries_updated': result.get('journal_entries_updated'),
                        'daily_log_created': result.get('daily_log_created')
                    })
                    success_count += 1
                    
                    # ເກັບສະຫຼຸບ Journal updates
                    if result.get('journal_entries_updated'):
                        journal_updates_summary.append({
                            'aldm_id': aldm_id,
                            'journal_update': result['journal_entries_updated']
                        })
                    
                    # ເກັບສະຫຼຸບ Daily Log
                    if result.get('daily_log_created') and result['daily_log_created']['success']:
                        daily_log_summaries.append({
                            'aldm_id': aldm_id,
                            'daily_log': result['daily_log_created']
                        })
                else:
                    results.append({
                        'aldm_id': aldm_id,
                        'status': 'error',
                        'message': result.get('error', 'Unknown error')
                    })
                    error_count += 1
        
        # ຄຳນວນສະຖິຕິ
        total_journal_updates = len([j for j in journal_updates_summary if j['journal_update']['success']])
        total_daily_logs = len(daily_log_summaries)
        
        return {
            'success': True,
            'summary': {
                'total_items': len(aldm_ids),
                'success_count': success_count,
                'error_count': error_count,
                'status_applied': status,
                'reason_applied': reason if status in ['R', 'P'] else None,
                'processed_by': validated_user_id,
                'processed_at': current_time.strftime('%d/%m/%Y %H:%M:%S'),
                'journal_entries_updated': total_journal_updates,  # ✅ ສະຖິຕິ Journal
                'daily_log_transactions': total_daily_logs
            },
            'details': results,
            'journal_updates_summary': journal_updates_summary, 
            'daily_log_summaries': daily_log_summaries  
        }
        
    except Exception as e:
        return {"error": f"Enhanced bulk confirm error: {str(e)}"}
# def confirm_depreciation_with_daily_log(aldm_id, status, reason=None, user_id=None):
#     """
#     ✅ ENHANCED: ຢືນຢັນການຫັກຄ່າເສື່ອມ + ສ້າງ Daily Log (ແບບ Journal System)
#     """
#     try:
#         validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
#         if not validated_user_id:
#             return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
#         if status not in ['A', 'R', 'P']:
#             return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
#         if status in ['R', 'P'] and not reason:
#             return {"error": "ຕ້ອງລະບຸ reason ສຳລັບ Rejected ຫຼື Pending Revision"}
        
#         with transaction.atomic():
#             main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
            
#             if main_record.Auth_Status not in ['U', 'P']:
#                 return {"error": f"ບໍ່ສາມາດປ່ຽນສະຖານະຂອງບັນທຶກທີ່ມີ Auth_Status = {main_record.Auth_Status}"}
            
#             current_time = timezone.now()
            
#             # ✅ ອັບເດດ Main Record
#             main_record.Auth_Status = status
#             main_record.detail = reason if status in ['R', 'P'] else None
#             main_record.Checker_Id_id = validated_user_id
#             main_record.Checker_DT_Stamp = current_time
#             main_record.save()
            
#             # ✅ ອັບເດດ Detail Record
#             FA_Asset_List_Depreciation.objects.filter(
#                 asset_list_id=main_record.asset_list_id,
#                 dpca_date=main_record.dpca_date,
#                 dpca_value=main_record.dpca_value
#             ).update(
#                 Auth_Status=status,
#                 detail=reason if status in ['R', 'P'] else None,
#                 Checker_Id_id=validated_user_id,
#                 Checker_DT_Stamp=current_time
#             )
            
#             # ✅ ຖ້າຢືນຢັນ (A), ອັບເດດທຸກຢ່າງ + ສ້າງ Daily Log
#             daily_log_result = None
#             if status == 'A':
#                 asset = main_record.asset_list_id
                
#                 # 1. ອັບເດດ FA_Asset_Lists
#                 asset.C_dpac = str(int(asset.C_dpac or 0) + 1)
#                 asset.asset_accu_dpca_value = Decimal(str(main_record.accumulated_dpca))
#                 asset.asset_value_remain = Decimal(str(main_record.remaining_value))
#                 asset.asset_latest_date_dpca = main_record.dpca_date
#                 asset.save()
#                 print(f"✅ ອັບເດດ FA_Asset_Lists ສຳເລັດ - Asset ID: {asset.asset_list_id}")
                
#                 # 2. ອັບເດດ FA_Accounting_Method
#                 try:
#                     from django.db.models import Q
#                     accounting_method = FA_Accounting_Method.objects.filter(
#                         Q(asset_list_id=asset) | Q(ref_id=str(asset.asset_list_id))
#                     ).first()
                    
#                     if accounting_method:
#                         accounting_method.amount_end = main_record.remaining_value
#                         accounting_method.amount = main_record.dpca_value
#                         accounting_method.transaction_date = main_record.dpca_date
#                         accounting_method.description = f"ອັບເດດຈາກການຢືນຢັນການຫັກຄ່າເສື່ອມ - {main_record.dpca_desc}"
#                         accounting_method.Checker_Id_id = validated_user_id
#                         accounting_method.Checker_DT_Stamp = current_time
#                         accounting_method.save()
#                         print(f"✅ ອັບເດດ FA_Accounting_Method ສຳເລັດ - Mapping ID: {accounting_method.mapping_id}")
                        
#                         accounting_method_updated = True
#                         accounting_method_info = {
#                             'mapping_id': accounting_method.mapping_id,
#                             'amount_end_updated': float(accounting_method.amount_end),
#                             'amount_updated': float(accounting_method.amount),
#                             'transaction_date_updated': accounting_method.transaction_date.strftime('%d/%m/%Y')
#                         }
#                     else:
#                         print(f"⚠️ ບໍ່ພົບ FA_Accounting_Method ສຳລັບ Asset ID: {asset.asset_list_id}")
#                         accounting_method_updated = False
#                         accounting_method_info = {'error': 'Accounting method not found'}
                        
#                 except Exception as acc_method_error:
#                     print(f"❌ ອັບເດດ FA_Accounting_Method ຜິດພາດ: {str(acc_method_error)}")
#                     accounting_method_updated = False
#                     accounting_method_info = {'error': str(acc_method_error)}
                
#                 # ✅ 3. ສ້າງ Daily Log entries (ແບບ Journal System)
#                 print(f"📊 ກຳລັງສ້າງ Daily Log entries...")
#                 daily_log_result = create_depreciation_daily_log(main_record, validated_user_id)
                
#                 if daily_log_result['success']:
#                     print(f"✅ ສ້າງ Daily Log ສຳເລັດ: {daily_log_result}")
#                 else:
#                     print(f"❌ ສ້າງ Daily Log ຜິດພາດ: {daily_log_result['error']}")
#             else:
#                 accounting_method_updated = False
#                 accounting_method_info = {'skipped': f'Status is {status}, not approved'}
            
#             return {
#                 'success': True,
#                 'message': f"ບັນທຶກ {aldm_id} ອັບເດດເປັນ {status} ສຳເລັດ",
#                 'user_id_used': validated_user_id,
#                 'status_set': status,
#                 'reason_set': reason if status in ['R', 'P'] else None,
#                 'fa_asset_updated': status == 'A',
#                 'fa_accounting_method_updated': accounting_method_updated if status == 'A' else False,
#                 'accounting_method_info': accounting_method_info if status == 'A' else None,
#                 'daily_log_created': daily_log_result if status == 'A' else None  # ✅ ເພີ່ມຂໍ້ມູນ Daily Log
#             }
        
#     except Exception as e:
#         return {"error": f"Enhanced confirm depreciation error: {str(e)}"}
def confirm_depreciation_with_daily_log(aldm_id, status, reason=None, user_id=None):
    """
    ✅ ENHANCED: ຢືນຢັນການຫັກຄ່າເສື່ອມ + ສ້າງ Daily Log (ແບບ Journal System)
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        if status not in ['A', 'R', 'P']:
            return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
        if status in ['R', 'P'] and not reason:
            return {"error": "ຕ້ອງລະບຸ reason ສຳລັບ Rejected ຫຼື Pending Revision"}
        
        with transaction.atomic():
            main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
            
            if main_record.Auth_Status not in ['U', 'P']:
                return {"error": f"ບໍ່ສາມາດປ່ຽນສະຖານະຂອງບັນທຶກທີ່ມີ Auth_Status = {main_record.Auth_Status}"}
            
            current_time = timezone.now()
            
            # ✅ ອັບເດດ Main Record
            main_record.Auth_Status = status
            main_record.detail = reason if status in ['R', 'P'] else None
            main_record.Checker_Id_id = validated_user_id
            main_record.Checker_DT_Stamp = current_time
            main_record.save()
            
            # ✅ ອັບເດດ Detail Record
            FA_Asset_List_Depreciation.objects.filter(
                asset_list_id=main_record.asset_list_id,
                dpca_date=main_record.dpca_date,
                dpca_value=main_record.dpca_value
            ).update(
                Auth_Status=status,
                detail=reason if status in ['R', 'P'] else None,
                Checker_Id_id=validated_user_id,
                Checker_DT_Stamp=current_time
            )
            
            # ✅ ຖ້າຢືນຢັນ (A), ອັບເດດ FA_Asset_Lists + ສ້າງ Daily Log
            daily_log_result = None
            if status == 'A':
                asset = main_record.asset_list_id
                
                # 1. ອັບເດດ FA_Asset_Lists
                asset.C_dpac = str(int(asset.C_dpac or 0) + 1)
                asset.asset_accu_dpca_value = Decimal(str(main_record.accumulated_dpca))
                asset.asset_value_remain = Decimal(str(main_record.remaining_value))
                asset.asset_latest_date_dpca = main_record.dpca_date
                asset.save()
                print(f"✅ ອັບເດດ FA_Asset_Lists ສຳເລັດ - Asset ID: {asset.asset_list_id}")
                
                # ✅ 2. ສ້າງ Daily Log entries (ແບບ Journal System)
                print(f"📊 ກຳລັງສ້າງ Daily Log entries...")
                daily_log_result = create_depreciation_daily_log(main_record, validated_user_id)
                
                if daily_log_result['success']:
                    print(f"✅ ສ້າງ Daily Log ສຳເລັດ: {daily_log_result}")
                else:
                    print(f"❌ ສ້າງ Daily Log ຜິດພາດ: {daily_log_result['error']}")
            
            return {
                'success': True,
                'message': f"ບັນທຶກ {aldm_id} ອັບເດດເປັນ {status} ສຳເລັດ",
                'user_id_used': validated_user_id,
                'status_set': status,
                'reason_set': reason if status in ['R', 'P'] else None,
                'fa_asset_updated': status == 'A',
                'daily_log_created': daily_log_result if status == 'A' else None  # ✅ ເພີ່ມຂໍ້ມູນ Daily Log
            }
        
    except Exception as e:
        return {"error": f"Enhanced confirm depreciation error: {str(e)}"}
def bulk_confirm_depreciation_with_daily_log(aldm_ids, status, reason=None, user_id=None):
    """
    ✅ ENHANCED: Bulk ຢືນຢັນ + ສ້າງ Daily Log ແບບ Journal System
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        if status not in ['A', 'R', 'P']:
            return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
        if status in ['R', 'P'] and not reason:
            return {"error": "ຕ້ອງລະບຸ reason ສຳລັບ Rejected ຫຼື Pending Revision"}
        
        if not aldm_ids or not isinstance(aldm_ids, list):
            return {"error": "ໃສ່ aldm_ids ເປັນ array ເຊັ່ນ [88, 89, 90]"}
        
        results = []
        success_count = 0
        error_count = 0
        accounting_method_updates = []
        daily_log_summaries = []  # ✅ ເກັບສະຫຼຸບ Daily Log
        current_time = timezone.now()
        
        with transaction.atomic():
            for aldm_id in aldm_ids:
                # ໃຊ້ function ໃໝ່ທີ່ມີ Daily Log
                result = confirm_depreciation_with_daily_log(aldm_id, status, reason, user_id)
                
                if result.get('success'):
                    results.append({
                        'aldm_id': aldm_id,
                        'status': 'success',
                        'message': result['message'],
                        'fa_asset_updated': result.get('fa_asset_updated', False),
                        'fa_accounting_method_updated': result.get('fa_accounting_method_updated', False),
                        'daily_log_created': result.get('daily_log_created')
                    })
                    success_count += 1
                    
                    # ເກັບຂໍ້ມູນ Daily Log
                    if result.get('daily_log_created') and result['daily_log_created']['success']:
                        daily_log_summaries.append({
                            'aldm_id': aldm_id,
                            'reference_no': result['daily_log_created']['reference_no'],
                            'entries_created': result['daily_log_created']['daily_log_entries_created'],
                            'hist_entries_created': result['daily_log_created']['daily_log_hist_entries_created']
                        })
                    
                    # ເກັບຂໍ້ມູນ Accounting Method
                    if result.get('accounting_method_info'):
                        accounting_method_updates.append({
                            'aldm_id': aldm_id,
                            'accounting_method_info': result['accounting_method_info']
                        })
                else:
                    results.append({
                        'aldm_id': aldm_id,
                        'status': 'error',
                        'message': result.get('error', 'Unknown error')
                    })
                    error_count += 1
        
        # ຄຳນວນສະຖິຕິ Daily Log
        total_daily_log_entries = sum([item['entries_created'] for item in daily_log_summaries])
        total_daily_log_hist = sum([item['hist_entries_created'] for item in daily_log_summaries])
        
        return {
            'success': True,
            'summary': {
                'total_items': len(aldm_ids),
                'success_count': success_count,
                'error_count': error_count,
                'status_applied': status,
                'reason_applied': reason if status in ['R', 'P'] else None,
                'processed_by': validated_user_id,
                'processed_at': current_time.strftime('%d/%m/%Y %H:%M:%S'),
                'accounting_method_updates_count': len(accounting_method_updates),
                'daily_log_entries_created': total_daily_log_entries,  # ✅ ສະຖິຕິ Daily Log
                'daily_log_hist_created': total_daily_log_hist,
                'daily_log_transactions': len(daily_log_summaries)
            },
            'details': results,
            'accounting_method_updates': accounting_method_updates,
            'daily_log_summaries': daily_log_summaries  # ✅ ລາຍລະອຽດ Daily Log
        }
        
    except Exception as e:
        return {"error": f"Enhanced bulk confirm error: {str(e)}"}


def update_related_journal_entries(depreciation_record, status, user_id=None):
    """
    ✅ ອັບເດດ Journal Entries ທີ່ກ່ຽວຂ້ອງກັບການຫັກຄ່າເສື່ອມ
    """
    try:
        from django.utils import timezone
        
        asset = depreciation_record.asset_list_id
        current_time = timezone.now()
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        
        # ສ້າງ search patterns
        asset_reference = f"FIX-001-{depreciation_record.dpca_month}-{getattr(asset, 'asset_code', '') or str(asset.asset_list_id).zfill(7)}"
        ref_no_pattern = f"AS-ARD-{depreciation_record.dpca_date.strftime('%Y%m%d')}"
        
        updated_entries = []
        
        try:
            # ພະຍາຍາມ import Journal models
            from .models import SAMCSYS_detb_jrnl_log, SAMCSYS_detb_jrnl_batch
            
            print(f"🔍 ຊອກຫາ Journal entries:")
            print(f"   - Asset reference: {asset_reference}")
            print(f"   - Ref pattern: {ref_no_pattern}")
            
            # ✅ 1. ອັບເດດ SAMCSYS_detb_jrnl_log
            try:
                journal_entries = SAMCSYS_detb_jrnl_log.objects.filter(
                    Q(Ac_relatives=asset_reference) |
                    Q(Reference_No__startswith=ref_no_pattern)
                )
                
                if journal_entries.exists():
                    log_updated = journal_entries.update(
                        Auth_Status=status,
                        Checker_Id_id=validated_user_id,
                        Checker_DT_Stamp=current_time
                    )
                    updated_entries.append(f"LOG: {log_updated} entries")
                    print(f"✅ ອັບເດດ SAMCSYS_detb_jrnl_log: {log_updated} entries")
                else:
                    print(f"ℹ️ ບໍ່ພົບ Journal LOG entries")
                    
            except Exception as log_error:
                print(f"❌ ອັບເດດ Journal LOG ຜິດພາດ: {str(log_error)}")
            
           
            try:
                batch_entries = SAMCSYS_detb_jrnl_batch.objects.filter(
                    Reference_No__startswith=ref_no_pattern
                )
                
                if batch_entries.exists():
                    batch_updated = batch_entries.update(
                        Auth_Status=status,
                        Checker_Id_id=validated_user_id,
                        Checker_DT_Stamp=current_time
                    )
                    updated_entries.append(f"BATCH: {batch_updated} entries")
                    print(f"✅ ອັບເດດ SAMCSYS_detb_jrnl_batch: {batch_updated} entries")
                else:
                    print(f"ℹ️ ບໍ່ພົບ Journal BATCH entries")
                    
            except Exception as batch_error:
                print(f"❌ ອັບເດດ Journal BATCH ຜິດພາດ: {str(batch_error)}")
            
            return {
                'success': True,
                'updated_entries': updated_entries,
                'search_criteria': {
                    'asset_reference': asset_reference,
                    'ref_no_pattern': ref_no_pattern
                },
                'status_applied': status
            }
            
        except ImportError:
            print("⚠️ Journal models ບໍ່ມີ - ຂ້າມການອັບເດດ Journal")
            return {
                'success': False,
                'error': 'Journal models not available',
                'skipped': True
            }
            
    except Exception as e:
        print(f"💥 ອັບເດດ Journal entries ຜິດພາດ: {str(e)}")
        return {
            'success': False,
            'error': f"Journal update error: {str(e)}"
        }
def confirm_depreciation_with_journal_update(aldm_id, status, reason=None, user_id=None):
    """
    ✅ ENHANCED: ຢືນຢັນການຫັກຄ່າເສື່ອມ + ອັບເດດ Journal + Daily Log
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        if status not in ['A', 'R', 'P']:
            return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
        if status in ['R', 'P'] and not reason:
            return {"error": "ຕ້ອງລະບຸ reason ສຳລັບ Rejected ຫຼື Pending Revision"}
        
        with transaction.atomic():
            main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
            
            if main_record.Auth_Status not in ['U', 'P']:
                return {"error": f"ບໍ່ສາມາດປ່ຽນສະຖານະຂອງບັນທຶກທີ່ມີ Auth_Status = {main_record.Auth_Status}"}
            
            current_time = timezone.now()
            
           
            main_record.Auth_Status = status
            main_record.detail = reason if status in ['R', 'P'] else None
            main_record.Checker_Id_id = validated_user_id
            main_record.Checker_DT_Stamp = current_time
            main_record.save()
            
            FA_Asset_List_Depreciation.objects.filter(
                asset_list_id=main_record.asset_list_id,
                dpca_date=main_record.dpca_date,
                dpca_value=main_record.dpca_value
            ).update(
                Auth_Status=status,
                detail=reason if status in ['R', 'P'] else None,
                Checker_Id_id=validated_user_id,
                Checker_DT_Stamp=current_time
            )
            
           
            print(f"📝 ກຳລັງອັບເດດ Journal entries...")
            journal_update_result = update_related_journal_entries(main_record, status, user_id)
            
           
            daily_log_result = None
            accounting_method_updated = False
            accounting_method_info = None
            
            if status == 'A':
                asset = main_record.asset_list_id
                
                # ອັບເດດ FA_Asset_Lists
                asset.C_dpac = str(int(asset.C_dpac or 0) + 1)
                asset.asset_accu_dpca_value = Decimal(str(main_record.accumulated_dpca))
                asset.asset_value_remain = Decimal(str(main_record.remaining_value))
                asset.asset_latest_date_dpca = main_record.dpca_date
                asset.save()
                print(f"✅ ອັບເດດ FA_Asset_Lists ສຳເລັດ")
                
                # ອັບເດດ FA_Accounting_Method
                try:
                    from django.db.models import Q
                    accounting_method = FA_Accounting_Method.objects.filter(
                        Q(asset_list_id=asset) | Q(ref_id=str(asset.asset_list_id))
                    ).first()
                    
                    if accounting_method:
                        accounting_method.amount_end = main_record.remaining_value
                        accounting_method.amount = main_record.dpca_value
                        accounting_method.transaction_date = main_record.dpca_date
                        accounting_method.description = f"ອັບເດດຈາກການຢືນຢັນການຫັກຄ່າເສື່ອມ - {main_record.dpca_desc}"
                        accounting_method.Checker_Id_id = validated_user_id
                        accounting_method.Checker_DT_Stamp = current_time
                        accounting_method.save()
                        
                        accounting_method_updated = True
                        accounting_method_info = {
                            'mapping_id': accounting_method.mapping_id,
                            'amount_end_updated': float(accounting_method.amount_end),
                            'amount_updated': float(accounting_method.amount),
                            'transaction_date_updated': accounting_method.transaction_date.strftime('%d/%m/%Y')
                        }
                        print(f"✅ ອັບເດດ FA_Accounting_Method ສຳເລັດ")
                        
                except Exception as acc_error:
                    print(f"❌ ອັບເດດ FA_Accounting_Method ຜິດພາດ: {str(acc_error)}")
                    accounting_method_info = {'error': str(acc_error)}
                
                # ສ້າງ Daily Log entries
                print(f"📊 ກຳລັງສ້າງ Daily Log entries...")
                daily_log_result = create_depreciation_daily_log(main_record, validated_user_id)
            
            return {
                'success': True,
                'message': f"ບັນທຶກ {aldm_id} ອັບເດດເປັນ {status} ສຳເລັດ",
                'user_id_used': validated_user_id,
                'status_set': status,
                'reason_set': reason if status in ['R', 'P'] else None,
                'fa_asset_updated': status == 'A',
                'fa_accounting_method_updated': accounting_method_updated,
                'accounting_method_info': accounting_method_info,
                'daily_log_created': daily_log_result if status == 'A' else None,
                'journal_entries_updated': journal_update_result  # ✅ ເພີ່ມຂໍ້ມູນ Journal update
            }
        
    except Exception as e:
        return {"error": f"Enhanced confirm with journal update error: {str(e)}"}
def bulk_confirm_depreciation_with_journal_update(aldm_ids, status, reason=None, user_id=None):
    """
    ✅ ENHANCED: Bulk ຢືນຢັນ + ອັບເດດ Journal + Daily Log
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        if status not in ['A', 'R', 'P']:
            return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
        if not aldm_ids or not isinstance(aldm_ids, list):
            return {"error": "ໃສ່ aldm_ids ເປັນ array"}
        
        results = []
        success_count = 0
        error_count = 0
        journal_updates_summary = []
        daily_log_summaries = []
        current_time = timezone.now()
        
        with transaction.atomic():
            for aldm_id in aldm_ids:
                # ໃຊ້ function ໃໝ່ທີ່ມີ Journal update
                result = confirm_depreciation_with_journal_update(aldm_id, status, reason, user_id)
                
                if result.get('success'):
                    results.append({
                        'aldm_id': aldm_id,
                        'status': 'success',
                        'message': result['message'],
                        'journal_entries_updated': result.get('journal_entries_updated'),
                        'daily_log_created': result.get('daily_log_created')
                    })
                    success_count += 1
                    
                    # ເກັບສະຫຼຸບ Journal updates
                    if result.get('journal_entries_updated'):
                        journal_updates_summary.append({
                            'aldm_id': aldm_id,
                            'journal_update': result['journal_entries_updated']
                        })
                    
                    # ເກັບສະຫຼຸບ Daily Log
                    if result.get('daily_log_created') and result['daily_log_created']['success']:
                        daily_log_summaries.append({
                            'aldm_id': aldm_id,
                            'daily_log': result['daily_log_created']
                        })
                else:
                    results.append({
                        'aldm_id': aldm_id,
                        'status': 'error',
                        'message': result.get('error', 'Unknown error')
                    })
                    error_count += 1
        
        # ຄຳນວນສະຖິຕິ
        total_journal_updates = len([j for j in journal_updates_summary if j['journal_update']['success']])
        total_daily_logs = len(daily_log_summaries)
        
        return {
            'success': True,
            'summary': {
                'total_items': len(aldm_ids),
                'success_count': success_count,
                'error_count': error_count,
                'status_applied': status,
                'reason_applied': reason if status in ['R', 'P'] else None,
                'processed_by': validated_user_id,
                'processed_at': current_time.strftime('%d/%m/%Y %H:%M:%S'),
                'journal_entries_updated': total_journal_updates,  # ✅ ສະຖິຕິ Journal
                'daily_log_transactions': total_daily_logs
            },
            'details': results,
            'journal_updates_summary': journal_updates_summary,  # ✅ ລາຍລະອຽດ Journal updates
            'daily_log_summaries': daily_log_summaries
        }
        
    except Exception as e:
        return {"error": f"Enhanced bulk confirm with journal error: {str(e)}"}

def create_depreciation_history(asset, depreciation_data, user_id=None, in_month_record_id=None):
    """
    ✅ FIXED: ບໍ່ໃຊ້ Auth_Status ໃນ InMonth Records
    """
    try:
        if user_id:
            validated_user_id = validate_user_id(user_id)
        else:
            validated_user_id = get_current_user_id()
        
        if not validated_user_id:
            print("Warning: ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ - ຈະບັນທຶກໂດຍບໍ່ມີ user")
        
        current_time = timezone.now()
        depreciation_date = depreciation_data['period_start']
        
        description = f"ຫັກຄ່າຫຼູ້ຍຫຽ້ນເດືອນທີ່ {depreciation_data['month_number']} ({depreciation_data['month_year']})"
        
        main_record_data = {
            'asset_list_id': asset,
            'dpca_year': str(depreciation_date.year),
            'dpca_month': f"{depreciation_date.year}-{depreciation_date.month:02d}",
            'dpca_date': depreciation_date,
            'dpca_value': Decimal(str(depreciation_data['monthly_depreciation'])),
            'dpca_no_of_days': depreciation_data['days_count'],
            'remaining_value': Decimal(str(depreciation_data['remaining_value'])),
            'accumulated_dpca': Decimal(str(depreciation_data['new_accumulated'])),
            'dpca_desc': description,
            'dpca_ac_yesno': 'N',
            'dpca_datetime': current_time,
            'Record_Status': 'C',
            'Auth_Status': 'U',  # ✅ ໃຊ້ໃນ Main & Detail ເທົ່ານັ້ນ
        }
        
        # ✅ เชื่อมต่อ aldm_month_id
        if in_month_record_id:
            try:
                in_month_record = FA_Asset_List_Depreciation_InMonth.objects.get(aldim_id=in_month_record_id)
                main_record_data['aldm_month_id'] = in_month_record
            except FA_Asset_List_Depreciation_InMonth.DoesNotExist:
                print(f"Warning: InMonth record {in_month_record_id} ບໍ່ມີຢູ່")
        
        if validated_user_id:
            main_record_data['Maker_Id_id'] = validated_user_id
            main_record_data['Maker_DT_Stamp'] = current_time
        
        # ✅ ສ້າງ Main Record
        main_record = FA_Asset_List_Depreciation_Main.objects.create(**main_record_data)
        print(f"✅ ສ້າງ Main Record (Unauthorized): {main_record.aldm_id}")
        
        # ✅ ສ້າງ/ອັບເດດ Detail Record
        existing_record = FA_Asset_List_Depreciation.objects.filter(
            asset_list_id=asset
        ).order_by('-dpca_date').first()
        
        detail_record_data = {
            'dpca_date': depreciation_date,
            'dpca_value': Decimal(str(depreciation_data['monthly_depreciation'])),
            'dpca_no_of_days': depreciation_data['days_count'],
            'remaining_value': Decimal(str(depreciation_data['remaining_value'])),
            'accumulated_dpca': Decimal(str(depreciation_data['new_accumulated'])),
            'dpca_desc': description,
            'dpca_ac_yesno': 'N',
            'dpca_datetime': current_time,
            'Record_Status': 'C',
            'Auth_Status': 'U',  # ✅ ໃຊ້ໃນ Detail
        }
        
        # ✅ เชื่อมต่อ aldm_id  
        if in_month_record_id:
            try:
                in_month_record = FA_Asset_List_Depreciation_InMonth.objects.get(aldim_id=in_month_record_id)
                detail_record_data['aldm_id'] = in_month_record
            except FA_Asset_List_Depreciation_InMonth.DoesNotExist:
                print(f"Warning: InMonth record {in_month_record_id} ບໍ່ມີຢູ່")
        
        if validated_user_id:
            detail_record_data['Maker_Id_id'] = validated_user_id
            detail_record_data['Maker_DT_Stamp'] = current_time
        
        if existing_record:
            for key, value in detail_record_data.items():
                setattr(existing_record, key, value)
            existing_record.save()
            detail_record_id = existing_record.ald_id
            operation_type = "UPDATE"
            print(f"✅ ອັບເດດ Detail Record (Unauthorized): {detail_record_id}")
        else:
            detail_record_data['asset_list_id'] = asset
            detail_record = FA_Asset_List_Depreciation.objects.create(**detail_record_data)
            detail_record_id = detail_record.ald_id
            operation_type = "INSERT"
            print(f"✅ ສ້າງ Detail Record (Unauthorized): {detail_record_id}")
        
        return {
            'main_record_id': main_record.aldm_id,
            'detail_record_id': detail_record_id,
            'detail_operation': operation_type,
            'success': True,
            'user_id_used': validated_user_id,
            'linked_in_month_id': in_month_record_id,
            'auth_status': 'U'
        }
        
    except Exception as e:
        print(f"💥 create_depreciation_history error: {str(e)}")
        return {
            'success': False,
            'error': f"History recording error: {str(e)}"
        }

def create_depreciation_in_month_record(result_data, user_id=None):
    """
    ✅ FIXED: ໃຊ້ timezone.now()
    """
    try:
        if user_id:
            validated_user_id = validate_user_id(user_id)
        else:
            validated_user_id = get_current_user_id()
        
        if not validated_user_id:
            print("Warning: ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ - ຈະບັນທຶກໂດຍບໍ່ມີ user")
        
        current_time = timezone.now()  # ✅ FIXED: ໃຊ້ timezone.now()
        
        # ດຶງຂໍ້ມູນຈາກ result_data
        summary = result_data['summary']
        total_items = summary['total_items']
        success = summary.get('success', True)
        
        # ຄຳນວນຜົນບວກຂອງ monthly_depreciation
        total_depreciation = Decimal('0.00')
        for detail in result_data['details']:
            if detail['status'] == 'success' and 'depreciation_processed' in detail:
                total_depreciation += Decimal(str(detail['depreciation_processed']['monthly_depreciation']))
        
        # ປ່ຽນ timestamp ໃຫ້ເປັນຮູບແບບ YYYY-MM
        timestamp_str = result_data.get('timestamp', current_time.isoformat())
        try:
            timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
        except:
            timestamp = current_time
        dpca_month = timestamp.strftime('%Y-%m')
        
        # ກຳນົດສະຖານະ
        dpca_status = 'SUCCESS' if success else 'FAILED'
        
        # ສ້າງຂໍ້ມູນສຳລັບບັນທຶກ
        in_month_record_data = {
            'dpca_month': dpca_month,
            'C_dpca': str(total_items),
            'dpca_value': total_depreciation.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP),
            'dpca_status': dpca_status,
            'Record_Status': 'C',
        }
        
        if validated_user_id:
            in_month_record_data['Maker_Id_id'] = validated_user_id
            in_month_record_data['Maker_DT_Stamp'] = current_time
            in_month_record_data['Checker_Id_id'] = validated_user_id
            in_month_record_data['Checker_DT_Stamp'] = current_time
        
        # ✅ ບັນທຶກລົງຕາຕະລາງ
        in_month_record = FA_Asset_List_Depreciation_InMonth.objects.create(**in_month_record_data)
        print(f"✅ ສ້າງ InMonth Record: {in_month_record.aldim_id}")
        
        return {
            'success': True,
            'in_month_record_id': in_month_record.aldim_id,
            'user_id_used': validated_user_id
        }
        
    except Exception as e:
        print(f"💥 create_depreciation_in_month_record error: {str(e)}")
        return {
            'success': False,
            'error': f"In-month recording error: {str(e)}"
        }

def get_depreciation_history(asset_list_id, limit=None):
    """
    ✅ MINOR UPDATE: ເພີ່ມການສະແດງ linked_in_month_id
    """
    try:
        query = FA_Asset_List_Depreciation_Main.objects.filter(
            asset_list_id=asset_list_id
        ).order_by('-dpca_date')
        
        if limit:
            query = query[:limit]
        
        history = []
        for record in query:
            history.append({
                'aldm_id': record.aldm_id,
                'year': record.dpca_year,
                'month': record.dpca_month,
                'date': record.dpca_date.strftime('%d/%m/%Y'),
                'depreciation_value': float(record.dpca_value or 0),
                'days_count': record.dpca_no_of_days,
                'remaining_value': float(record.remaining_value or 0),
                'accumulated_dpca': float(record.accumulated_dpca or 0),
                'description': record.dpca_desc,
                'is_accounted': record.dpca_ac_yesno == 'Y',
                'account_date': record.dpca_ac_date.strftime('%d/%m/%Y') if record.dpca_ac_date else None,
                'created_datetime': record.dpca_datetime.strftime('%d/%m/%Y %H:%M:%S') if record.dpca_datetime else None,
                'record_status': record.Record_Status,
                'linked_in_month_id': record.aldm_month_id.aldim_id if record.aldm_month_id else None  # ✅ NEW
            })
        
        return {
            'success': True,
            'history': history,
            'total_records': len(history)
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Get history error: {str(e)}"
        }


def mark_depreciation_as_accounted(aldm_id, user_id=None):
    """
    ✅ FIXED: ໃຊ້ timezone.now() ແທນ datetime.now()
    ໝາຍການຫັກຄ່າເສື່ອມລາຄາວ່າບັນຊີແລ້ວ
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        current_time = timezone.now()  # ✅ FIXED: ໃຊ້ timezone.now()
        
        main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
        
        # ✅ NEW: ກວດສອບວ່າເປັນ Authorized ກ່ອນ
        if main_record.Auth_Status != 'A':
            return {
                'success': False,
                'error': f"Record {aldm_id} ຍັງບໍ່ຖືກຢືນຢັນ (Auth_Status = {main_record.Auth_Status})"
            }
        
        main_record.dpca_ac_yesno = 'Y'
        main_record.dpca_ac_date = current_time.date()
        
        if validated_user_id:
            main_record.dpca_ac_by = validated_user_id
            main_record.Checker_Id_id = validated_user_id
            main_record.Checker_DT_Stamp = current_time
        
        main_record.save()
        
        update_data = {
            'dpca_ac_yesno': 'Y',
            'dpca_ac_date': current_time.date(),
        }
        
        if validated_user_id:
            update_data['dpca_ac_by'] = validated_user_id
            update_data['Checker_Id_id'] = validated_user_id
            update_data['Checker_DT_Stamp'] = current_time
        
        FA_Asset_List_Depreciation.objects.filter(
            asset_list_id=main_record.asset_list_id,
            dpca_date=main_record.dpca_date,
            dpca_value=main_record.dpca_value
        ).update(**update_data)
        
        return {
            'success': True,
            'message': f'ໝາຍບັນຊີສຳເລັດ - Record ID: {aldm_id}',
            'user_id_used': validated_user_id
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Mark as accounted error: {str(e)}"
        }

def calculate_depreciation_schedule(mapping_id):
    """ຄິດຄ່າເສື່ອມລາຄາ - ບໍ່ປ່ຽນແປງ FA_Asset_Lists"""
    try:
        try:
            accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
        except FA_Accounting_Method.DoesNotExist:
            return {"error": f"ບໍ່ພົບ mapping_id: {mapping_id}"}
        
        try:
            if accounting_method.asset_list_id:
                asset = accounting_method.asset_list_id
            elif accounting_method.ref_id:
                asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
            else:
                return {"error": "ບໍ່ມີຂໍ້ມູນ asset_list_id ຫຼື ref_id"}
        except FA_Asset_Lists.DoesNotExist:
            return {"error": f"ບໍ່ພົບຊັບສິນ: {accounting_method.ref_id}"}
        
        if not asset.asset_value:
            return {"error": "ບໍ່ມີມູນຄ່າຊັບສິນ"}
        if not asset.asset_useful_life:
            return {"error": "ບໍ່ມີອາຍຸການໃຊ້ງານ"}
        if not asset.dpca_start_date:
            return {"error": "ບໍ່ມີວັນທີເລີ່ມຕົ້ນ"}
        
        original_asset_value = float(asset.asset_value)
        original_salvage_value = float(asset.asset_salvage_value or 0)
        total_depreciable = float(asset.accu_dpca_value_total or 0)
        useful_life = int(asset.asset_useful_life)
        start_date = asset.dpca_start_date
        
        virtual_asset_value = total_depreciable
        virtual_salvage_value = 0
        
        end_date = start_date + relativedelta(years=useful_life) - timedelta(days=1)
        total_days = (end_date - start_date + timedelta(days=1)).days
        
        depreciable_amount = virtual_asset_value - virtual_salvage_value
        daily_depreciation = depreciable_amount / total_days
        
        current_count = int(asset.C_dpac or 0)
        total_months = useful_life * 12
        remaining_months = total_months - current_count
        can_depreciate = current_count < total_months
        is_completed = current_count >= total_months
        
        result = {
            'asset_info': {
                'asset_id': asset.asset_list_id,
                'asset_name': asset.asset_spec or 'N/A',
                'original_asset_value': original_asset_value,
                'original_salvage_value': original_salvage_value,
                'virtual_asset_value': virtual_asset_value,
                'virtual_salvage_value': virtual_salvage_value,
                'useful_life': useful_life,
                'depreciation_method': asset.dpca_type or 'SL'
            },
            'calculation_info': {
                'start_date': start_date.strftime('%d/%m/%Y'),
                'end_date': end_date.strftime('%d/%m/%Y'),
                'total_days': total_days,
                'depreciable_amount': round(depreciable_amount, 2),
                'daily_depreciation': round(daily_depreciation, 2)
            },
            'depreciation_status': {
                'total_months': total_months,
                'current_count': current_count,
                'remaining_months': remaining_months,
                'can_depreciate': can_depreciate,
                'is_completed': is_completed,
                'completion_percentage': round((current_count / total_months) * 100, 2)
            }
        }
        
        return result
        
    except Exception as e:
        return {"error": f"General error: {str(e)}"}

def get_status_message_90k_to_zero(current_count, total_months, target_accumulated):
    """ສ້າງຂໍ້ຄວາມສະຖານະ - ສຳລັບ 90k → 0"""
    if current_count >= total_months:
        return f"✅ ຫັກຄົບ {target_accumulated:,.0f} ກີບ! ມູນຄ່າຄົງເຫຼືອ = 0 ({current_count}/{total_months} ເດືອນ)"
    elif current_count == 0:
        return f"🆕 ຍັງບໍ່ໄດ້ເລີ່ມຫັກ (0/{total_months} ເດືອນ) - ຈະຫັກ {target_accumulated:,.0f} ກີບ → 0"
    else:
        remaining = total_months - current_count
        return f"⏳ ກຳລັງຫັກ ({current_count}/{total_months} ເດືອນ) - ເຫຼືອ {remaining} ເດືອນ ເພື່ອຫັກຄົບ {target_accumulated:,.0f} ກີບ → 0"


def get_status_message(current_count, total_months):
    """ສ້າງຂໍ້ຄວາມສະຖານະ"""
    if current_count >= total_months:
        return f"✅ ຫັກຄົບຖ້ວນແລ້ວ! ({current_count}/{total_months} ເດືອນ)"
    elif current_count == 0:
        return f"🆕 ຍັງບໍ່ໄດ້ເລີ່ມຫັກ (0/{total_months} ເດືອນ)"
    else:
        remaining = total_months - current_count
        return f"⏳ ກຳລັງຫັກ ({current_count}/{total_months} ເດືອນ) - ເຫຼືອ {remaining} ເດືອນ"

# def process_monthly_depreciation(mapping_id, user_id=None, date=None):
#     """ຫັກຄ່າເສື່ອມລາຄາ 1 ເດືອນ"""
#     try:
#         calc_result = calculate_depreciation_schedule(mapping_id)
#         if 'error' in calc_result:
#             return calc_result
        
#         if not calc_result['depreciation_status']['can_depreciate']:
#             return {
#                 "error": "ຫັກຄົບມູນຄ່າທີ່ສາມາດຫັກເສື່ອມໄດ້ແລ້ວ!",
#                 "current_status": calc_result['depreciation_status']
#             }
        
#         accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
#         if accounting_method.asset_list_id:
#             asset = accounting_method.asset_list_id
#         else:
#             asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
        
#         current_count = int(asset.C_dpac or 0)
#         next_month = current_count + 1
        
#         start_date = asset.dpca_start_date
#         useful_life = int(asset.asset_useful_life)
#         total_months = useful_life * 12
        
#         asset_value = Decimal(str(asset.asset_value or 0))
#         salvage_value = Decimal(str(asset.asset_salvage_value or 0))
#         depreciable_amount = asset_value - salvage_value
        
#         annual_depreciation = depreciable_amount / Decimal(str(useful_life))
#         monthly_depreciation = (annual_depreciation / Decimal('12')).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
        
#         target_date = datetime.strptime(date, '%Y-%m-%d').date() if date else start_date + relativedelta(months=current_count)
        
#         if next_month == 1:
#             month_actual_start = start_date
#             month_end = datetime(target_date.year, target_date.month,
#                                get_last_day_of_month(target_date.year, target_date.month)).date()
#         else:
#             month_actual_start = datetime(target_date.year, target_date.month, 1).date()
#             month_end = datetime(target_date.year, target_date.month,
#                                get_last_day_of_month(target_date.year, target_date.month)).date()
        
#         days_in_month = (month_end - month_actual_start + timedelta(days=1)).days
#         total_days_in_month = get_last_day_of_month(target_date.year, target_date.month)
        
#         monthly_depreciation_value = (monthly_depreciation * Decimal(str(days_in_month)) / Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
        
#         old_accumulated = Decimal(str(asset.asset_accu_dpca_value or 0))
#         new_accumulated = old_accumulated + monthly_depreciation_value
#         new_remaining = asset_value - new_accumulated
        
#         return {
#             'success': True,
#             'depreciation_processed': {
#                 'month_number': next_month,
#                 'month_year': f"{get_month_name_la(month_actual_start.month)} {month_actual_start.year}",
#                 'period': f"{month_actual_start.strftime('%d/%m/%Y')} - {month_end.strftime('%d/%m/%Y')}",
#                 'days_count': days_in_month,
#                 'total_days_in_month': total_days_in_month,
#                 'monthly_depreciation': float(monthly_depreciation_value),
#                 'old_accumulated': float(old_accumulated),
#                 'new_accumulated': float(new_accumulated),
#                 'remaining_value': float(new_remaining)
#             }
#         }
        
#     except Exception as e:
#         return {"error": f"Process error: {str(e)}"}
def process_monthly_depreciation(mapping_id, user_id=None, date=None):
    """ຫັກຄ່າເສື່ອມລາຄາ 1 ເດືອນ - ວິທີ Vue.js: ໃຊ້ຈຳນວນມື້ຕົວຈິງ, ຮັບປະກັນມູນຄ່າສະສົມຄົບ depreciable_amount"""
    try:
        # ກວດສອບສະຖານະກ່ອນ
        calc_result = calculate_depreciation_schedule(mapping_id)
        if 'error' in calc_result:
            return calc_result
        
        if not calc_result['depreciation_status']['can_depreciate']:
            return {
                "error": "ຫັກຄົບມູນຄ່າທີ່ສາມາດຫັກເສື່ອມໄດ້ແລ້ວ! ມູນຄ່າຄົງເຫຼືອ = salvage_value",
                "current_status": calc_result['depreciation_status']
            }
        
        # ດຶງຂໍ້ມູນ
        accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
        if accounting_method.asset_list_id:
            asset = accounting_method.asset_list_id
        else:
            asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
        
        current_count = int(asset.C_dpac or 0)
        next_month = current_count + 1
        
        start_date = asset.dpca_start_date
        useful_life = int(asset.asset_useful_life)
        total_months = useful_life * 12
        end_date = start_date + relativedelta(years=useful_life) - timedelta(days=1)
        
        # ✅ ຂໍ້ມູນພື້ນຖານ (ໃຊ້ Decimal ເພື່ອຄວາມແມ່ນຍຳ)
        asset_value = Decimal(str(asset.asset_value or 0))  
        accu_dpca_value_total = Decimal(str(asset.accu_dpca_value_total))  # depreciable_amount
        salvage_value = Decimal(str(asset.asset_salvage_value or 0))  
        depreciable_amount = asset_value - salvage_value  
        
        # ຄ່າເສື່ອມຕໍ່ປີ ແລະ ຕໍ່ເດືອນ
        annual_depreciation = depreciable_amount / Decimal(str(useful_life))
        monthly_depreciation = (annual_depreciation / Decimal('12')).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
        
        # ✅ ກວດສອບວ່າເປັນເດືອນສຸດທ້າຍບໍ່
        is_last_month = (next_month == total_months)
        
        # ✅ ຄິດວັນທີ່ (ຮອງຮັບ date parameter)
        if date:
            target_date = datetime.strptime(date, '%Y-%m-%d').date()
            # ໃຊ້ target_date ສຳລັບການຄິດເດືອນ
            if next_month == 1:
                month_actual_start = start_date
                month_end = datetime(target_date.year, target_date.month,
                                   get_last_day_of_month(target_date.year, target_date.month)).date()
            else:
                month_actual_start = datetime(target_date.year, target_date.month, 1).date()
                month_end = datetime(target_date.year, target_date.month,
                                   get_last_day_of_month(target_date.year, target_date.month)).date()
        else:
            # ໃຊ້ start_date + months ແບບເດີມ
            month_start_date = start_date + relativedelta(months=current_count)
            if next_month == 1:
                month_actual_start = start_date
                month_end = datetime(month_start_date.year, month_start_date.month,
                                   get_last_day_of_month(month_start_date.year, month_start_date.month)).date()
            else:
                month_actual_start = datetime(month_start_date.year, month_start_date.month, 1).date()
                month_end = datetime(month_start_date.year, month_start_date.month,
                                   get_last_day_of_month(month_start_date.year, month_start_date.month)).date()
        
        # ກວດສອບວ່າເປັນເດືອນສຸດທ້າຍບໍ່
        if month_end > end_date:
            month_end = end_date
        
        # ✅ ຄິດຈຳນວນມື້ຕົວຈິງ
        days_in_month = (month_end - month_actual_start + timedelta(days=1)).days
        total_days_in_month = get_last_day_of_month(month_actual_start.year, month_actual_start.month)
        
        # ✅ ການຄິດຄ່າເສື່ອມລາຄາໃໝ່ (ຕາມວິທີ Vue.js)
        old_accumulated = Decimal(str(asset.asset_accu_dpca_value or 0))
        
        # ✅ ປະກາດຕົວແປສຳລັບ setup_value ແລະ end_value
        setup_value = Decimal('0')
        end_value = Decimal('0')
        
        if next_month == 1:
            # 🎯 ງວດທຳອິດ: ມູນຄ່າຕົ້ນງວດ
            setup_value = (monthly_depreciation * Decimal(str(days_in_month)) / Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            monthly_depreciation_value = setup_value
            end_value = (monthly_depreciation - setup_value).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            new_accumulated = monthly_depreciation_value  # ບໍ່ບວກ old ເພາະ old = 0
            new_remaining = accu_dpca_value_total - new_accumulated
            calculation_note = f"ງວດທຳອິດ - ມູນຄ່າຕົ້ນງວດ = ({monthly_depreciation:,.2f} × {days_in_month}) ÷ {total_days_in_month} = {monthly_depreciation_value:,.2f} ກີບ"
            
            print(f"🎯 ງວດທຳອິດ (ເດືອນທີ່ {next_month}):")
            print(f"   - ວັນໃຊ້ຈິງ: {days_in_month}/{total_days_in_month} ມື້")
            print(f"   - ຄ່າເສື່ອມຕໍ່ເດືອນ: {monthly_depreciation:,.2f}")
            print(f"   - ມູນຄ່າຕົ້ນງວດ: {setup_value:,.2f}")
            print(f"   - ມູນຄ່າທ້າຍງວດ: {end_value:,.2f}")
            print(f"   - Accumulated: {new_accumulated:,.2f}")
            print(f"   - Remaining: {new_remaining:,.2f}")
            
        elif is_last_month:
            # 🎯 ງວດສຸດທ້າຍ: ຄ່າເສື່ອມ = ມູນຄ່າທີ່ເຫຼືອຈົນກວ່າຈະຄົບ depreciable_amount
            remaining_to_depreciate = depreciable_amount - old_accumulated
            monthly_depreciation_value = remaining_to_depreciate.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            new_accumulated = old_accumulated + monthly_depreciation_value
            new_remaining = accu_dpca_value_total - new_accumulated
            end_value = Decimal('0')  # ບໍ່ມີມູນຄ່າທ້າຍງວດໃນເດືອນສຸດທ້າຍ
            calculation_note = f"ງວດສຸດທ້າຍ - ຫັກຄົບ {depreciable_amount:,.0f} ກີບ (ຄ່າເສື່ອມ = {monthly_depreciation_value:,.2f})"
            
            print(f"🎯 ງວດສຸດທ້າຍ (ເດືອນທີ່ {next_month}):")
            print(f"   - ເປົ້າໝາຍ: ຫັກຄົບ {depreciable_amount:,.0f} ກີບ")
            print(f"   - ຫັກມາແລ້ວ: {old_accumulated:,.2f}")
            print(f"   - ຄ່າເສື່ອມເດືອນນີ້: {monthly_depreciation_value:,.2f}")
            print(f"   - Accumulated: {new_accumulated:,.2f}")
            print(f"   - Remaining: {new_remaining:,.2f}")
            
        else:
            # 🎯 ງວດປົກກະຕິ: ຫັກຕາມວັນທີ່ແທ້ຈິງ
            monthly_depreciation_value = (monthly_depreciation * Decimal(str(days_in_month)) / Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            new_accumulated = old_accumulated + monthly_depreciation_value
            new_remaining = accu_dpca_value_total - new_accumulated
            end_value = Decimal('0')  
            calculation_note = f"ງວດປົກກະຕິ - ຄ່າເສື່ອມ = ({monthly_depreciation:,.2f} × {days_in_month}) ÷ {total_days_in_month} = {monthly_depreciation_value:,.2f}"
            
            print(f"🎯 ງວດປົກກະຕິ (ເດືອນທີ່ {next_month}):")
            print(f"   - ວັນໃຊ້ຈິງ: {days_in_month}/{total_days_in_month} ມື້")
            print(f"   - ຄ່າເສື່ອມເດືອນນີ້: {monthly_depreciation_value:,.2f}")
            print(f"   - Accumulated: {new_accumulated:,.2f}")
            print(f"   - Remaining: {new_remaining:,.2f}")
        
        # 📝 ກວດສອບຄວາມຖືກຕ້ອງ
        if new_accumulated > depreciable_amount:
            monthly_depreciation_value = (monthly_depreciation_value - (new_accumulated - depreciable_amount)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            new_accumulated = depreciable_amount
            new_remaining = asset_value - new_accumulated  # ໃຊ້ asset_value ໃນ safety check
            calculation_note += f" | ປັບປ່ຽນເພື່ອໃຫ້ accumulated = {depreciable_amount:,.0f}"
        
        
        return {
            'success': True,
            'depreciation_processed': {
                'month_number': next_month,
                'month_year': f"{get_month_name_la(month_actual_start.month)} {month_actual_start.year}",
                'period': f"{month_actual_start.strftime('%d/%m/%Y')} - {month_end.strftime('%d/%m/%Y')}",
                'days_count': days_in_month,
                'total_days_in_month': total_days_in_month,
                'monthly_depreciation': float(monthly_depreciation_value),
                'setup_value': float(setup_value) if next_month == 1 else None,
                'end_value': float(end_value) if next_month == 1 else None,
                'old_accumulated': float(old_accumulated),
                'new_accumulated': float(new_accumulated),
                'remaining_value': float(new_remaining),
                'is_final_month': is_last_month,
                'calculation_note': calculation_note,
                'target_achieved': f"ຫັກຄົບ {depreciable_amount:,.0f} ກີບ, Remaining = {salvage_value:,.0f}" if is_last_month else None
            },
            'updated_status': {
                'C_dpac': next_month,
                'total_months': total_months,
                'remaining_months': total_months - next_month,
                'is_completed': next_month >= total_months,
                'final_achieved': new_accumulated >= depreciable_amount and new_remaining <= salvage_value if is_last_month else None
            }
        }
        
    except Exception as e:
        return {"error": f"Process error: {str(e)}"}


# ✅ ຕົວຢ່າງການໃຊ້ງານ
"""
# ການໃຊ້ແບບປົກກະຕິ (ໃຊ້ວັນທີ່ຈາກ start_date + months)
result = process_monthly_depreciation(mapping_id=123, user_id=456)

# ການໃຊ້ດ້ວຍວັນທີ່ສະເພາະ
result = process_monthly_depreciation(mapping_id=123, user_id=456, date='2024-03-15')

# ຜົນລັບທີ່ໄດ້:
{
    'success': True,
    'depreciation_processed': {
        'month_number': 1,
        'monthly_depreciation': 8226.00,
        'setup_value': 8226.00,        # ມີແຕ່ເດືອນທຳອິດ
        'end_value': 6774.00,          # ມີແຕ່ເດືອນທຳອິດ
        'is_final_month': False,
        'calculation_note': 'ງວດທຳອິດ - ມູນຄ່າຕົ້ນງວດ = ...',
        'target_achieved': None        # ມີແຕ່ເດືອນສຸດທ້າຍ
    },
    'updated_status': {
        'C_dpac': 1,
        'total_months': 60,
        'remaining_months': 59,
        'is_completed': False
    }
}
"""

def process_monthly_depreciation_with_inmonth(mapping_id, user_id=None, in_month_record_id=None, date=None):
    """
    ✅ FIXED: ຫັກຄ່າເສື່ອມລາຄາ 1 ເດືອນ - ບໍ່ອັບເດດ FA_Asset_Lists (ລໍຖ້າຢືນຢັນ)
    """
    try:
        # ດຳເນີນການຫັກຄ່າເສື່ອມລາຄາ
        result = process_monthly_depreciation(mapping_id, user_id, date)
        
        if not result.get('success'):
            return result
        
        # ✅ ບັນທຶກປະຫວັດ (ແຕ່ບໍ່ອັບເດດ FA_Asset_Lists)
        try:
            # ດຶງຂໍ້ມູນ asset
            accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
            if accounting_method.asset_list_id:
                asset = accounting_method.asset_list_id
            else:
                asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
            
            # ສ້າງຂໍ້ມູນສຳລັບບັນທຶກປະຫວັດ
            depreciation_data = {
                'period_start': datetime.strptime(date, '%Y-%m-%d').date() if date else asset.dpca_start_date + relativedelta(months=int(asset.C_dpac or 0)),
                'monthly_depreciation': result['depreciation_processed']['monthly_depreciation'],
                'remaining_value': result['depreciation_processed']['remaining_value'],
                'new_accumulated': result['depreciation_processed']['new_accumulated'],
                'month_number': result['depreciation_processed']['month_number'],
                'month_year': result['depreciation_processed']['month_year'],
                'days_count': result['depreciation_processed']['days_count']
            }
            
            # ✅ ບັນທຶກປະຫວັດ (ສະຖານະ Unauthorized)
            history_result = create_depreciation_history(
                asset, depreciation_data, user_id, in_month_record_id
            )
            
            if history_result['success']:
                # ❌ ລຶບສ່ວນນີ້ອອກ - ບໍ່ອັບເດດ FA_Asset_Lists ຕອນນີ້!
                # asset.C_dpac = str(int(asset.C_dpac or 0) + 1)
                # asset.asset_accu_dpca_value = Decimal(str(depreciation_data['new_accumulated']))
                # asset.asset_value_remain = Decimal(str(depreciation_data['remaining_value']))
                # asset.asset_latest_date_dpca = depreciation_data['period_start']
                # asset.save()
                
                result['history_records'] = history_result
                print(f"✅ ບັນທຶກປະຫວັດສຳເລັດ (ລໍຖ້າຢືນຢັນ) - mapping_id: {mapping_id}")
            else:
                result['history_records'] = history_result
                print(f"❌ ບັນທຶກປະຫວັດຜິດພາດ - mapping_id: {mapping_id}")
                
        except Exception as history_error:
            print(f"💥 ບັນທຶກປະຫວັດ error: {str(history_error)}")
            result['history_records'] = {
                'success': False,
                'error': f"History recording error: {str(history_error)}"
            }
        
        return result
        
    except Exception as e:
        return {"error": f"Process with InMonth error: {str(e)}"}
def process_bulk_depreciation(mapping_ids, check_only=False, user_id=None):
    """ຫັກຄ່າເສື່ອມລາຄາຫຼາຍລາຍການ"""
    try:
        results = []
        success_count = 0
        error_count = 0
        
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        
        for mapping_id in mapping_ids:
            try:
                if check_only:
                    calc_result = calculate_depreciation_schedule(mapping_id)
                    if 'error' in calc_result:
                        results.append({
                            'mapping_id': mapping_id,
                            'status': 'error',
                            'message': calc_result['error']
                        })
                        error_count += 1
                    else:
                        can_depreciate = calc_result['depreciation_status']['can_depreciate']
                        results.append({
                            'mapping_id': mapping_id,
                            'status': 'ready' if can_depreciate else 'completed',
                            'asset_name': calc_result['asset_info']['asset_name'],
                            'can_depreciate': can_depreciate
                        })
                        if can_depreciate:
                            success_count += 1
                else:
                    process_result = process_monthly_depreciation_with_inmonth(mapping_id, validated_user_id, None)
                    if 'error' in process_result:
                        results.append({
                            'mapping_id': mapping_id,
                            'status': 'error',
                            'message': process_result['error']
                        })
                        error_count += 1
                    else:
                        results.append({
                            'mapping_id': mapping_id,
                            'status': 'success',
                            'message': f"ຫັກເດືອນທີ່ {process_result['depreciation_processed']['month_number']} ສຳເລັດ",
                            'depreciation_processed': process_result['depreciation_processed']
                        })
                        success_count += 1
                        
            except Exception as e:
                results.append({
                    'mapping_id': mapping_id,
                    'status': 'error',
                    'message': f"Processing error: {str(e)}"
                })
                error_count += 1
        
        return {
            'summary': {
                'total_items': len(mapping_ids),
                'success_count': success_count,
                'error_count': error_count,
                'check_only': check_only,
                'user_id_used': validated_user_id
            },
            'details': results
        }
        
    except Exception as e:
        return {"error": f"Bulk processing error: {str(e)}"}
# ✅ NEW: ຟັງຊັນໃຫມ່ສຳລັບການຢືນຢັນ/ປະຕິເສດ
# def confirm_depreciation(aldm_id, status, reason=None, user_id=None):
#     """
#     ✅ FORCED DEBUG: ຢືນຢັນການຫັກຄ່າເສື່ອມ + ບັງຄັບ debug
#     """
#     try:
#         print(f"🎯 [FORCE] confirm_depreciation called: aldm_id={aldm_id}, status={status}")
        
#         validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
#         if not validated_user_id:
#             return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
#         if status not in ['A', 'R', 'P']:
#             return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
#         if status in ['R', 'P'] and not reason:
#             return {"error": "ຕ້ອງລະບຸ reason ສຳລັບ Rejected ຫຼື Pending Revision"}
        
#         with transaction.atomic():
#             main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
            
#             if main_record.Auth_Status not in ['U', 'P']:
#                 return {"error": f"ບໍ່ສາມາດປ່ຽນສະຖານະຂອງບັນທຶກທີ່ມີ Auth_Status = {main_record.Auth_Status}"}
            
#             current_time = timezone.now()
            
#             # ✅ 1. ອັບເດດ Main Record
#             main_record.Auth_Status = status
#             main_record.detail = reason if status in ['R', 'P'] else None
#             main_record.Checker_Id_id = validated_user_id
#             main_record.Checker_DT_Stamp = current_time
#             main_record.save()
#             print(f"✅ [FORCE] Updated main_record: {aldm_id}")
            
#             # ✅ 2. ອັບເດດ Detail Record
#             FA_Asset_List_Depreciation.objects.filter(
#                 asset_list_id=main_record.asset_list_id,
#                 dpca_date=main_record.dpca_date,
#                 dpca_value=main_record.dpca_value
#             ).update(
#                 Auth_Status=status,
#                 detail=reason if status in ['R', 'P'] else None,
#                 Checker_Id_id=validated_user_id,
#                 Checker_DT_Stamp=current_time
#             )
#             print(f"✅ [FORCE] Updated detail records")
            
#             # ✅ 3. ຖ້າຢືນຢັນ (A), ອັບເດດທຸກຢ່າງ + Auto Approve Journals
#             journal_auto_approval = None
#             accounting_method_updated = False
#             accounting_method_info = None
            
#             if status == 'A':
#                 print(f"🔍 [FORCE] Status is A, proceeding...")
#                 asset = main_record.asset_list_id
#                 asset_list_id = asset.asset_list_id
#                 print(f"🔍 [FORCE] Asset ID: {asset_list_id}")
                
#                 # 3.1 ອັບເດດ FA_Asset_Lists
#                 asset.C_dpac = str(int(asset.C_dpac or 0) + 1)
#                 asset.asset_accu_dpca_value = Decimal(str(main_record.accumulated_dpca))
#                 asset.asset_value_remain = Decimal(str(main_record.remaining_value))
#                 asset.asset_latest_date_dpca = main_record.dpca_date
#                 asset.save()
#                 print(f"✅ ອັບເດດ FA_Asset_Lists ສຳເລັດ - Asset ID: {asset.asset_list_id}")
                
#                 # 3.2 ອັບເດດ FA_Accounting_Method
#                 try:
#                     accounting_method = FA_Accounting_Method.objects.filter(
#                         Q(asset_list_id=asset) | Q(ref_id=str(asset.asset_list_id))
#                     ).first()
                    
#                     if accounting_method:
#                         accounting_method.amount_end = main_record.remaining_value
#                         accounting_method.amount = main_record.dpca_value
#                         accounting_method.transaction_date = main_record.dpca_date
#                         accounting_method.description = f"ອັບເດດຈາກການຢືນຢັນການຫັກຄ່າເສື່ອມ - {main_record.dpca_desc}"
#                         accounting_method.Checker_Id_id = validated_user_id
#                         accounting_method.Checker_DT_Stamp = current_time
#                         accounting_method.save()
                        
#                         accounting_method_updated = True
#                         accounting_method_info = {
#                             'mapping_id': accounting_method.mapping_id,
#                             'amount_end_updated': float(accounting_method.amount_end),
#                             'amount_updated': float(accounting_method.amount),
#                             'transaction_date_updated': accounting_method.transaction_date.strftime('%d/%m/%Y')
#                         }
#                         print(f"✅ ອັບເດດ FA_Accounting_Method ສຳເລັດ - Mapping ID: {accounting_method.mapping_id}")
                        
#                 except Exception as acc_error:
#                     print(f"❌ ອັບເດດ FA_Accounting_Method ຜິດພາດ: {str(acc_error)}")
#                     accounting_method_info = {'error': str(acc_error)}
                
#                 # ✅ 3.3 ບັງຄັບກວດສອບ journal entries ກ່ອນ
#                 print(f"🔍 [FORCE] Checking journal entries for asset: {asset_list_id}")
#                 check_result = check_journal_entries_for_asset(asset_list_id)
#                 print(f"📊 [FORCE] Check result: {check_result}")
                
#                 # ✅ 3.4 ອັດຕະໂນມັດ approve journal entries
#                 try:
#                     print(f"🔍 [FORCE] About to call auto_approve_related_journals...")
                    
#                     # ✅ ບັງຄັບເອີ້ນ function
#                     journal_auto_approval = auto_approve_related_journals(asset_list_id)
                    
#                     print(f"📊 [FORCE] auto_approve_related_journals result: {journal_auto_approval}")
                    
#                     if journal_auto_approval and journal_auto_approval.get('success') and journal_auto_approval.get('approved_count', 0) > 0:
#                         print(f"✅ [FORCE] Auto approved {journal_auto_approval['approved_count']} journals")
#                     else:
#                         print(f"ℹ️ [FORCE] No journals approved or function failed")
#                         # ✅ ບັງຄັບສ້າງ result ຖ້າເປັນ None
#                         if journal_auto_approval is None:
#                             journal_auto_approval = {
#                                 'success': False,
#                                 'message': 'auto_approve_related_journals returned None',
#                                 'approved_count': 0,
#                                 'reference_numbers': [],
#                                 'debug_check': check_result
#                             }
                        
#                 except Exception as journal_error:
#                     print(f"⚠️ [FORCE] Journal auto approval error: {str(journal_error)}")
#                     import traceback
#                     traceback.print_exc()
#                     journal_auto_approval = {
#                         'success': False,
#                         'error': f"Journal auto approval error: {str(journal_error)}",
#                         'approved_count': 0,
#                         'reference_numbers': [],
#                         'debug_check': check_result
#                     }
#             else:
#                 print(f"🔍 [FORCE] Status is {status}, skipping journal approval")
#                 journal_auto_approval = {
#                     'success': False,
#                     'message': f'Skipped journal approval - status is {status}, not A',
#                     'approved_count': 0,
#                     'reference_numbers': []
#                 }
            
#             # ✅ 4. ສ້າງ message ທີ່ລວມ journal approval
#             base_message = f"ບັນທຶກ {aldm_id} ອັບເດດເປັນ {status} ສຳເລັດ"
#             if status == 'A' and journal_auto_approval and journal_auto_approval.get('success') and journal_auto_approval.get('approved_count', 0) > 0:
#                 base_message += f" + Auto approved {journal_auto_approval['approved_count']} journal entries"
            
#             print(f"✅ [FORCE] Final journal_auto_approval: {journal_auto_approval}")
            
#             return {
#                 'success': True,
#                 'message': base_message,
#                 'user_id_used': validated_user_id,
#                 'status_set': status,
#                 'reason_set': reason if status in ['R', 'P'] else None,
#                 'fa_asset_updated': status == 'A',
#                 'fa_accounting_method_updated': accounting_method_updated,
#                 'accounting_method_info': accounting_method_info,
#                 'journal_auto_approval': journal_auto_approval  # ✅ ຈະບໍ່ເປັນ null ແລ້ວ
#             }
        
#     except Exception as e:
#         print(f"💥 [FORCE] Confirm depreciation error: {str(e)}")
#         import traceback
#         traceback.print_exc()
#         return {"error": f"Confirm depreciation error: {str(e)}"}
# def confirm_depreciation(aldm_id, status, reason=None, user_id=None):
#     """
#     ✅ FORCED DEBUG: ຢືນຢັນການຫັກຄ່າເສື່ອມ + ບັງຄັບ debug
#     """
#     try:
#         print(f"🎯 [FORCE] confirm_depreciation called: aldm_id={aldm_id}, status={status}")
        
#         validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
#         if not validated_user_id:
#             return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
#         if status not in ['A', 'R', 'P']:
#             return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
#         if status in ['R', 'P'] and not reason:
#             return {"error": "ຕ້ອງລະບຸ reason ສຳລັບ Rejected ຫຼື Pending Revision"}
        
#         with transaction.atomic():
#             main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
            
#             if main_record.Auth_Status not in ['U', 'P']:
#                 return {"error": f"ບໍ່ສາມາດປ່ຽນສະຖານະຂອງບັນທຶກທີ່ມີ Auth_Status = {main_record.Auth_Status}"}
            
#             current_time = timezone.now()
            
#             # ✅ 1. ອັບເດດ Main Record
#             main_record.Auth_Status = status
#             main_record.detail = reason if status in ['R', 'P'] else None
#             main_record.Checker_Id_id = validated_user_id
#             main_record.Checker_DT_Stamp = current_time
#             main_record.save()
#             print(f"✅ [FORCE] Updated main_record: {aldm_id}")
            
#             # ✅ 2. ອັບເດດ Detail Record
#             FA_Asset_List_Depreciation.objects.filter(
#                 asset_list_id=main_record.asset_list_id,
#                 dpca_date=main_record.dpca_date,
#                 dpca_value=main_record.dpca_value
#             ).update(
#                 Auth_Status=status,
#                 detail=reason if status in ['R', 'P'] else None,
#                 Checker_Id_id=validated_user_id,
#                 Checker_DT_Stamp=current_time
#             )
#             print(f"✅ [FORCE] Updated detail records")
            
#             # ✅ 3. ຖ້າຢືນຢັນ (A), ອັບເດດ FA_Asset_Lists + Auto Approve Journals
#             journal_auto_approval = None
            
#             if status == 'A':
#                 print(f"🔍 [FORCE] Status is A, proceeding...")
#                 asset = main_record.asset_list_id
#                 asset_list_id = asset.asset_list_id
#                 print(f"🔍 [FORCE] Asset ID: {asset_list_id}")
                
#                 # 3.1 ອັບເດດ FA_Asset_Lists
#                 asset.C_dpac = str(int(asset.C_dpac or 0) + 1)
#                 asset.asset_accu_dpca_value = Decimal(str(main_record.accumulated_dpca))
#                 asset.asset_value_remain = Decimal(str(main_record.remaining_value))
#                 asset.asset_latest_date_dpca = main_record.dpca_date
#                 asset.save()
#                 print(f"✅ ອັບເດດ FA_Asset_Lists ສຳເລັດ - Asset ID: {asset.asset_list_id}")
                
#                 # ✅ 3.2 ບັງຄັບກວດສອບ journal entries ກ່ອນ
#                 print(f"🔍 [FORCE] Checking journal entries for asset: {asset_list_id}")
#                 check_result = check_journal_entries_for_asset(asset_list_id)
#                 print(f"📊 [FORCE] Check result: {check_result}")
                
#                 # ✅ 3.3 ອັດຕະໂນມັດ approve journal entries
#                 try:
#                     print(f"🔍 [FORCE] About to call auto_approve_related_journals...")
                    
#                     # ✅ ບັງຄັບເອີ້ນ function
#                     journal_auto_approval = auto_approve_related_journals(asset_list_id)
                    
#                     print(f"📊 [FORCE] auto_approve_related_journals result: {journal_auto_approval}")
                    
#                     if journal_auto_approval and journal_auto_approval.get('success') and journal_auto_approval.get('approved_count', 0) > 0:
#                         print(f"✅ [FORCE] Auto approved {journal_auto_approval['approved_count']} journals")
#                     else:
#                         print(f"ℹ️ [FORCE] No journals approved or function failed")
#                         # ✅ ບັງຄັບສ້າງ result ຖ້າເປັນ None
#                         if journal_auto_approval is None:
#                             journal_auto_approval = {
#                                 'success': False,
#                                 'message': 'auto_approve_related_journals returned None',
#                                 'approved_count': 0,
#                                 'reference_numbers': [],
#                                 'debug_check': check_result
#                             }
                        
#                 except Exception as journal_error:
#                     print(f"⚠️ [FORCE] Journal auto approval error: {str(journal_error)}")
#                     import traceback
#                     traceback.print_exc()
#                     journal_auto_approval = {
#                         'success': False,
#                         'error': f"Journal auto approval error: {str(journal_error)}",
#                         'approved_count': 0,
#                         'reference_numbers': [],
#                         'debug_check': check_result
#                     }
#             else:
#                 print(f"🔍 [FORCE] Status is {status}, skipping journal approval")
#                 journal_auto_approval = {
#                     'success': False,
#                     'message': f'Skipped journal approval - status is {status}, not A',
#                     'approved_count': 0,
#                     'reference_numbers': []
#                 }
            
#             # ✅ 4. ສ້າງ message ທີ່ລວມ journal approval
#             base_message = f"ບັນທຶກ {aldm_id} ອັບເດດເປັນ {status} ສຳເລັດ"
#             if status == 'A' and journal_auto_approval and journal_auto_approval.get('success') and journal_auto_approval.get('approved_count', 0) > 0:
#                 base_message += f" + Auto approved {journal_auto_approval['approved_count']} journal entries"
            
#             print(f"✅ [FORCE] Final journal_auto_approval: {journal_auto_approval}")
            
#             return {
#                 'success': True,
#                 'message': base_message,
#                 'user_id_used': validated_user_id,
#                 'status_set': status,
#                 'reason_set': reason if status in ['R', 'P'] else None,
#                 'fa_asset_updated': status == 'A',
#                 'journal_auto_approval': journal_auto_approval  # ✅ ຈະບໍ່ເປັນ null ແລ້ວ
#             }
        
#     except Exception as e:
#         print(f"💥 [FORCE] Confirm depreciation error: {str(e)}")
#         import traceback
#         traceback.print_exc()
#         return {"error": f"Confirm depreciation error: {str(e)}"}
def confirm_depreciation(aldm_id, status, reason=None, user_id=None):
    """
    ✅ FORCED DEBUG: ຢືນຢັນການຫັກຄ່າເສື່ອມ + ບັງຄັບ debug + Fixed C_dpac calculation
    """
    try:
        print(f"🎯 [FORCE] confirm_depreciation called: aldm_id={aldm_id}, status={status}")
        
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        if status not in ['A', 'R', 'P']:
            return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
        if status in ['R', 'P'] and not reason:
            return {"error": "ຕ້ອງລະບຸ reason ສຳລັບ Rejected ຫຼື Pending Revision"}
        
        with transaction.atomic():
            main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
            
            if main_record.Auth_Status not in ['U', 'P']:
                return {"error": f"ບໍ່ສາມາດປ່ຽນສະຖານະຂອງບັນທຶກທີ່ມີ Auth_Status = {main_record.Auth_Status}"}
            
            current_time = timezone.now()
            
            # ✅ 1. ອັບເດດ Main Record
            main_record.Auth_Status = status
            main_record.detail = reason if status in ['R', 'P'] else None
            main_record.Checker_Id_id = validated_user_id
            main_record.Checker_DT_Stamp = current_time
            main_record.save()
            print(f"✅ [FORCE] Updated main_record: {aldm_id}")
            
            # ✅ 2. ອັບເດດ Detail Record
            FA_Asset_List_Depreciation.objects.filter(
                asset_list_id=main_record.asset_list_id,
                dpca_date=main_record.dpca_date,
                dpca_value=main_record.dpca_value
            ).update(
                Auth_Status=status,
                detail=reason if status in ['R', 'P'] else None,
                Checker_Id_id=validated_user_id,
                Checker_DT_Stamp=current_time
            )
            print(f"✅ [FORCE] Updated detail records")
            
            # ✅ 3. ຖ້າຢືນຢັນ (A), ອັບເດດ FA_Asset_Lists + Auto Approve Journals
            journal_auto_approval = None
            
            if status == 'A':
                print(f"🔍 [FORCE] Status is A, proceeding...")
                asset = main_record.asset_list_id
                asset_list_id = asset.asset_list_id
                print(f"🔍 [FORCE] Asset ID: {asset_list_id}")
                
                # 3.1 ອັບເດດ FA_Asset_Lists - ✨ ວິທີການໃໝ່ສຳລັບ C_dpac
                dpca_no_of_days = main_record.dpca_no_of_days or 0
                print(f"🔍 [FORCE-C_DPAC-DEBUG] dpca_no_of_days: {dpca_no_of_days}")
                print(f"🔍 [FORCE-C_DPAC-DEBUG] Asset current C_dpac: {asset.C_dpac}")
                
                if dpca_no_of_days <= 31:
                    # ຖ້າ <= 31 ວັນ: ເພີ່ມ 1
                    c_dpac_increment = 1
                    print(f"📊 [FORCE-C_DPAC-DEBUG] dpca_no_of_days <= 31, increment by 1")
                else:
                    # ຖ້າ > 31 ວັນ: ຫານດ້ວຍ 30 ແລ້ວປັດເປັນເລກຖ້ວນ
                    c_dpac_increment = round(dpca_no_of_days / 30)
                    print(f"📊 [FORCE-C_DPAC-DEBUG] dpca_no_of_days > 31, increment by round({dpca_no_of_days}/30) = {c_dpac_increment}")
                
                # ອັບເດດຄ່າໃນ database
                current_c_dpac = Decimal(str(asset.C_dpac or 0))
                new_c_dpac = current_c_dpac + Decimal(str(c_dpac_increment))
                
                print(f"🎯 [FORCE-C_DPAC-DEBUG] CALCULATION: {current_c_dpac} + {c_dpac_increment} = {new_c_dpac}")
                
                asset.C_dpac = str(new_c_dpac)
                asset.asset_accu_dpca_value = Decimal(str(main_record.accumulated_dpca))
                asset.asset_value_remain = Decimal(str(main_record.remaining_value))
                asset.asset_latest_date_dpca = main_record.dpca_date
                asset.save()
                
                print(f"✅ [FORCE-C_DPAC-DEBUG] ອັບເດດ FA_Asset_Lists ສຳເລັດ - Asset ID: {asset.asset_list_id}")
                print(f"📊 [FORCE-C_DPAC-DEBUG] FINAL C_dpac: {new_c_dpac}")
                print(f"🎯 [FORCE-C_DPAC-DEBUG] ===== C_DPAC CALCULATION COMPLETE =====")
                
                # ✅ 3.2 ບັງຄັບກວດສອບ journal entries ກ່ອນ
                print(f"🔍 [FORCE] Checking journal entries for asset: {asset_list_id}")
                try:
                    check_result = check_journal_entries_for_asset(asset_list_id)
                    print(f"📊 [FORCE] Check result: {check_result}")
                except:
                    check_result = {'error': 'check_journal_entries_for_asset function not found'}
                    print(f"⚠️ [FORCE] Could not check journal entries: {check_result}")
                
                # ✅ 3.3 ອັດຕະໂນມັດ approve journal entries
                try:
                    print(f"🔍 [FORCE] About to call auto_approve_related_journals...")
                    
                    # ✅ ບັງຄັບເອີ້ນ function
                    try:
                        journal_auto_approval = auto_approve_related_journals(asset_list_id)
                    except:
                        print(f"⚠️ [FORCE] auto_approve_related_journals function not found, using fallback")
                        journal_auto_approval = {
                            'success': False,
                            'message': 'auto_approve_related_journals function not available',
                            'approved_count': 0,
                            'reference_numbers': []
                        }
                    
                    print(f"📊 [FORCE] auto_approve_related_journals result: {journal_auto_approval}")
                    
                    if journal_auto_approval and journal_auto_approval.get('success') and journal_auto_approval.get('approved_count', 0) > 0:
                        print(f"✅ [FORCE] Auto approved {journal_auto_approval['approved_count']} journals")
                    else:
                        print(f"ℹ️ [FORCE] No journals approved or function failed")
                        # ✅ ບັງຄັບສ້າງ result ຖ້າເປັນ None
                        if journal_auto_approval is None:
                            journal_auto_approval = {
                                'success': False,
                                'message': 'auto_approve_related_journals returned None',
                                'approved_count': 0,
                                'reference_numbers': [],
                                'debug_check': check_result if 'check_result' in locals() else None
                            }
                        
                except Exception as journal_error:
                    print(f"⚠️ [FORCE] Journal auto approval error: {str(journal_error)}")
                    import traceback
                    traceback.print_exc()
                    journal_auto_approval = {
                        'success': False,
                        'error': f"Journal auto approval error: {str(journal_error)}",
                        'approved_count': 0,
                        'reference_numbers': [],
                        'debug_check': check_result if 'check_result' in locals() else None
                    }
            elif status == 'R':
                print(f"🔴 [FORCE] Status is R, processing auto rejection...")
                asset = main_record.asset_list_id
                asset_list_id = asset.asset_list_id
                print(f"🔍 [FORCE] Asset ID: {asset_list_id}")
                
                # ✅ กวดสอบ journal entries ก่อน
                print(f"🔍 [FORCE] Checking journal entries for asset: {asset_list_id}")
                try:
                    check_result = check_journal_entries_for_asset(asset_list_id)
                    print(f"📊 [FORCE] Check result: {check_result}")
                except:
                    check_result = {'error': 'check_journal_entries_for_asset function not found'}
                    print(f"⚠️ [FORCE] Could not check journal entries: {check_result}")
                
                # ✅ อัดตะโนมัด reject journal entries
                try:
                    print(f"🔍 [FORCE] About to call auto_reject_related_journals...")
                    
                    try:
                        journal_auto_approval = auto_reject_related_journals(asset_list_id, reason, validated_user_id)
                        # ปรียน rejected_count เป็น approved_count เพื่อใช้ logic เดียวกับ A
                        if journal_auto_approval and journal_auto_approval.get('success'):
                            journal_auto_approval['approved_count'] = journal_auto_approval.get('rejected_count', 0)
                    except:
                        print(f"⚠️ [FORCE] auto_reject_related_journals function not found, using fallback")
                        journal_auto_approval = {
                            'success': False,
                            'message': 'auto_reject_related_journals function not available',
                            'approved_count': 0,
                            'reference_numbers': []
                        }
                    
                    print(f"📊 [FORCE] auto_reject_related_journals result: {journal_auto_approval}")
                    
                    if journal_auto_approval and journal_auto_approval.get('success') and journal_auto_approval.get('approved_count', 0) > 0:
                        print(f"✅ [FORCE] Auto rejected {journal_auto_approval['approved_count']} journals")
                    else:
                        print(f"ℹ️ [FORCE] No journals rejected or function failed")
                        if journal_auto_approval is None:
                            journal_auto_approval = {
                                'success': False,
                                'message': 'auto_reject_related_journals returned None',
                                'approved_count': 0,
                                'reference_numbers': [],
                                'debug_check': check_result if 'check_result' in locals() else None
                            }
                        
                except Exception as journal_error:
                    print(f"⚠️ [FORCE] Journal auto rejection error: {str(journal_error)}")
                    import traceback
                    traceback.print_exc()
                    journal_auto_approval = {
                        'success': False,
                        'error': f"Journal auto rejection error: {str(journal_error)}",
                        'approved_count': 0,
                        'reference_numbers': [],
                        'debug_check': check_result if 'check_result' in locals() else None
                    }
                    
            elif status == 'P':
                print(f"🟡 [FORCE] Status is P, processing pending update...")
                asset = main_record.asset_list_id
                asset_list_id = asset.asset_list_id
                print(f"🔍 [FORCE] Asset ID: {asset_list_id}")
                
                try:
                    journal_auto_approval = update_journal_status_to_pending(asset_list_id, reason, validated_user_id)
                    if journal_auto_approval and journal_auto_approval.get('success'):
                        journal_auto_approval['approved_count'] = journal_auto_approval.get('updated_count', 0)
                except:
                    journal_auto_approval = {
                        'success': False,
                        'message': 'update_journal_status_to_pending function not available',
                        'approved_count': 0,
                        'reference_numbers': []
                    }
                    
            else:
                print(f"🔍 [FORCE] Status is {status}, unknown status")
                journal_auto_approval = {
                    'success': False,
                    'message': f'Unknown status {status}',
                    'approved_count': 0,
                    'reference_numbers': []
                }
            
            # ✅ 4. ສ້າງ message
            base_message = f"ບັນທຶກ {aldm_id} ອັບເດດເປັນ {status} ສຳເລັດ"
            if status == 'A' and journal_auto_approval and journal_auto_approval.get('approved_count', 0) > 0:
                base_message += f" + Auto approved {journal_auto_approval['approved_count']} journal entries"
            
            print(f"✅ [DEBUG] Final result: journal_auto_approval = {journal_auto_approval}")
            
            return {
                'success': True,
                'message': base_message,
                'user_id_used': validated_user_id,
                'status_set': status,
                'reason_set': reason if status in ['R', 'P'] else None,
                'fa_asset_updated': status == 'A',
                'fa_accounting_method_updated': False,  # ✅ ປ່ຽນເປັນ False
                'accounting_method_info': None,  # ✅ ປ່ຽນເປັນ None  
                'c_dpac_calculation': {  # ✨ ເພີ່ມຂໍ້ມູນການຄິດໄລ່ໃໝ່
                    'dpca_no_of_days': dpca_no_of_days,
                    'increment_value': c_dpac_increment,
                    'previous_c_dpac': float(current_c_dpac),
                    'new_c_dpac': float(new_c_dpac)
                } if status == 'A' else None,
                'journal_auto_approval': journal_auto_approval
            }
        
    except Exception as e:
        print(f"💥 [DEBUG] Error: {str(e)}")
        import traceback
        traceback.print_exc()
        return {"error": f"Confirm depreciation error: {str(e)}"}
@csrf_exempt  
def calculate_depreciation_api_debug(request):
    """
    ✅ API ພ້ອມ debug action
    """
    try:
        if request.method not in ['POST', 'GET']:
            return JsonResponse({'error': 'ໃຊ້ POST ຫຼື GET method'}, status=400)
        
        if request.method == 'POST':
            if not request.body:
                return JsonResponse({'error': 'ບໍ່ມີ request body'}, status=400)
            
            try:
                data = json.loads(request.body)
            except json.JSONDecodeError as e:
                return JsonResponse({'error': f'JSON error: {str(e)}'}, status=400)
            
            mapping_id = data.get('mapping_id')
            asset_list_id = data.get('asset_list_id')
            aldm_id = data.get('aldm_id')
            user_id = data.get('user_id')
            action = data.get('action', 'calculate')
            status = data.get('status')
            reason = data.get('reason')
        else:  # GET
            mapping_id = request.GET.get('mapping_id')
            asset_list_id = request.GET.get('asset_list_id')
            aldm_id = request.GET.get('aldm_id')
            user_id = request.GET.get('user_id')
            action = request.GET.get('action', 'calculate')
            status = request.GET.get('status')
            reason = request.GET.get('reason')
        
        # ✅ ເພີ່ມ debug actions
        if action == 'check_journals':
            if not asset_list_id:
                return JsonResponse({'error': 'ໃສ່ asset_list_id ສຳລັບ check'}, status=400)
            result = check_journal_entries_for_asset(asset_list_id)
            
        elif action == 'test_approve':
            if not asset_list_id:
                return JsonResponse({'error': 'ໃສ່ asset_list_id ສຳລັບ test'}, status=400)
            result = auto_approve_related_journals(asset_list_id)
            
        elif action == 'confirm_depreciation':
            if not aldm_id:
                return JsonResponse({'error': 'ໃສ່ aldm_id'}, status=400)
            if not status:
                return JsonResponse({'error': 'ໃສ່ status (A, R, ຫຼື P)'}, status=400)
            
            # ✅ ໃຊ້ forced debug version
            result = confirm_depreciation(aldm_id, status, reason, user_id)
        
        # ... (rest of actions) ...
        
        if isinstance(result, dict) and 'error' in result:
            return JsonResponse(result, status=400)
        
        return JsonResponse({
            'success': True,
            'action': action,
            'data': result,
            'timestamp': timezone.now().isoformat()
        })
        
    except Exception as e:
        import traceback
        error_details = {
            'error': str(e),
            'type': type(e).__name__,
            'traceback': traceback.format_exc()
        }
        return JsonResponse(error_details, status=500)

def cancel_depreciation(aldm_id, user_id=None):
    """
    ຍົກເລີກບັນທຶກການຫັກຄ່າເສື່ອມທີ່ຍັງບໍ່ຢືນຢັນ
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        with transaction.atomic():
            main_record = FA_Asset_List_Depreciation_Main.objects.get(aldm_id=aldm_id)
            
            if main_record.Auth_Status not in ['U', 'P']:
                return {"error": f"ບໍ່ສາມາດຍົກເລີກບັນທຶກທີ່ມີ Auth_Status = {main_record.Auth_Status}"}
            
            
            FA_Asset_List_Depreciation.objects.filter(
                asset_list_id=main_record.asset_list_id,
                dpca_date=main_record.dpca_date,
                dpca_value=main_record.dpca_value
            ).delete()
            
            if main_record.aldm_month_id:
                FA_Asset_List_Depreciation_InMonth.objects.filter(
                    aldim_id=main_record.aldm_month_id.aldim_id
                ).delete()
            
            main_record.delete()
            
            return {
                'success': True,
                'message': f"ຍົກເລີກບັນທຶກ {aldm_id} ສຳເລັດ",
                'cancelled_by': validated_user_id,
                'cancelled_date': datetime.now().isoformat()
            }
        
    except Exception as e:
        return {"error": f"Cancel depreciation error: {str(e)}"}
def get_depreciable_assets():
    """
    ✅ ຫາລາຍການຊັບສິນທີ່ສາມາດຫັກໄດ້
    """
    try:
        accounting_methods = FA_Accounting_Method.objects.all()
        depreciable_items = []
        
        for method in accounting_methods:
            try:
                if method.asset_list_id:
                    asset = method.asset_list_id
                elif method.ref_id:
                    asset = FA_Asset_Lists.objects.get(asset_list_id=method.ref_id)
                else:
                    continue
                
                if asset.asset_value and asset.asset_useful_life:
                    current_count = int(asset.C_dpac or 0)
                    total_months = int(asset.asset_useful_life) * 12
                    can_depreciate = current_count < total_months
                    
                    item_info = {
                        'mapping_id': method.mapping_id,
                        'asset_id': asset.asset_list_id,
                        'asset_name': asset.asset_spec or 'N/A',
                        'asset_value': float(asset.asset_value),
                        'current_count': current_count,
                        'total_months': total_months,
                        'remaining_months': total_months - current_count,
                        'can_depreciate': can_depreciate,
                        'completion_percentage': round((current_count / total_months) * 100, 2)
                    }
                    depreciable_items.append(item_info)
                    
            except Exception as e:
                continue
        
        can_depreciate_items = [item for item in depreciable_items if item['can_depreciate']]
        cannot_depreciate_items = [item for item in depreciable_items if not item['can_depreciate']]
        
        return {
            'summary': {
                'total_items': len(depreciable_items),
                'can_depreciate': len(can_depreciate_items),
                'cannot_depreciate': len(cannot_depreciate_items)
            },
            'items': depreciable_items,
            'depreciable_items': can_depreciate_items,
            'completed_items': cannot_depreciate_items
        }
        
    except Exception as e:
        return {"error": f"Get depreciable assets error: {str(e)}"}

# ✅ NEW: ຟັງຊັນໃຫມ່ສຳລັບດຶງລາຍການທີ່ຍັງບໍ່ຢືນຢັນ
def get_pending_depreciation(user_id=None):
    """
    ✅ UPDATED: ໃຊ້ detail ແທນ reject_reason
    ດຶງລາຍການທີ່ຍັງບໍ່ຢືນຢັນ (Auth_Status = 'U' ຫຼື 'P')
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        pending_records = FA_Asset_List_Depreciation_Main.objects.filter(
            Auth_Status__in=['U', 'P']
        ).select_related('asset_list_id')
        
        results = []
        for record in pending_records:
            results.append({
                'aldm_id': record.aldm_id,
                'asset_id': record.asset_list_id.asset_list_id,
                'asset_code': record.asset_list_id.asset_code,
                'dpca_date': record.dpca_date.strftime('%d/%m/%Y'),
                'dpca_value': float(record.dpca_value),
                'Auth_Status': record.Auth_Status,
                'detail': record.detail,  # ✅ ໃຊ້ detail ແທນ reject_reason
                'maker_id': record.Maker_Id_id,
                'maker_date': record.Maker_DT_Stamp.strftime('%d/%m/%Y %H:%M:%S') if record.Maker_DT_Stamp else None
            })
        
        return {
            'success': True,
            'data': results,
            'total_records': len(results)
        }
        
    except Exception as e:
        return {"error": f"Get pending depreciation error: {str(e)}"}

@csrf_exempt  
def calculate_depreciation_api(request):
    """
    ✅ ENHANCED: API ຫຼັກ - ເພີ່ມ catch-up depreciation actions
    """
    try:
        # Initialize result
        result = None
        
        if request.method not in ['POST', 'GET']:
            return JsonResponse({'error': 'ໃຊ້ POST ຫຼື GET method'}, status=400)
        
        # Parse request parameters
        if request.method == 'POST':
            if not request.body:
                return JsonResponse({'error': 'ບໍ່ມີ request body'}, status=400)
            
            try:
                data = json.loads(request.body)
            except json.JSONDecodeError as e:
                return JsonResponse({'error': f'JSON error: {str(e)}'}, status=400)
            
            # Extract parameters
            mapping_id = data.get('mapping_id')
            mapping_ids = data.get('mapping_ids', [])
            asset_list_id = data.get('asset_list_id')
            aldm_id = data.get('aldm_id')
            aldm_ids = data.get('aldm_ids', [])
            user_id = data.get('user_id')
            target_month = data.get('target_month')
            target_year = data.get('target_year')
            action = data.get('action', 'calculate')
            status = data.get('status')
            reason = data.get('reason')
            filter_status = data.get('filter_status', ['U'])
            date = data.get('date')
        else:  # GET
            # Extract GET parameters
            mapping_id = request.GET.get('mapping_id')
            mapping_ids_str = request.GET.get('mapping_ids', '')
            mapping_ids = [int(x) for x in mapping_ids_str.split(',') if x] if mapping_ids_str else []
            asset_list_id = request.GET.get('asset_list_id')
            aldm_id = request.GET.get('aldm_id')
            aldm_ids_str = request.GET.get('aldm_ids', '')
            aldm_ids = [int(x) for x in aldm_ids_str.split(',') if x] if aldm_ids_str else []
            user_id = request.GET.get('user_id')
            target_month = request.GET.get('target_month')
            target_year = request.GET.get('target_year')
            action = request.GET.get('action', 'calculate')
            status = request.GET.get('status')
            reason = request.GET.get('reason')
            filter_status_str = request.GET.get('filter_status', 'U')
            filter_status = filter_status_str.split(',') if filter_status_str else ['U']
            date = request.GET.get('date')

        print(f"🔍 API called with action: {action}")

        # Valid actions definition
        valid_actions = {
            'need_mapping_id': ['calculate', 'process', 'status', 'catch_up_process'],
            'need_mapping_ids': ['bulk_check', 'bulk_process', 'catch_up_bulk_process'],
            'need_asset_list_id': ['get_history', 'find_journals'],
            'need_aldm_id': ['mark_accounted', 'confirm_depreciation', 'cancel_depreciation'],
            'need_aldm_ids': ['bulk_confirm'],
            'need_status': ['bulk_confirm_all'],
            'no_parameters': ['bulk_list', 'bulk_process_all', 'get_monthly_due', 'get_pending_summary', 'get_pending_depreciation']
        }

        all_actions = sum(valid_actions.values(), [])
        if action not in all_actions:
            return JsonResponse({
                'error': f'action "{action}" ບໍ່ຖືກຕ້ອງ',
                'valid_actions': list(all_actions)
            }, status=400)

        # ✅ Process actions - ເພີ່ມ catch-up actions
        if action in valid_actions['need_mapping_id']:
            if not mapping_id:
                return JsonResponse({'error': 'ໃສ່ mapping_id'}, status=400)
            
            if action == 'calculate':
                result = calculate_depreciation_schedule(mapping_id)
            elif action == 'process':
                result = process_monthly_depreciation(mapping_id, user_id, date)
            elif action == 'status':
                calc_result = calculate_depreciation_schedule(mapping_id)
                if 'error' in calc_result:
                    result = calc_result
                else:
                    result = {
                        'asset_info': calc_result['asset_info'],
                        'depreciation_status': calc_result['depreciation_status']
                    }
            elif action == 'catch_up_process':  # ✅ ເພີ່ມ catch-up ລາຍການດຽວ
                print(f"🎯 Processing catch-up for mapping_id: {mapping_id}")
                result = process_bulk_depreciation_catch_up(mapping_id, user_id, date)

        elif action in valid_actions['need_mapping_ids']:
            if not mapping_ids:
                return JsonResponse({'error': 'ໃສ່ mapping_ids'}, status=400)
            
            if action == 'bulk_check':
                result = process_bulk_depreciation(mapping_ids, check_only=True, user_id=user_id)
            elif action == 'bulk_process':
                with transaction.atomic():
                    result = process_bulk_depreciation(mapping_ids, check_only=False, user_id=user_id)
            elif action == 'catch_up_bulk_process':  # ✅ ເພີ່ມ catch-up ຫຼາຍລາຍການ
                print(f"🎯 Processing bulk catch-up for {len(mapping_ids)} items")
                results = []
                success_count = 0
                error_count = 0
                
                for mid in mapping_ids:
                    print(f"   Processing mapping_id: {mid}")
                    item_result = process_bulk_depreciation_catch_up(mid, user_id, date)
                    
                    if item_result.get('success'):
                        success_count += 1
                    else:
                        error_count += 1
                        
                    results.append({
                        'mapping_id': mid,
                        'result': item_result
                    })
                
                result = {
                    'success': True,
                    'summary': {
                        'total_items': len(mapping_ids),
                        'success_count': success_count,
                        'error_count': error_count
                    },
                    'details': results
                }

        elif action in valid_actions['need_asset_list_id']:
            if not asset_list_id:
                return JsonResponse({'error': 'ໃສ່ asset_list_id'}, status=400)
            
            if action == 'get_history':
                limit = data.get('limit') if request.method == 'POST' else request.GET.get('limit')
                if limit:
                    limit = int(limit)
                result = get_depreciation_history(asset_list_id, limit)
            elif action == 'find_journals':
                result = find_related_journal_entries(asset_list_id)

        elif action in valid_actions['need_aldm_id']:
            if not aldm_id:
                return JsonResponse({'error': 'ໃສ່ aldm_id'}, status=400)
            
            if action == 'mark_accounted':
                result = mark_depreciation_as_accounted(aldm_id, user_id)
            elif action == 'confirm_depreciation':
                if not status:
                    return JsonResponse({'error': 'ໃສ່ status (A, R, ຫຼື P)'}, status=400)
                result = confirm_depreciation(aldm_id, status, reason, user_id)
            elif action == 'cancel_depreciation':
                result = cancel_depreciation(aldm_id, user_id)

        elif action in valid_actions['need_aldm_ids']:
            if not aldm_ids:
                return JsonResponse({'error': 'ໃສ່ aldm_ids'}, status=400)
            
            if action == 'bulk_confirm':
                if not status:
                    return JsonResponse({'error': 'ໃສ່ status (A, R, ຫຼື P)'}, status=400)
                result = bulk_confirm_depreciation(aldm_ids, status, reason, user_id)

        elif action in valid_actions['need_status']:
            if not status:
                return JsonResponse({'error': 'ໃສ່ status (A, R, ຫຼື P)'}, status=400)
            
            if action == 'bulk_confirm_all':
                try:
                    # ຫາ pending records
                    pending_records = FA_Asset_List_Depreciation_Main.objects.filter(
                        Auth_Status__in=filter_status
                    ).values_list('aldm_id', flat=True)
                    
                    aldm_ids_for_bulk = list(pending_records)
                    
                    if not aldm_ids_for_bulk:
                        result = {
                            'success': True,
                            'message': f'ບໍ່ມີລາຍການທີ່ມີສະຖານະ {filter_status}',
                            'summary': {'total_items': 0, 'success_count': 0, 'error_count': 0},
                            'details': []
                        }
                    else:
                        result = bulk_confirm_depreciation(aldm_ids_for_bulk, status, reason, user_id)
                        if result.get('success'):
                            result['bulk_all_info'] = {
                                'filter_status': filter_status,
                                'found_pending': len(aldm_ids_for_bulk),
                                'operation': 'confirm_all_pending_with_journal'
                            }
                except Exception as e:
                    result = {"error": f"bulk_confirm_all error: {str(e)}"}

        elif action in valid_actions['no_parameters']:
            if action == 'bulk_list':
                result = get_depreciable_assets()
            elif action == 'bulk_process_all':
                depreciable_assets = get_depreciable_assets()
                if 'error' in depreciable_assets:
                    result = depreciable_assets
                else:
                    available_ids = [item['mapping_id'] for item in depreciable_assets['depreciable_items']]
                    if not available_ids:
                        result = {
                            'success': True,
                            'message': 'ບໍ່ມີລາຍການທີ່ຕ້ອງຫັກ',
                            'data': {'summary': {'total_items': 0, 'success_count': 0, 'error_count': 0}, 'details': []}
                        }
                    else:
                        with transaction.atomic():
                            result = process_bulk_depreciation(available_ids, check_only=False, user_id=user_id)
            elif action == 'get_pending_depreciation':
                result = get_pending_depreciation(user_id)
            elif action == 'get_pending_summary':
                result = get_pending_summary(user_id)
            elif action == 'get_monthly_due':
                # ແປງເປັນ int ຖ້າມີ
                if target_month:
                    target_month = int(target_month)
                if target_year:
                    target_year = int(target_year)
                result = get_depreciation_due_this_month(target_month, target_year)
            else:
                result = {"error": f"Action {action} not fully implemented"}
        
        # ✅ ກວດສອບວ່າ result ຖືກກຳນົດແລ້ວ
        if result is None:
            result = {"error": f"No result generated for action: {action}"}
            print(f"❌ No result for action: {action}")
        else:
            print(f"✅ Result generated for action {action}: {type(result)}")

        # ກວດສອບ error ໃນ result
        if isinstance(result, dict) and 'error' in result:
            print(f"❌ Error in result: {result['error']}")
            return JsonResponse(result, status=400)
        
        return JsonResponse({
            'success': True,
            'action': action,
            'data': result,
            'timestamp': datetime.now().isoformat(),
            'enhanced_features': {
                'auto_journal_approve': action in ['confirm_depreciation', 'bulk_confirm', 'bulk_confirm_all'],
                'find_journals_available': True,
                'catch_up_depreciation': action in ['catch_up_process', 'catch_up_bulk_process']  # ✅ ເພີ່ມ
            }
        })
        
    except Exception as e:
        import traceback
        error_details = {
            'error': str(e),
            'type': type(e).__name__,
            'traceback': traceback.format_exc(),
            'action_received': locals().get('action', 'unknown')
        }
        print("Enhanced API Error Details:", error_details)
        return JsonResponse(error_details, status=500)
def debug_bulk_confirm_all(status, reason=None, user_id=None, filter_status=['U']):
    """Debug function for bulk_confirm_all"""
    try:
        print(f"🔍 DEBUG: bulk_confirm_all called with status={status}")
        
        # ຫາ pending records
        pending_records = FA_Asset_List_Depreciation_Main.objects.filter(
            Auth_Status__in=filter_status
        ).values_list('aldm_id', flat=True)
        
        aldm_ids = list(pending_records)
        print(f"📋 Found {len(aldm_ids)} pending records")
        
        if not aldm_ids:
            return {
                'success': True,
                'message': 'ບໍ່ມີລາຍການ pending',
                'debug_info': {
                    'filter_status': filter_status,
                    'found_records': 0
                }
            }
        
        # ໃຊ້ Enhanced function
        result = bulk_confirm_depreciation_enhanced(aldm_ids, status, reason, user_id)
        result['debug_info'] = {
            'function_used': 'bulk_confirm_depreciation_enhanced',
            'filter_status': filter_status,
            'found_records': len(aldm_ids)
        }
        
        return result
        
    except Exception as e:
        return {"error": f"Debug error: {str(e)}"}
def get_depreciation_due_this_month(target_month=None, target_year=None):
    """
    ✅ UNCHANGED: ຫາລາຍການຊັບສິນທີ່ຕ້ອງຫັກໃນເດືອນທີ່ກຳນົດ
    """
    try:
        current_date = datetime.now()
        
        if not target_month:
            target_month = current_date.month
        if not target_year:
            target_year = current_date.year
            
        month_start = datetime(target_year, target_month, 1).date()
        month_end = datetime(target_year, target_month, 
                           get_last_day_of_month(target_year, target_month)).date()
        
        accounting_methods = FA_Accounting_Method.objects.all()
        due_items = []
        overdue_items = []
        up_to_date_items = []
        
        for method in accounting_methods:
            try:
                if method.asset_list_id:
                    asset = method.asset_list_id
                elif method.ref_id:
                    asset = FA_Asset_Lists.objects.get(asset_list_id=method.ref_id)
                else:
                    continue
                
                if not (asset.asset_value and asset.asset_useful_life):
                    continue
                
                current_count = int(asset.C_dpac or 0)
                useful_life = int(asset.asset_useful_life)
                total_months = useful_life * 12
                start_date = asset.dpca_start_date
                
                if current_count >= total_months:
                    continue
                
                next_month_number = current_count + 1
                
                if next_month_number == 1:
                    due_date = start_date
                else:
                    due_date = (start_date + relativedelta(months=current_count)).replace(day=1)
                
                if next_month_number == 1:
                    due_end_date = datetime(start_date.year, start_date.month,
                                          get_last_day_of_month(start_date.year, start_date.month)).date()
                else:
                    month_calc = start_date + relativedelta(months=current_count)
                    due_end_date = datetime(month_calc.year, month_calc.month,
                                          get_last_day_of_month(month_calc.year, month_calc.month)).date()
                
                calc_result = calculate_depreciation_schedule(method.mapping_id)
                if 'error' in calc_result:
                    continue
                
                daily_depreciation = calc_result['calculation_info']['daily_depreciation']
                
                if next_month_number == 1:
                    days_count = (due_end_date - due_date + timedelta(days=1)).days
                else:
                    days_count = get_last_day_of_month(due_end_date.year, due_end_date.month)
                
                expected_depreciation = daily_depreciation * days_count
                
                item_data = {
                    'mapping_id': method.mapping_id,
                    'asset_id': asset.asset_list_id,
                    'asset_name': asset.asset_spec or 'N/A',
                    'asset_value': float(asset.asset_value),
                    'current_month': next_month_number,
                    'total_months': total_months,
                    'due_date': due_date.strftime('%d/%m/%Y'),
                    'due_end_date': due_end_date.strftime('%d/%m/%Y'),
                    'days_count': days_count,
                    'expected_depreciation': round(expected_depreciation, 2),
                    'last_depreciation_date': asset.asset_latest_date_dpca.strftime('%d/%m/%Y') if asset.asset_latest_date_dpca else 'ຍັງບໍ່ໄດ້ຫັກ',
                    'status_category': '',
                    'due_month_year': f"{get_month_name_la(due_date.month)} {due_date.year}",
                    'completion_percentage': round((current_count / total_months) * 100, 2)
                }
                
                if due_date <= month_end and due_end_date >= month_start:
                    if due_end_date < current_date.date():
                        item_data['status_category'] = 'overdue'
                        item_data['status_message'] = f"⚠️ ຄ້າງຫັກ! ຄວນຫັກແລ້ວໃນ {item_data['due_month_year']}"
                        overdue_items.append(item_data)
                    else:
                        item_data['status_category'] = 'due'
                        item_data['status_message'] = f"📅 ຕ້ອງຫັກໃນ {item_data['due_month_year']}"
                        due_items.append(item_data)
                elif due_date > month_end:
                    item_data['status_category'] = 'future'
                    item_data['status_message'] = f"⏭️ ຈະຫັກໃນ {item_data['due_month_year']}"
                else:
                    item_data['status_category'] = 'up_to_date'
                    item_data['status_message'] = f"✅ ອັບເດດແລ້ວ"
                    up_to_date_items.append(item_data)
                    
            except Exception as e:
                print(f"Error processing mapping_id {method.mapping_id}: {str(e)}")
                continue
        
        overdue_items.sort(key=lambda x: x['due_date'])
        due_items.sort(key=lambda x: x['due_date'])
        
        return {
            'success': True,
            'month': f"{get_month_name_la(target_month)} {target_year}",
            'total_items': len(due_items) + len(overdue_items) + len(up_to_date_items),
            'due_items': due_items,
            'overdue_items': overdue_items,
            'up_to_date_items': up_to_date_items,
            'summary': {
                'due_count': len(due_items),
                'overdue_count': len(overdue_items),
                'up_to_date_count': len(up_to_date_items)
            }
        }
    
    except Exception as e:
        return {
            'success': False,
            'error': f"Get depreciation due error: {str(e)}"
        }
    
    


"""
-- ກວດສອບວ່າມີ user ຫຍັງຢູ່ບ້າງ:
SELECT user_id, username FROM SAMCSYS_mttb_users;

-- ຖ້າບໍ່ມີ user ໃດເລີຍ ໃຫ້ສ້າງ user ທົດລອງ:
INSERT INTO SAMCSYS_mttb_users (user_id, username, password, email, is_active) 
VALUES (1, 'admin', 'admin123', 'admin@example.com', 1);

-- ຫຼື ຫາ user_id ທີ່ມີຢູ່ແລ້ວ:
SELECT MIN(user_id) as first_user_id FROM SAMCSYS_mttb_users WHERE is_active = 1;
"""




def get_depreciation_due_this_month(target_month=None, target_year=None):
    """
    ຫາລາຍການຊັບສິນທີ່ຕ້ອງຫັກໃນເດືອນທີ່ກຳນົດ
    
    Args:
        target_month: ເດືອນທີ່ຕ້ອງການກວດສອບ (1-12) - ຖ້າບໍ່ໃສ່ໃຊ້ເດືອນປັດຈຸບັນ
        target_year: ປີທີ່ຕ້ອງການກວດສອບ - ຖ້າບໍ່ໃສ່ໃຊ້ປີປັດຈຸບັນ
    """
    try:
        current_date = datetime.now()
        
        
        if not target_month:
            target_month = current_date.month
        if not target_year:
            target_year = current_date.year
            
        
        month_start = datetime(target_year, target_month, 1).date()
        month_end = datetime(target_year, target_month, 
                           get_last_day_of_month(target_year, target_month)).date()
        
        
        accounting_methods = FA_Accounting_Method.objects.all()
        due_items = []
        overdue_items = []
        up_to_date_items = []
        
        for method in accounting_methods:
            try:
                
                if method.asset_list_id:
                    asset = method.asset_list_id
                elif method.ref_id:
                    asset = FA_Asset_Lists.objects.get(asset_list_id=method.ref_id)
                else:
                    continue
                
                
                if not (asset.asset_value and asset.asset_useful_life):
                    continue
                
                current_count = int(asset.C_dpac or 0)
                useful_life = int(asset.asset_useful_life)
                total_months = useful_life * 12
                start_date = asset.dpca_start_date
                
               
                if current_count >= total_months:
                    continue
                
              
                next_month_number = current_count + 1
                
                
                if next_month_number == 1:
                    
                    due_date = start_date
                else:
                   
                    due_date = (start_date + relativedelta(months=current_count)).replace(day=1)
                
                
                if next_month_number == 1:
                    due_end_date = datetime(start_date.year, start_date.month,
                                          get_last_day_of_month(start_date.year, start_date.month)).date()
                else:
                    month_calc = start_date + relativedelta(months=current_count)
                    due_end_date = datetime(month_calc.year, month_calc.month,
                                          get_last_day_of_month(month_calc.year, month_calc.month)).date()
                
                
                calc_result = calculate_depreciation_schedule(method.mapping_id)
                if 'error' in calc_result:
                    continue
                
                daily_depreciation = calc_result['calculation_info']['daily_depreciation']
                
                if next_month_number == 1:
                    days_count = (due_end_date - due_date + timedelta(days=1)).days
                else:
                    days_count = get_last_day_of_month(due_end_date.year, due_end_date.month)
                
                expected_depreciation = daily_depreciation * days_count
                
               
                item_data = {
                    'mapping_id': method.mapping_id,
                    'asset_id': asset.asset_list_id,
                    'asset_name': asset.asset_spec or 'N/A',
                    'asset_value': float(asset.asset_value),
                    'current_month': next_month_number,
                    'total_months': total_months,
                    'due_date': due_date.strftime('%d/%m/%Y'),
                    'due_end_date': due_end_date.strftime('%d/%m/%Y'),
                    'days_count': days_count,
                    'expected_depreciation': round(expected_depreciation, 2),
                    'last_depreciation_date': asset.asset_latest_date_dpca.strftime('%d/%m/%Y') if asset.asset_latest_date_dpca else 'ຍັງບໍ່ໄດ້ຫັກ',
                    'status_category': '',
                    'due_month_year': f"{get_month_name_la(due_date.month)} {due_date.year}",
                    'completion_percentage': round((current_count / total_months) * 100, 2)
                }
                
               
                if due_date <= month_end and due_end_date >= month_start:
                    
                    if due_end_date < current_date.date():
                        item_data['status_category'] = 'overdue'
                        item_data['status_message'] = f"⚠️ ຄ້າງຫັກ! ຄວນຫັກແລ້ວໃນ {item_data['due_month_year']}"
                        overdue_items.append(item_data)
                    else:
                        item_data['status_category'] = 'due'
                        item_data['status_message'] = f"📅 ຕ້ອງຫັກໃນ {item_data['due_month_year']}"
                        due_items.append(item_data)
                elif due_date > month_end:
                   
                    item_data['status_category'] = 'future'
                    item_data['status_message'] = f"⏭️ ຈະຫັກໃນ {item_data['due_month_year']}"
                    
                else:
                    
                    item_data['status_category'] = 'up_to_date'
                    item_data['status_message'] = f"✅ ອັບເດດແລ້ວ"
                    up_to_date_items.append(item_data)
                    
            except Exception as e:
                print(f"Error processing mapping_id {method.mapping_id}: {str(e)}")
                continue
        
       
        overdue_items.sort(key=lambda x: x['due_date'])
        due_items.sort(key=lambda x: x['due_date'])
        
        return {
            'success': True,
            'target_period': {
                'month': target_month,
                'year': target_year,
                'month_name_la': get_month_name_la(target_month),
                'period': f"{month_start.strftime('%d/%m/%Y')} - {month_end.strftime('%d/%m/%Y')}"
            },
            'summary': {
                'total_due': len(due_items),
                'total_overdue': len(overdue_items),
                'total_up_to_date': len(up_to_date_items),
                'total_checked': len(due_items) + len(overdue_items) + len(up_to_date_items)
            },
            'overdue_items': overdue_items,  
            'due_items': due_items,          
            'up_to_date_items': up_to_date_items[:5],  
            'all_items_needing_attention': overdue_items + due_items
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Get monthly due error: {str(e)}"
        }

def get_next_few_months_due(months_ahead=3):
    """
    ຫາລາຍການທີ່ຕ້ອງຫັກໃນອີກ 3 ເດືອນຂ້າງໜ້າ
    """
    try:
        current_date = datetime.now()
        results = []
        
        for i in range(months_ahead):
            target_date = current_date + relativedelta(months=i)
            monthly_result = get_depreciation_due_this_month(
                target_month=target_date.month,
                target_year=target_date.year
            )
            
            if monthly_result['success']:
                results.append({
                    'month': target_date.month,
                    'year': target_date.year,
                    'month_name': get_month_name_la(target_date.month),
                    'due_count': monthly_result['summary']['total_due'],
                    'overdue_count': monthly_result['summary']['total_overdue'],
                    'items': monthly_result['all_items_needing_attention'][:5]  # ສະແດງ 5 ອັນທຳອິດ
                })
        
        return {
            'success': True,
            'period_summary': results,
            'total_months_checked': months_ahead
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Get next months due error: {str(e)}"
        }

def process_monthly_due_depreciation(target_month=None, target_year=None, user_id=None):
    """
    ຫັກຄ່າເສື່ອມລາຄາທຸກລາຍການທີ່ຕ້ອງຫັກໃນເດືອນນັ້ນ
    """
    try:
   
        due_result = get_depreciation_due_this_month(target_month, target_year)
        
        if not due_result['success']:
            return due_result
        
     
        items_to_process = due_result['all_items_needing_attention']
        
        if not items_to_process:
            return {
                'success': True,
                'message': f"ບໍ່ມີລາຍການທີ່ຕ້ອງຫັກໃນ {due_result['target_period']['month_name_la']} {due_result['target_period']['year']}",
                'target_period': due_result['target_period'],
                'summary': {
                    'total_items': 0,
                    'success_count': 0,
                    'error_count': 0
                },
                'details': []
            }
        
        
        mapping_ids = [item['mapping_id'] for item in items_to_process]
        
       
        with transaction.atomic():
            process_result = process_bulk_depreciation(mapping_ids, check_only=False, user_id=user_id)
        
    
        return {
            'success': True,
            'message': f"ຫັກຄ່າຫຼູຍຫຽ້ນຄາໃນ {due_result['target_period']['month_name_la']} {due_result['target_period']['year']} ສຳເລັດ",
            'target_period': due_result['target_period'],
            'processing_result': process_result
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Process monthly due error: {str(e)}"
        }
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import json

def get_overdue_depreciation_items():
    """
    🔍 ຫາລາຍການຊັບສິນທີ່ຄ້າງຫັກຄ່າເສື່ອມລາຄາ (ເລືອນກຳນົດແລ້ວ)
    
    Returns:
        dict: ລາຍການຄ້າງຫັກພ້ອມລາຍລະອຽດ
    """
    try:
        current_date = datetime.now().date()
        overdue_items = []
        warning_items = []
        
      
        accounting_methods = FA_Accounting_Method.objects.all()
        
        for method in accounting_methods:
            try:
               
                if method.asset_list_id:
                    asset = method.asset_list_id
                elif method.ref_id:
                    asset = FA_Asset_Lists.objects.get(asset_list_id=method.ref_id)
                else:
                    continue
                
              
                if not (asset.asset_value and asset.asset_useful_life):
                    continue
                
                current_count = int(asset.C_dpac or 0)
                useful_life = int(asset.asset_useful_life)
                total_months = useful_life * 12
                start_date = asset.dpca_start_date
                
             
                if current_count >= total_months:
                    continue
                
            
                next_month_number = current_count + 1
                
               
                if next_month_number == 1:
                  
                    due_date = start_date
                    due_end_date = datetime(start_date.year, start_date.month,
                                          get_last_day_of_month(start_date.year, start_date.month)).date()
                else:
                 
                    month_calc = start_date + relativedelta(months=current_count)
                    due_date = datetime(month_calc.year, month_calc.month, 1).date()
                    due_end_date = datetime(month_calc.year, month_calc.month,
                                          get_last_day_of_month(month_calc.year, month_calc.month)).date()
                
             
                calc_result = calculate_depreciation_schedule(method.mapping_id)
                if 'error' in calc_result:
                    continue
                
                daily_depreciation = calc_result['calculation_info']['daily_depreciation']
                days_count = (due_end_date - due_date + timedelta(days=1)).days
                expected_depreciation = daily_depreciation * days_count
                
                # ຄິດຈຳນວນວັນທີ່ຄ້າງ
                days_overdue = (current_date - due_end_date).days
                
                # ສ້າງຂໍ້ມູນລາຍການ
                item_data = {
                    'mapping_id': method.mapping_id,
                    'asset_id': asset.asset_list_id,
                    'asset_name': asset.asset_spec or 'N/A',
                    'asset_value': float(asset.asset_value),
                    'current_month': next_month_number,
                    'total_months': total_months,
                    'due_date': due_date.strftime('%d/%m/%Y'),
                    'due_end_date': due_end_date.strftime('%d/%m/%Y'),
                    'days_count': days_count,
                    'expected_depreciation': round(expected_depreciation, 2),
                    'last_depreciation_date': asset.asset_latest_date_dpca.strftime('%d/%m/%Y') if asset.asset_latest_date_dpca else 'ຍັງບໍ່ໄດ້ຫັກ',
                    'due_month_year': f"{get_month_name_la(due_date.month)} {due_date.year}",
                    'completion_percentage': round((current_count / total_months) * 100, 2),
                    'days_overdue': days_overdue,
                    'overdue_months': round(days_overdue / 30, 1)  # ປະມານເດືອນ
                }
                
          
                if days_overdue > 0:
                    # ຄ້າງຫັກແລ້ວ
                    if days_overdue <= 7:
                        item_data['urgency_level'] = 'low'
                        item_data['urgency_message'] = f"⚠️ ຄ້າງ {days_overdue} ມື້"
                        item_data['urgency_color'] = 'yellow'
                    elif days_overdue <= 30:
                        item_data['urgency_level'] = 'medium'
                        item_data['urgency_message'] = f"🔸 ຄ້າງ {days_overdue} ມື້ ({item_data['overdue_months']} ເດືອນ)"
                        item_data['urgency_color'] = 'orange'
                    elif days_overdue <= 90:
                        item_data['urgency_level'] = 'high'
                        item_data['urgency_message'] = f"🔴 ຄ້າງ {days_overdue} ມື້ ({item_data['overdue_months']} ເດືອນ)"
                        item_data['urgency_color'] = 'red'
                    else:
                        item_data['urgency_level'] = 'critical'
                        item_data['urgency_message'] = f"🆘 ຄ້າງ {days_overdue} ມື້ ({item_data['overdue_months']} ເດືອນ) - ສຸກເສີນ!"
                        item_data['urgency_color'] = 'dark-red'
                    
                    overdue_items.append(item_data)
                    
                elif days_overdue >= -7 and days_overdue <= 0:
                    # ໃກ້ເລືອນກຳນົດ (7 ມື້ຂ້າງໜ້າ)
                    days_until_due = abs(days_overdue)
                    item_data['urgency_level'] = 'warning'
                    item_data['urgency_message'] = f"⏰ ເຫຼືອ {days_until_due} ມື້"
                    item_data['urgency_color'] = 'blue'
                    item_data['days_until_due'] = days_until_due
                    
                    warning_items.append(item_data)
                    
            except Exception as e:
                print(f"Error processing mapping_id {method.mapping_id}: {str(e)}")
                continue
        
        # ຈັດລຽງຕາມລະດັບຄວາມສຳຄັນ
        overdue_items.sort(key=lambda x: x['days_overdue'], reverse=True)  # ຄ້າງນານທີ່ສຸດກ່ອນ
        warning_items.sort(key=lambda x: x['days_until_due'])  # ໃກ້ກຳນົດທີ່ສຸດກ່ອນ
        
        # ສະຖິຕິ
        total_overdue = len(overdue_items)
        critical_count = len([x for x in overdue_items if x['urgency_level'] == 'critical'])
        high_count = len([x for x in overdue_items if x['urgency_level'] == 'high'])
        medium_count = len([x for x in overdue_items if x['urgency_level'] == 'medium'])
        low_count = len([x for x in overdue_items if x['urgency_level'] == 'low'])
        
        # ຄຳນວນມູນຄ່າຄ້າງຫັກລວມ
        total_overdue_value = sum([item['expected_depreciation'] for item in overdue_items])
        
        return {
            'success': True,
            'summary': {
                'total_overdue': total_overdue,
                'total_warning': len(warning_items),
                'total_overdue_value': round(total_overdue_value, 2),
                'breakdown': {
                    'critical': critical_count,    # > 90 ມື້
                    'high': high_count,           # 31-90 ມື້  
                    'medium': medium_count,       # 8-30 ມື້
                    'low': low_count             # 1-7 ມື້
                },
                'generated_date': current_date.strftime('%d/%m/%Y'),
                'urgency_legend': {
                    'critical': '🆘 ຄ້າງເກີນ 90 ມື້ - ສຸກເສີນ!',
                    'high': '🔴 ຄ້າງ 31-90 ມື້ - ສຳຄັນ',
                    'medium': '🔸 ຄ້າງ 8-30 ມື້ - ປານກາງ', 
                    'low': '⚠️ ຄ້າງ 1-7 ມື້ - ຕໍ່າ',
                    'warning': '⏰ ໃກ້ກຳນົດ 7 ມື້'
                }
            },
            'overdue_items': overdue_items,
            'warning_items': warning_items
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Get overdue items error: {str(e)}"
        }
def get_overdue_by_urgency_level(urgency_level=None):
    """
    🎯 ຫາລາຍການຄ້າງຫັກຕາມລະດັບຄວາມສຳຄັນ
    
    Args:
        urgency_level: 'critical', 'high', 'medium', 'low', 'warning' ຫຼື None (ທັງໝົດ)
    """
    try:
        overdue_result = get_overdue_depreciation_items()
        
        if not overdue_result['success']:
            return overdue_result
        
        if not urgency_level:
            # ສົ່ງຄືນທັງໝົດ
            return overdue_result
        
        # ກອງຕາມລະດັບ
        filtered_overdue = [
            item for item in overdue_result['overdue_items'] 
            if item['urgency_level'] == urgency_level
        ]
        
        filtered_warning = [
            item for item in overdue_result['warning_items']
            if urgency_level == 'warning'
        ]
        
        return {
            'success': True,
            'urgency_level': urgency_level,
            'summary': {
                'total_filtered': len(filtered_overdue) + len(filtered_warning),
                'urgency_description': overdue_result['summary']['urgency_legend'].get(urgency_level, 'ບໍ່ມີຂໍ້ມູນ')
            },
            'overdue_items': filtered_overdue,
            'warning_items': filtered_warning if urgency_level == 'warning' else []
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Get overdue by urgency error: {str(e)}"
        }
    


def bulk_confirm_depreciation(aldm_ids, status, reason=None, user_id=None):
    """
    ✅ MODIFIED: Bulk ຢືນຢັນ + ອັດຕະໂນມັດ approve journal
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        if status not in ['A', 'R', 'P']:
            return {"error": "status ບໍ່ຖືກຕ້ອງ. ໃຊ້ 'A', 'R', ຫຼື 'P'"}
        
        if not aldm_ids or not isinstance(aldm_ids, list):
            return {"error": "ໃສ່ aldm_ids ເປັນ array"}
        
        results = []
        success_count = 0
        error_count = 0
        accounting_method_updates = []
        total_journals_approved = 0
        journal_approval_summary = []
        current_time = timezone.now()
        
        with transaction.atomic():
            for aldm_id in aldm_ids:
                # ✅ ໃຊ້ modified confirm_depreciation
                result = confirm_depreciation(aldm_id, status, reason, user_id)
                
                if result.get('success'):
                    results.append({
                        'aldm_id': aldm_id,
                        'status': 'success',
                        'message': result['message'],
                        'fa_asset_updated': result.get('fa_asset_updated', False),
                        'fa_accounting_method_updated': result.get('fa_accounting_method_updated', False),
                        'journal_auto_approval': result.get('journal_auto_approval')
                    })
                    success_count += 1
                    
                    # ເກັບຂໍ້ມູນ Accounting Method
                    if result.get('accounting_method_info'):
                        accounting_method_updates.append({
                            'aldm_id': aldm_id,
                            'accounting_method_info': result['accounting_method_info']
                        })
                    
                    # ✅ ເກັບສະຫຼຸບ journal approvals
                    journal_approval = result.get('journal_auto_approval')
                    if journal_approval and journal_approval.get('success'):
                        approved_count = journal_approval.get('approved_count', 0)
                        total_journals_approved += approved_count
                        
                        if approved_count > 0:
                            journal_approval_summary.append({
                                'aldm_id': aldm_id,
                                'approved_count': approved_count,
                                'reference_numbers': journal_approval.get('reference_numbers', [])
                            })
                else:
                    results.append({
                        'aldm_id': aldm_id,
                        'status': 'error',
                        'message': result.get('error', 'Unknown error')
                    })
                    error_count += 1
        
        return {
            'success': True,
            'summary': {
                'total_items': len(aldm_ids),
                'success_count': success_count,
                'error_count': error_count,
                'status_applied': status,
                'reason_applied': reason if status in ['R', 'P'] else None,
                'processed_by': validated_user_id,
                'processed_at': current_time.strftime('%d/%m/%Y %H:%M:%S'),
                'accounting_method_updates_count': len(accounting_method_updates),
                'total_journals_approved': total_journals_approved,  # ✅ ຄວນບໍ່ເປັນ 0 ແລ້ວ
                'assets_with_journals_approved': len(journal_approval_summary)
            },
            'details': results,
            'accounting_method_updates': accounting_method_updates,
            'journal_approval_summary': journal_approval_summary  # ✅ ຄວນມີຂໍ້ມູນແລ້ວ
        }
        
    except Exception as e:
        return {"error": f"Bulk confirm error: {str(e)}"}

def bulk_confirm_all_pending(status, reason=None, user_id=None, filter_status=['U']):
    """
    🔥 NEW: ຢືນຢັນທຸກລາຍການທີ່ pending ພ້ອມກັນ
    
    Args:
        status: 'A', 'R', 'P'
        reason: ເຫດຜົນ
        user_id: User ID
        filter_status: ['U'] ຫຼື ['U', 'P'] - ເລືອກສະຖານະທີ່ຕ້ອງການປະມວນຜົນ
    """
    try:
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        if not validated_user_id:
            return {"error": "ບໍ່ມີ user_id ທີ່ຖືກຕ້ອງ"}
        
        # ຫາທຸກລາຍການທີ່ pending
        pending_records = FA_Asset_List_Depreciation_Main.objects.filter(
            Auth_Status__in=filter_status
        ).values_list('aldm_id', flat=True)
        
        if not pending_records:
            return {
                'success': True,
                'message': f"ບໍ່ມີລາຍການທີ່ມີສະຖານະ {filter_status}",
                'summary': {
                    'total_items': 0,
                    'success_count': 0,
                    'error_count': 0
                }
            }
        
        # ໃຊ້ bulk_confirm_depreciation
        aldm_ids = list(pending_records)
        result = bulk_confirm_depreciation(aldm_ids, status, reason, user_id)
        
        # ເພີ່ມຂໍ້ມູນເສີມ
        if result.get('success'):
            result['bulk_all_info'] = {
                'filter_status': filter_status,
                'found_pending': len(aldm_ids),
                'operation': 'confirm_all_pending'
            }
        
        return result
        
    except Exception as e:
        return {"error": f"Bulk confirm all pending error: {str(e)}"}
def get_pending_summary(user_id=None):
    """
    📊 NEW: ສະແດງສະຫຼຸບລາຍການ pending ທັງໝົດ
    """
    try:
        pending_records = FA_Asset_List_Depreciation_Main.objects.filter(
            Auth_Status__in=['U', 'P']
        ).select_related('asset_list_id')
        
        unauthorized_items = []
        pending_revision_items = []
        
        for record in pending_records:
            item_data = {
                'aldm_id': record.aldm_id,
                'asset_id': record.asset_list_id.asset_list_id,
                'asset_name': record.asset_list_id.asset_spec or 'N/A',
                'dpca_date': record.dpca_date.strftime('%d/%m/%Y'),
                'dpca_value': float(record.dpca_value),
                'detail': record.detail,
                'maker_date': record.Maker_DT_Stamp.strftime('%d/%m/%Y %H:%M:%S') if record.Maker_DT_Stamp else None
            }
            
            if record.Auth_Status == 'U':
                unauthorized_items.append(item_data)
            elif record.Auth_Status == 'P':
                pending_revision_items.append(item_data)
        
        return {
            'success': True,
            'summary': {
                'total_unauthorized': len(unauthorized_items),
                'total_pending_revision': len(pending_revision_items),
                'total_pending': len(unauthorized_items) + len(pending_revision_items)
            },
            'unauthorized_items': unauthorized_items,  # Auth_Status = 'U'
            'pending_revision_items': pending_revision_items,  # Auth_Status = 'P'
            'all_pending_aldm_ids': [item['aldm_id'] for item in unauthorized_items + pending_revision_items]
        }
        
    except Exception as e:
        return {"error": f"Get pending summary error: {str(e)}"}
def bulk_confirm_by_asset_ids(asset_ids, status, reason=None, user_id=None):
    """
    🎯 NEW: ຢືນຢັນຕາມ Asset ID (ທຸກ aldm_id ຂອງ asset ນັ້ນໆ)
    
    Args:
        asset_ids: [101, 102, 103] - ລາຍການ asset_list_id
        status: 'A', 'R', 'P'
        reason: ເຫດຜົນ
        user_id: User ID
    """
    try:
        # ຫາທຸກ aldm_id ທີ່ກ່ຽວຂ້ອງກັບ asset_ids ເຫຼົ່ານີ້
        related_records = FA_Asset_List_Depreciation_Main.objects.filter(
            asset_list_id__asset_list_id__in=asset_ids,
            Auth_Status__in=['U', 'P']
        ).values_list('aldm_id', flat=True)
        
        if not related_records:
            return {
                'success': True,
                'message': f"ບໍ່ມີລາຍການ pending ສຳລັບ asset_ids {asset_ids}",
                'summary': {'total_items': 0, 'success_count': 0, 'error_count': 0}
            }
        
        # ໃຊ້ bulk_confirm_depreciation
        aldm_ids = list(related_records)
        result = bulk_confirm_depreciation(aldm_ids, status, reason, user_id)
        
        # ເພີ່ມຂໍ້ມູນເສີມ
        if result.get('success'):
            result['bulk_by_asset_info'] = {
                'asset_ids': asset_ids,
                'found_aldm_ids': aldm_ids,
                'operation': 'confirm_by_asset_ids'
            }
        
        return result
        
    except Exception as e:
        return {"error": f"Bulk confirm by asset IDs error: {str(e)}"}
def process_overdue_depreciation(urgency_levels=None, user_id=None):
    """
    🔧 ຫັກຄ່າເສື່ອມລາຄາທີ່ຄ້າງທັງໝົດ ຫຼື ຕາມລະດັບທີ່ເລືອກ
    
    Args:
        urgency_levels: ['critical', 'high'] ຫຼື None (ທັງໝົດ)
        user_id: User ID
    """
    try:
        # ຫາລາຍການຄ້າງຫັກ
        overdue_result = get_overdue_depreciation_items()
        
        if not overdue_result['success']:
            return overdue_result
        
        # ເລືອກລາຍການຕາມລະດັບ
        items_to_process = []
        
        if urgency_levels:
            # ເລືອກເຉພາະລະດັບທີ່ຕ້ອງການ
            for item in overdue_result['overdue_items']:
                if item['urgency_level'] in urgency_levels:
                    items_to_process.append(item)
        else:
            # ຫັກທັງໝົດ
            items_to_process = overdue_result['overdue_items']
        
        if not items_to_process:
            return {
                'success': True,
                'message': f"ບໍ່ມີລາຍການຄ້າງຫັກທີ່ຕ້ອງການປະມວນຜົນ",
                'summary': {
                    'total_items': 0,
                    'success_count': 0,
                    'error_count': 0
                },
                'details': []
            }
        
        # ດຶງ mapping_ids
        mapping_ids = [item['mapping_id'] for item in items_to_process]
        
        # ຫັກທຸກລາຍການ
        with transaction.atomic():
            process_result = process_bulk_depreciation(mapping_ids, check_only=False, user_id=user_id)
        
        # ເພີ່ມຂໍ້ມູນເສີມ
        process_result['overdue_processing'] = {
            'urgency_levels_processed': urgency_levels or 'all',
            'total_overdue_items': len(overdue_result['overdue_items']),
            'processed_items': len(items_to_process),
            'skipped_items': len(overdue_result['overdue_items']) - len(items_to_process)
        }
        
        return process_result
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Process overdue error: {str(e)}"
        }
@csrf_exempt
def overdue_depreciation_api(request):
    """
    API ສຳລັບຈັດການລາຍການຄ້າງຫັກຄ່າເສື່ອມລາຄາ
    
    Actions:
    - get_overdue: ດຶງລາຍການຄ້າງຫັກທັງໝົດ
    - get_by_urgency: ດຶງຕາມລະດັບຄວາມສຳຄັນ (ຕ້ອງມີ urgency_level)
    - process_overdue: ຫັກລາຍການຄ້າງຫັກທັງໝົດ
    - process_by_urgency: ຫັກຕາມລະດັບທີ່ເລືອກ (ຕ້ອງມີ urgency_levels)
    """
    try:
        # ກວດສອບ method
        if request.method not in ['POST', 'GET']:
            return JsonResponse({'error': 'ໃຊ້ POST ຫຼື GET method'})
        
        # ດຶງຂໍ້ມູນ
        if request.method == 'POST':
            if not request.body:
                return JsonResponse({'error': 'ບໍ່ມີ request body'})
            
            try:
                data = json.loads(request.body)
            except json.JSONDecodeError as e:
                return JsonResponse({'error': f'JSON error: {str(e)}'})
            
            action = data.get('action', 'get_overdue')
            urgency_level = data.get('urgency_level')
            urgency_levels = data.get('urgency_levels', [])
            user_id = data.get('user_id')
        else:  # GET
            action = request.GET.get('action', 'get_overdue')
            urgency_level = request.GET.get('urgency_level')
            urgency_levels_str = request.GET.get('urgency_levels', '')
            urgency_levels = urgency_levels_str.split(',') if urgency_levels_str else []
            user_id = request.GET.get('user_id')
        
        
        if action == 'get_overdue':
            
            result = get_overdue_depreciation_items()
            
        elif action == 'get_by_urgency':
            
            if not urgency_level:
                return JsonResponse({
                    'error': 'ໃສ່ urgency_level',
                    'valid_levels': ['critical', 'high', 'medium', 'low', 'warning'],
                    'example': '{"action": "get_by_urgency", "urgency_level": "critical"}'
                })
            result = get_overdue_by_urgency_level(urgency_level)
            
        elif action == 'process_overdue':
           
            result = process_overdue_depreciation(urgency_levels=None, user_id=user_id)
            
        elif action == 'process_by_urgency':
           
            if not urgency_levels:
                return JsonResponse({
                    'error': 'ໃສ່ urgency_levels',
                    'valid_levels': ['critical', 'high', 'medium', 'low'],
                    'examples': {
                        'POST': '{"action": "process_by_urgency", "urgency_levels": ["critical", "high"], "user_id": 1}',
                        'GET': '?action=process_by_urgency&urgency_levels=critical,high&user_id=1'
                    }
                })
            result = process_overdue_depreciation(urgency_levels=urgency_levels, user_id=user_id)
            
        else:
            return JsonResponse({
                'error': f'action "{action}" ບໍ່ຖືກຕ້ອງ',
                'valid_actions': ['get_overdue', 'get_by_urgency', 'process_overdue', 'process_by_urgency'],
                'examples': {
                    'get_all': '{"action": "get_overdue"}',
                    'get_critical': '{"action": "get_by_urgency", "urgency_level": "critical"}',
                    'process_all': '{"action": "process_overdue", "user_id": 1}',
                    'process_urgent': '{"action": "process_by_urgency", "urgency_levels": ["critical", "high"], "user_id": 1}'
                }
            })
        
        # ກວດສອບຜົນລັບ
        if isinstance(result, dict) and 'error' in result:
            return JsonResponse(result, status=400)
        
        return JsonResponse({
            'success': True,
            'action': action,
            'data': result,
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        import traceback
        error_details = {
            'error': str(e),
            'type': type(e).__name__,
            'traceback': traceback.format_exc()
        }
        print("Overdue API Error Details:", error_details)
        return JsonResponse(error_details, status=500)
    


    
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def setup_default_eod_functions(request):
    """
    Setup default EOD functions
    """
    try:
        from .eod_helpers import create_default_eod_functions
        
        success, message = create_default_eod_functions()
        
        if success:
            return Response({
                'message': message
            }, status=status.HTTP_201_CREATED)
        else:
            return Response({
                'error': message
            }, status=status.HTTP_400_BAD_REQUEST)
            
    except Exception as e:
        return Response({
            'error': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def validate_eod_prerequisites_view(request):
    """
    Validate EOD prerequisites
    """
    try:
        from .eod_helpers import validate_eod_prerequisites
        
        is_valid, issues = validate_eod_prerequisites()
        
        return Response({
            'can_start_eod': is_valid,
            'issues': issues,
            'message': 'ພ້ອມເລີ່ມ EOD' if is_valid else 'ມີບັນຫາທີ່ຕ້ອງແກ້ໄຂກ່ອນ'
        })
        
    except Exception as e:
        return Response({
            'can_start_eod': False,
            'issues': [f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'],
            'message': 'ບໍ່ສາມາດກວດສອບໄດ້'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# Store Procedure for FCY Trial Balance ----------------------------------->

from django.db import connection
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

def run_trial_balance_fcy_proc(ac_ccy_id: str, date_start: str, date_end: str):
    """
    Execute the FCY trial balance stored procedure
    
    Args:
        ac_ccy_id (str): Currency ID (LAK, USD, THB, etc.)
        date_start (str): Start date in YYYY-MM-DD format
        date_end (str): End date in YYYY-MM-DD format
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            # Use parameterized SQL to prevent SQL injection
            sql = """
                EXEC dbo.Somtop_Trail_Balance_All_Currency_Consolidated_fcy
                    @ac_ccy_id = %s,
                    @DateStart = %s,
                    @DateEnd = %s
            """
            
            cursor.execute(sql, [ac_ccy_id, date_start, date_end])
            
            # Get column names
            columns = [col[0] for col in cursor.description]
            
            # Fetch all results and convert to list of dictionaries
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing FCY trial balance procedure: {str(e)}")
        raise


def validate_date_format(date_string: str) -> bool:
    """
    Validate date format (YYYY-MM-DD)
    
    Args:
        date_string (str): Date string to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    try:
        datetime.strptime(date_string, '%Y-%m-%d')
        return True
    except ValueError:
        return False


def validate_date_range(date_start: str, date_end: str) -> bool:
    """
    Validate that start date is before or equal to end date
    
    Args:
        date_start (str): Start date
        date_end (str): End date
    
    Returns:
        bool: True if valid range, False otherwise
    """
    try:
        start = datetime.strptime(date_start, '%Y-%m-%d')
        end = datetime.strptime(date_end, '%Y-%m-%d')
        return start <= end
    except ValueError:
        return False


def validate_currency_code(currency_code: str) -> bool:
    """
    Validate currency code format and allowed values
    
    Args:
        currency_code (str): Currency code to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    if not currency_code or not isinstance(currency_code, str):
        return False
    
    # Check length (should be 3-5 characters based on stored procedure parameter)
    if len(currency_code) < 3 or len(currency_code) > 5:
        return False
    
    # Common currency codes (you can extend this list as needed)
    allowed_currencies = ['LAK', 'USD', 'THB', 'EUR', 'JPY', 'CNY', 'VND']
    
    return currency_code.upper() in allowed_currencies


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def trial_balance_fcy_view(request):
    """
    API endpoint for FCY trial balance by currency
    
    Expected payload:
    {
        "ac_ccy_id": "USD|LAK|THB|etc",
        "date_start": "YYYY-MM-DD",
        "date_end": "YYYY-MM-DD"
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "currency": "currency_code",
        "count": number_of_records,
        "data": [trial_balance_records]
    }
    """
    # Extract parameters from request
    ac_ccy_id = request.data.get("ac_ccy_id")
    date_start = request.data.get("date_start")
    date_end = request.data.get("date_end")
    
    # Validate required parameters
    if not ac_ccy_id or not date_start or not date_end:
        return Response({
            "status": "error",
            "message": "Missing required parameters: ac_ccy_id, date_start and date_end are required",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate currency code
    if not validate_currency_code(ac_ccy_id):
        return Response({
            "status": "error",
            "message": "Invalid currency code. Supported currencies: LAK, USD, THB, EUR, JPY, CNY, VND",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate date formats
    if not validate_date_format(date_start):
        return Response({
            "status": "error",
            "message": "Invalid date_start format. Expected: YYYY-MM-DD",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    if not validate_date_format(date_end):
        return Response({
            "status": "error",
            "message": "Invalid date_end format. Expected: YYYY-MM-DD",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate date range
    if not validate_date_range(date_start, date_end):
        return Response({
            "status": "error",
            "message": "Invalid date range: date_start must be before or equal to date_end",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        # Convert currency to uppercase for consistency
        ac_ccy_id = ac_ccy_id.upper()
        
        logger.info(f"[TrialBalanceFCY] Executing procedure for {ac_ccy_id} from {date_start} to {date_end}")
        
        # Execute stored procedure
        result = run_trial_balance_fcy_proc(ac_ccy_id, date_start, date_end)
        
        logger.info(f"[TrialBalanceFCY] Procedure completed successfully. Currency: {ac_ccy_id}, Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": f"FCY trial balance data for {ac_ccy_id} retrieved successfully",
            "currency": ac_ccy_id,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[TrialBalanceFCY] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "Internal server error occurred while processing request",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def trial_balance_fcy_get_view(request):
    """
    GET endpoint for FCY trial balance (using query parameters)
    
    Query parameters:
    - ac_ccy_id: Currency code (USD, LAK, THB, etc.)
    - date_start: Start date (YYYY-MM-DD)
    - date_end: End date (YYYY-MM-DD)
    """
    # Extract parameters from query params
    ac_ccy_id = request.query_params.get("ac_ccy_id")
    date_start = request.query_params.get("date_start")
    date_end = request.query_params.get("date_end")
    
    # Validate required parameters
    if not ac_ccy_id or not date_start or not date_end:
        return Response({
            "status": "error",
            "message": "Missing required query parameters: ac_ccy_id, date_start and date_end",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate currency code
    if not validate_currency_code(ac_ccy_id):
        return Response({
            "status": "error",
            "message": "Invalid currency code. Supported currencies: LAK, USD, THB, EUR, JPY, CNY, VND",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate date formats
    if not validate_date_format(date_start) or not validate_date_format(date_end):
        return Response({
            "status": "error",
            "message": "Invalid date format. Expected: YYYY-MM-DD",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate date range
    if not validate_date_range(date_start, date_end):
        return Response({
            "status": "error",
            "message": "Invalid date range: date_start must be before or equal to date_end",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        # Convert currency to uppercase for consistency
        ac_ccy_id = ac_ccy_id.upper()
        
        logger.info(f"[TrialBalanceFCY-GET] Executing procedure for {ac_ccy_id} from {date_start} to {date_end}")
        
        # Execute stored procedure
        result = run_trial_balance_fcy_proc(ac_ccy_id, date_start, date_end)
        
        logger.info(f"[TrialBalanceFCY-GET] Procedure completed successfully. Currency: {ac_ccy_id}, Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": f"FCY trial balance data for {ac_ccy_id} retrieved successfully",
            "currency": ac_ccy_id,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[TrialBalanceFCY-GET] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "Internal server error occurred while processing request",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# Optional: ViewSet approach for more advanced functionality
from rest_framework import viewsets
from rest_framework.decorators import action

class TrialBalanceFCYViewSet(viewsets.ViewSet):
    """
    ViewSet for FCY Trial Balance operations
    """
    permission_classes = [IsAuthenticated]
    
    @action(detail=False, methods=['post', 'get'])
    def get_balance(self, request):
        """
        Get FCY trial balance data
        
        POST: Use request body
        GET: Use query parameters
        """
        if request.method == 'POST':
            return trial_balance_fcy_view(request)
        else:
            return trial_balance_fcy_get_view(request)
    
    @action(detail=False, methods=['get'])
    def supported_currencies(self, request):
        """
        Get list of supported currencies
        """
        currencies = ['LAK', 'USD', 'THB', 'EUR', 'JPY', 'CNY', 'VND']
        
        return Response({
            "status": "success",
            "message": "Supported currencies retrieved successfully",
            "count": len(currencies),
            "data": {
                "currencies": currencies,
                "descriptions": {
                    "LAK": "Lao Kip",
                    "USD": "US Dollar", 
                    "THB": "Thai Baht",
                    "EUR": "Euro",
                    "JPY": "Japanese Yen",
                    "CNY": "Chinese Yuan",
                    "VND": "Vietnamese Dong"
                }
            }
        }, status=status.HTTP_200_OK)

#Store Procedure LCY --------------------------->

from django.db import connection
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

def run_trial_balance_consolidated_proc(date_start: str, date_end: str):
    """
    Execute the consolidated trial balance stored procedure
    
    Args:
        date_start (str): Start date in YYYY-MM-DD format
        date_end (str): End date in YYYY-MM-DD format
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            # Use parameterized SQL to prevent SQL injection
            sql = """
                EXEC dbo.Somtop_Trail_Balance_All_Currency_Consolidated_lcy
                    @DateStart = %s,
                    @DateEnd = %s
            """
            
            cursor.execute(sql, [date_start, date_end])
            
            # Get column names
            columns = [col[0] for col in cursor.description]
            
            # Fetch all results and convert to list of dictionaries
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing consolidated trial balance procedure: {str(e)}")
        raise


def validate_date_format(date_string: str) -> bool:
    """
    Validate date format (YYYY-MM-DD)
    
    Args:
        date_string (str): Date string to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    try:
        datetime.strptime(date_string, '%Y-%m-%d')
        return True
    except ValueError:
        return False


def validate_date_range(date_start: str, date_end: str) -> bool:
    """
    Validate that start date is before or equal to end date
    
    Args:
        date_start (str): Start date
        date_end (str): End date
    
    Returns:
        bool: True if valid range, False otherwise
    """
    try:
        start = datetime.strptime(date_start, '%Y-%m-%d')
        end = datetime.strptime(date_end, '%Y-%m-%d')
        return start <= end
    except ValueError:
        return False


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def trial_balance_consolidated_view(request):
    """
    API endpoint for consolidated trial balance across all currencies
    
    Expected payload:
    {
        "date_start": "YYYY-MM-DD",
        "date_end": "YYYY-MM-DD"
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "count": number_of_records,
        "data": [trial_balance_records]
    }
    """
    # Extract parameters from request
    date_start = request.data.get("date_start")
    date_end = request.data.get("date_end")
    
    # Validate required parameters
    if not date_start or not date_end:
        return Response({
            "status": "error",
            "message": "Missing required parameters: date_start and date_end are required",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate date formats
    if not validate_date_format(date_start):
        return Response({
            "status": "error",
            "message": "Invalid date_start format. Expected: YYYY-MM-DD",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    if not validate_date_format(date_end):
        return Response({
            "status": "error",
            "message": "Invalid date_end format. Expected: YYYY-MM-DD",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate date range
    if not validate_date_range(date_start, date_end):
        return Response({
            "status": "error",
            "message": "Invalid date range: date_start must be before or equal to date_end",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[TrialBalanceConsolidated] Executing procedure from {date_start} to {date_end}")
        
        # Execute stored procedure
        result = run_trial_balance_consolidated_proc(date_start, date_end)
        
        logger.info(f"[TrialBalanceConsolidated] Procedure completed successfully. Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": "Trial balance data retrieved successfully",
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[TrialBalanceConsolidated] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "Internal server error occurred while processing request",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def trial_balance_consolidated_get_view(request):
    """
    GET endpoint for consolidated trial balance (using query parameters)
    
    Query parameters:
    - date_start: Start date (YYYY-MM-DD)
    - date_end: End date (YYYY-MM-DD)
    """
    # Extract parameters from query params
    date_start = request.query_params.get("date_start")
    date_end = request.query_params.get("date_end")
    
    # Validate required parameters
    if not date_start or not date_end:
        return Response({
            "status": "error",
            "message": "Missing required query parameters: date_start and date_end",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate date formats
    if not validate_date_format(date_start) or not validate_date_format(date_end):
        return Response({
            "status": "error",
            "message": "Invalid date format. Expected: YYYY-MM-DD",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate date range
    if not validate_date_range(date_start, date_end):
        return Response({
            "status": "error",
            "message": "Invalid date range: date_start must be before or equal to date_end",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[TrialBalanceConsolidated-GET] Executing procedure from {date_start} to {date_end}")
        
        # Execute stored procedure
        result = run_trial_balance_consolidated_proc(date_start, date_end)
        
        logger.info(f"[TrialBalanceConsolidated-GET] Procedure completed successfully. Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": "Trial balance data retrieved successfully",
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[TrialBalanceConsolidated-GET] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "Internal server error occurred while processing request",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# BALANCE SHEET
from django.db import connection
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

def run_balance_sheet_acc_proc(segment: str, currency: str, period_code_id: str):
    """
    Execute the balance sheet ACC stored procedure
    
    Args:
        segment (str): FCY or LCY
        currency (str): Currency code (LAK, USD, THB, etc.)
        period_code_id (str): Period code ID

    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            # Use parameterized SQL to prevent SQL injection
            sql = """
                EXEC dbo.balancesheet_acc_By_Currency_And_Consolidated_afterEOC
                    @segment = %s,
                    @currency = %s,
                    @period_code_id = %s
            """

            cursor.execute(sql, [segment, currency, period_code_id])

            # Get column names
            columns = [col[0] for col in cursor.description]
            
            # Fetch all results and convert to list of dictionaries
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing balance sheet ACC procedure: {str(e)}")
        raise

def run_balance_sheet_mfi_proc(segment: str, currency: str, period_code_id: str):
    """
    Execute the balance sheet MFI stored procedure
    
    Args:
        segment (str): FCY or LCY
        currency (str): Currency code (LAK, USD, THB, etc.)
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            # Use parameterized SQL to prevent SQL injection
            sql = """
                EXEC dbo.balancesheet_mfi_By_Currency_And_Consolidated_afterEOC
                    @segment = %s,
                    @currency = %s,
                    @period_code_id = %s
            """

            cursor.execute(sql, [segment, currency, period_code_id])

            # Get column names
            columns = [col[0] for col in cursor.description]
            
            # Fetch all results and convert to list of dictionaries
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing balance sheet MFI procedure: {str(e)}")
        raise



def validate_segment(segment: str) -> bool:
    """
    Validate segment parameter
    
    Args:
        segment (str): Segment value to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    if not segment or not isinstance(segment, str):
        return False
    
    valid_segments = ['FCY', 'LCY']
    return segment.upper() in valid_segments

def validate_currency_code(currency_code: str) -> bool:
    """
    Validate currency code format and allowed values
    
    Args:
        currency_code (str): Currency code to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    if not currency_code or not isinstance(currency_code, str):
        return False
    
    # Check length (should be 3-5 characters)
    if len(currency_code) < 3 or len(currency_code) > 5:
        return False
    
    # Common currency codes supported
    allowed_currencies = ['LAK', 'USD', 'THB', 'EUR', 'JPY', 'CNY', 'VND']
    
    return currency_code.upper() in allowed_currencies

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def balance_sheet_acc_view(request):
    """
    API endpoint for balance sheet ACC data
    
    Expected payload:
    {
        "segment": "FCY|LCY",
        "currency": "LAK|USD|THB|etc"
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "segment": "segment_type",
        "currency": "currency_code",
        "type": "ACC",
        "count": number_of_records,
        "data": [balance_sheet_records]
    }
    """
    # Extract parameters from request
    segment = request.data.get("segment")
    currency = request.data.get("currency")
    period_code_id = request.data.get("period_code_id")  # <-- ADD THIS LINE
    
    # Validate required parameters
    if not segment or not currency:
        return Response({
            "status": "error",
            "message": "ບໍ່ມີຂໍ້ມູນທີ່ຈຳເປັນ: segment ແລະ currency ແມ່ນຕ້ອງການ (Missing required parameters: segment and currency are required)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Convert to uppercase for consistency
    segment = segment.upper()
    currency = currency.upper()
    period_code_id = period_code_id.upper()
    
    # Validate segment
    if not validate_segment(segment):
        return Response({
            "status": "error",
            "message": "ຄ່າ segment ບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້: FCY ຫຼື LCY (Invalid segment. Supported values: FCY, LCY)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate currency code
    if not validate_currency_code(currency):
        return Response({
            "status": "error",
            "message": "ລະຫັດສະກຸນເງິນບໍ່ຖືກຕ້ອງ ສະກຸນເງິນທີ່ຮອງຮັບ: LAK, USD, THB, EUR, JPY, CNY, VND (Invalid currency code. Supported currencies: LAK, USD, THB, EUR, JPY, CNY, VND)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[BalanceSheet-ACC] Executing procedure for segment={segment}, currency={currency}, period_code_id ={period_code_id}" )
        
        # Execute stored procedure
        result = run_balance_sheet_acc_proc(segment, currency, period_code_id)

        logger.info(f"[BalanceSheet-ACC] Procedure completed successfully. Segment: {segment}, Currency: {currency},  period_code_id ={period_code_id} , Records: {len(result)}")
        
        # Determine display message based on segment
        display_currency = f"{currency} (FCY)" if segment == 'FCY' else f"LAK (ທຽບເທົ່າ)"
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ ACC ສຳລັບ {display_currency} ສຳເລັດ (Balance sheet ACC data retrieved successfully - {display_currency})",
            "segment": segment,
            "currency": currency,
            "period_code_id": period_code_id,
            "type": "ACC",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[BalanceSheet-ACC] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ ACC (Internal server error occurred while retrieving balance sheet ACC data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def balance_sheet_mfi_view(request):
    """
    API endpoint for balance sheet MFI data
    
    Expected payload:
    {
        "segment": "FCY|LCY",
        "currency": "LAK|USD|THB|etc"
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "segment": "segment_type",
        "currency": "currency_code",
        "type": "MFI",
        "count": number_of_records,
        "data": [balance_sheet_records]
    }
    """
    # Extract parameters from request
    segment = request.data.get("segment")
    currency = request.data.get("currency")
    period_code_id = request.data.get("period_code_id")
    
    # Validate required parameters
    if not segment or not currency or not period_code_id:
        return Response({
            "status": "error",
            "message": "ບໍ່ມີຂໍ້ມູນທີ່ຈຳເປັນ: segment ແລະ currency ແມ່ນຕ້ອງການ (Missing required parameters: segment and currency and period_code_id are required)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Convert to uppercase for consistency
    segment = segment.upper()
    currency = currency.upper()
    
    # Validate segment
    if not validate_segment(segment):
        return Response({
            "status": "error",
            "message": "ຄ່າ segment ບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້: FCY ຫຼື LCY (Invalid segment. Supported values: FCY, LCY)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate currency code
    if not validate_currency_code(currency):
        return Response({
            "status": "error",
            "message": "ລະຫັດສະກຸນເງິນບໍ່ຖືກຕ້ອງ ສະກຸນເງິນທີ່ຮອງຮັບ: LAK, USD, THB, EUR, JPY, CNY, VND (Invalid currency code. Supported currencies: LAK, USD, THB, EUR, JPY, CNY, VND)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[BalanceSheet-MFI] Executing procedure for segment={segment}, currency={currency}, period_code_id={period_code_id}")
        
        # Execute stored procedure
        result = run_balance_sheet_mfi_proc(segment, currency, period_code_id)

        logger.info(f"[BalanceSheet-MFI] Procedure completed successfully. Segment: {segment}, Currency: {currency}, Period Code ID: {period_code_id}, Records: {len(result)}")
        
        # Determine display message based on segment
        display_currency = f"{currency} (FCY)" if segment == 'FCY' else f"LAK (ທຽບເທົ່າ)"
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ MFI ສຳລັບ {display_currency} ສຳເລັດ (Balance sheet MFI data retrieved successfully - {display_currency})",
            "segment": segment,
            "currency": currency,
            "period_code_id": period_code_id,
            "type": "MFI",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[BalanceSheet-MFI] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ MFI (Internal server error occurred while retrieving balance sheet MFI data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def balance_sheet_acc_get_view(request):
    """
    GET endpoint for balance sheet ACC data (using query parameters)
    
    Query parameters:
    - segment: FCY or LCY
    - currency: Currency code (LAK, USD, THB, etc.)
    """
    # Extract parameters from query params
    segment = request.query_params.get("segment")
    currency = request.query_params.get("currency")
    period_code_id = request.query_params.get("period_code_id")
    
    # Validate required parameters
    if not segment or not currency or not period_code_id:
        return Response({
            "status": "error",
            "message": "ບໍ່ມີ query parameters ທີ່ຈຳເປັນ: segment ແລະ currency (Missing required query parameters: segment and currency)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Convert to uppercase for consistency
    segment = segment.upper()
    currency = currency.upper()
    
    # Validate parameters
    if not validate_segment(segment) or not validate_currency_code(currency):
        return Response({
            "status": "error",
            "message": "ຄ່າ parameters ບໍ່ຖືກຕ້ອງ (Invalid parameters. Supported: segment=FCY/LCY, currency=LAK/USD/THB/etc)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[BalanceSheet-ACC-GET] Executing procedure for segment={segment}, currency={currency}")
        
        # Execute stored procedure
        result = run_balance_sheet_acc_proc(segment, currency, period_code_id)
        
        logger.info(f"[BalanceSheet-ACC-GET] Procedure completed successfully. Records: {len(result)}")
        
        display_currency = f"{currency} (FCY)" if segment == 'FCY' else f"LAK (ທຽບເທົ່າ)"
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ ACC ສຳລັບ {display_currency} ສຳເລັດ",
            "segment": segment,
            "currency": currency,
            "period_code_id": period_code_id,
            "type": "ACC",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[BalanceSheet-ACC-GET] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ ACC",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def balance_sheet_mfi_get_view(request):
    """
    GET endpoint for balance sheet MFI data (using query parameters)
    
    Query parameters:
    - segment: FCY or LCY
    - currency: Currency code (LAK, USD, THB, etc.)
    """
    # Extract parameters from query params
    segment = request.query_params.get("segment")
    currency = request.query_params.get("currency")
    period_code_id = request.query_params.get("period_code_id")
    
    # Validate required parameters
    if not segment or not currency:
        return Response({
            "status": "error",
            "message": "ບໍ່ມີ query parameters ທີ່ຈຳເປັນ: segment ແລະ currency (Missing required query parameters: segment and currency)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Convert to uppercase for consistency
    segment = segment.upper()
    currency = currency.upper()
    period_code_id = period_code_id.upper()

    # Validate parameters
    if not validate_segment(segment) or not validate_currency_code(currency):
        return Response({
            "status": "error",
            "message": "ຄ່າ parameters ບໍ່ຖືກຕ້ອງ (Invalid parameters. Supported: segment=FCY/LCY, currency=LAK/USD/THB/etc)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[BalanceSheet-MFI-GET] Executing procedure for segment={segment}, currency={currency}")
        
        # Execute stored procedure
        result = run_balance_sheet_mfi_proc(segment, currenc, period_code_id)
        
        logger.info(f"[BalanceSheet-MFI-GET] Procedure completed successfully. Records: {len(result)}")
        
        display_currency = f"{currency} (FCY)" if segment == 'FCY' else f"LAK (ທຽບເທົ່າ)"
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ MFI ສຳລັບ {display_currency} ສຳເລັດ",
            "segment": segment,
            "currency": currency,
            "period_code_id": period_code_id,
            "type": "MFI",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[BalanceSheet-MFI-GET] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ MFI",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# Optional: ViewSet approach for more advanced functionality
from rest_framework import viewsets
from rest_framework.decorators import action

class BalanceSheetViewSet(viewsets.ViewSet):
    """
    ViewSet for Balance Sheet operations
    """
    permission_classes = [IsAuthenticated]
    
    @action(detail=False, methods=['post', 'get'])
    def acc_data(self, request):
        """
        Get balance sheet ACC data
        
        POST: Use request body
        GET: Use query parameters
        """
        if request.method == 'POST':
            return balance_sheet_acc_view(request)
        else:
            return balance_sheet_acc_get_view(request)
    
    @action(detail=False, methods=['post', 'get'])
    def mfi_data(self, request):
        """
        Get balance sheet MFI data
        
        POST: Use request body
        GET: Use query parameters
        """
        if request.method == 'POST':
            return balance_sheet_mfi_view(request)
        else:
            return balance_sheet_mfi_get_view(request)
    
    @action(detail=False, methods=['get'])
    def supported_options(self, request):
        """
        Get list of supported segments and currencies for balance sheet
        """
        segments = [
            {
                'value': 'FCY',
                'title': 'Foreign Currency (FCY)',
                'description': 'ສະກຸນເງິນຕ່າງປະເທດ',
                'currencies': ['USD', 'THB', 'EUR', 'JPY', 'CNY', 'VND', 'LAK']
            },
            {
                'value': 'LCY',
                'title': 'Local Currency Equivalent (LCY)', 
                'description': 'ທຽບເທົ່າກີບລາວ',
                'currencies': ['LAK']
            }
        ]
        
        currencies = {
            'LAK': 'ກີບລາວ (Lao Kip)',
            'USD': 'ໂດລາສະຫະລັດ (US Dollar)', 
            'THB': 'ບາດໄທ (Thai Baht)',
            'EUR': 'ເອີໂຣ (Euro)',
            'JPY': 'ເຢນຍີ່ປຸ່ນ (Japanese Yen)',
            'CNY': 'ຫຍວນຈີນ (Chinese Yuan)',
            'VND': 'ດົງຫວຽດນາມ (Vietnamese Dong)'
        }
        
        return Response({
            "status": "success",
            "message": "ດຶງຂໍ້ມູນ segments ແລະສະກຸນເງິນທີ່ຮອງຮັບສຳເລັດ",
            "count": len(segments),
            "data": {
                "segments": segments,
                "currencies": currencies,
                "types": ["ACC", "MFI"]
            }
        }, status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def compare_acc_mfi(self, request):
        """
        Compare ACC and MFI balance sheet data for the same segment and currency
        
        Expected payload:
        {
            "segment": "FCY|LCY",
            "currency": "USD|THB|etc"
        }
        """
        segment = request.data.get("segment")
        currency = request.data.get("currency")
        
        if not segment or not currency:
            return Response({
                "status": "error",
                "message": "ບໍ່ມີຂໍ້ມູນທີ່ຈຳເປັນ (Missing required parameters: segment and currency)",
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        segment = segment.upper()
        currency = currency.upper()
        
        if not validate_segment(segment) or not validate_currency_code(currency):
            return Response({
                "status": "error",
                "message": "ຄ່າ parameters ບໍ່ຖືກຕ້ອງ (Invalid parameters)",
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Get both ACC and MFI data
            acc_result = run_balance_sheet_acc_proc(segment, currency)
            mfi_result = run_balance_sheet_mfi_proc(segment, currency)
            
            display_currency = f"{currency} (FCY)" if segment == 'FCY' else f"LAK (ທຽບເທົ່າ)"
            
            # Calculate totals for ACC
            acc_total_debit = sum(float(item.get('debit_amount', 0)) for item in acc_result)
            acc_total_credit = sum(float(item.get('credit_amount', 0)) for item in acc_result)
            acc_total_net = sum(float(item.get('net_amount', 0)) for item in acc_result)
            
            # Calculate totals for MFI
            mfi_total_debit = sum(float(item.get('debit_amount', 0)) for item in mfi_result)
            mfi_total_credit = sum(float(item.get('credit_amount', 0)) for item in mfi_result)
            mfi_total_net = sum(float(item.get('net_amount', 0)) for item in mfi_result)
            
            return Response({
                "status": "success",
                "message": f"ສົມທຽບຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ ACC ແລະ MFI ສຳລັບ {display_currency} ສຳເລັດ",
                "segment": segment,
                "currency": currency,
                "display_currency": display_currency,
                "data": {
                    "acc": {
                        "count": len(acc_result),
                        "totalDebit": acc_total_debit,
                        "totalCredit": acc_total_credit,
                        "totalNet": acc_total_net,
                        "data": acc_result
                    },
                    "mfi": {
                        "count": len(mfi_result),
                        "totalDebit": mfi_total_debit,
                        "totalCredit": mfi_total_credit,
                        "totalNet": mfi_total_net,
                        "data": mfi_result
                    }
                }
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.exception(f"[BalanceSheet-Compare] Error comparing ACC and MFI: {str(e)}")
            
            return Response({
                "status": "error",
                "message": "ເກີດຂໍ້ຜິດພາດໃນການສົມທຽບຂໍ້ມູນ ACC ແລະ MFI",
                "data": None
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from django.db import transaction
from django.core.exceptions import ValidationError
from datetime import datetime
import logging

from .models import Dairy_Report, MTTB_Ccy_DEFN, MTTB_Fin_Cycle, MTTB_Per_Code, MTTB_Users
from .serializers import DairyReportSerializer

logger = logging.getLogger(__name__)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def bulk_insert_dairy_report(request):
    """
    Clear existing data and bulk insert trial balance data into Dairy_Report model
    Expected payload:
    {
        "data": [
            {
                "acc_no": "110",
                "Desc": "Cash or Cash Equivalent",
                "CCy_Code": "LAK",
                "OP_DR": 0.0,
                "OP_CR": 0.0,
                "Mo_DR": 2116880.0,
                "Mo_Cr": 3710692001.0,
                "C1_DR": 0.0,
                "C1_CR": 3708575121.0,
                "Fin_year": "2025",
                "Period_code": "202507",
                "StartDate": "2023-01-01",
                "EndDate": "2025-07-24",
                "Category": "TRIAL_BALANCE"
            }
        ]
    }
    """
    try:
        # Validate request data
        if not request.data or 'data' not in request.data:
            return Response({
                'status': 'error',
                'message': 'ບໍ່ມີຂໍ້ມູນສຳລັບການນຳເຂົ້າ (No data provided for import)'
            }, status=status.HTTP_400_BAD_REQUEST)

        data_list = request.data['data']
        
        if not isinstance(data_list, list) or len(data_list) == 0:
            return Response({
                'status': 'error',
                'message': 'ຂໍ້ມູນບໍ່ຖືກຕ້ອງ ຫຼື ເປັນລິສຄ່າງ (Invalid data format or empty list)'
            }, status=status.HTTP_400_BAD_REQUEST)

        created_records = []
        failed_records = []
        deleted_count = 0
        
        with transaction.atomic():
            try:
                # Step 1: Clear existing data from Dairy_Report
                logger.info("Starting to clear existing Dairy_Report data")
                deleted_count = Dairy_Report.objects.all().count()
                Dairy_Report.objects.all().delete()
                logger.info(f"Successfully cleared {deleted_count} existing records from Dairy_Report")
                
            except Exception as e:
                logger.error(f"Error clearing Dairy_Report data: {str(e)}")
                return Response({
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນເກົ່າ: {str(e)} (Error clearing existing data)'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

            # Step 2: Insert new data
            logger.info(f"Starting to insert {len(data_list)} new records")
            
            for index, item in enumerate(data_list):
                try:
                    # Get or create related objects
                    ccy_obj = None
                    if item.get('CCy_Code'):
                        try:
                            ccy_obj = MTTB_Ccy_DEFN.objects.get(ccy_code=item['CCy_Code'])
                        except MTTB_Ccy_DEFN.DoesNotExist:
                            logger.warning(f"Currency {item['CCy_Code']} not found for record {index}")

                    fin_year_obj = None
                    if item.get('Fin_year'):
                        try:
                            fin_year_obj = MTTB_Fin_Cycle.objects.get(fin_cycle=item['Fin_year'])
                        except MTTB_Fin_Cycle.DoesNotExist:
                            logger.warning(f"Financial year {item['Fin_year']} not found for record {index}")

                    period_obj = None
                    if item.get('Period_code'):
                        try:
                            period_obj = MTTB_Per_Code.objects.get(period_code=item['Period_code'])
                        except MTTB_Per_Code.DoesNotExist:
                            logger.warning(f"Period code {item['Period_code']} not found for record {index}")

                    # Parse dates
                    start_date = None
                    end_date = None
                    
                    if item.get('StartDate'):
                        try:
                            start_date = datetime.strptime(item['StartDate'], '%Y-%m-%d').date()
                        except ValueError:
                            logger.warning(f"Invalid start date format for record {index}: {item['StartDate']}")

                    if item.get('EndDate'):
                        try:
                            end_date = datetime.strptime(item['EndDate'], '%Y-%m-%d').date()
                        except ValueError:
                            logger.warning(f"Invalid end date format for record {index}: {item['EndDate']}")

                    # Create Dairy_Report record
                    dairy_report = Dairy_Report(
                        DP_ID=index+1,
                        gl_code=item.get('gl_code', ''),
                        Desc=item.get('Desc', ''),
                        CCy_Code=ccy_obj,
                        Fin_year=fin_year_obj,
                        Period_code=period_obj,
                        StartDate=start_date,
                        EndDate=end_date,
                        Category=item.get('Category', 'TRIAL_BALANCE'),
                        OP_DR=item.get('OP_DR', 0),
                        OP_CR=item.get('OP_CR', 0),
                        Mo_DR=item.get('Mo_DR', 0),
                        Mo_Cr=item.get('Mo_Cr', 0),
                        C1_DR=item.get('C1_DR', 0),
                        C1_CR=item.get('C1_CR', 0),
                        # Set LCY fields to same values (you can modify this logic as needed)
                        OP_DR_lcy=item.get('OP_DR', 0),
                        OP_CR_lcy=item.get('OP_CR', 0),
                        Mo_DR_lcy=item.get('Mo_DR', 0),
                        Mo_Cr_lcy=item.get('Mo_Cr', 0),
                        C1_DR_lcy=item.get('C1_DR', 0),
                        C1_CR_lcy=item.get('C1_CR', 0),
                        Maker_Id=request.user,
                        MSegment=item.get('MSegment', '')
                    )
                    
                    # Validate and save the model
                    dairy_report.full_clean()
                    dairy_report.save()
                    
                    created_records.append({
                        'index': index,
                        'gl_code': dairy_report.gl_code,
                        'id': dairy_report.DP_ID
                    })
                    
                except ValidationError as ve:
                    error_message = f"Validation error for record {index}: {str(ve)}"
                    logger.error(error_message)
                    failed_records.append({
                        'index': index,
                        'gl_code': item.get('gl_code', 'Unknown'),
                        'error': error_message
                    })
                    
                except Exception as e:
                    error_message = f"Error processing record {index}: {str(e)}"
                    logger.error(error_message)
                    failed_records.append({
                        'index': index,
                        'gl_code': item.get('gl_code', 'Unknown'),
                        'error': error_message
                    })

        # Prepare response
        response_data = {
            'status': 'success',
            'message': f'ການລຶບແລະນຳເຂົ້າຂໍ້ມູນສຳເລັດ (Clear and import completed successfully)',
            'cleared_records': deleted_count,
            'total_records': len(data_list),
            'inserted_count': len(created_records),
            'failed_count': len(failed_records),
            'created_records': created_records
        }

        if failed_records:
            response_data['failed_records'] = failed_records
            response_data['message'] += f' - {len(failed_records)} ລາຍການຜິດພາດ (records failed)'
            
        logger.info(f"Bulk operation completed: {deleted_count} deleted, {len(created_records)} inserted, {len(failed_records)} failed")

        return Response(response_data, status=status.HTTP_201_CREATED)

    except Exception as e:
        logger.error(f"Bulk insert error: {str(e)}")
        return Response({
            'status': 'error',
            'message': f'ເກີດຂໍ້ຜິດພາດໃນການດຳເນີນງານ: {str(e)} (Error in operation)'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def bulk_delete(request):
    """
    Custom action for bulk deleting dairy report data by criteria
    """
    try:
        # Get filter criteria from request
        fin_year = request.data.get('fin_year')
        period_code = request.data.get('period_code')
        ccy_code = request.data.get('ccy_code')
        category = request.data.get('category', 'TRIAL_BALANCE')
        # Build filter query
        filter_kwargs = {'Category': category}
        
        if fin_year:
            filter_kwargs['Fin_year__fin_year'] = fin_year
        if period_code:
            filter_kwargs['Period_code__period_code'] = period_code
        if ccy_code:
            filter_kwargs['CCy_Code__ccy_code'] = ccy_code
        # Delete matching records
        deleted_count, _ = Dairy_Report.objects.filter(**filter_kwargs).delete()
        return Response({
            'status': 'success',
            'message': f'ລຶບຂໍ້ມູນສຳເລັດ - {deleted_count} ລາຍການ',
            'deleted_count': deleted_count
        }, status=status.HTTP_200_OK)
    except Exception as e:
        logger.error(f"Bulk delete error: {str(e)}")
        return Response({
            'status': 'error',
            'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນ: {str(e)}'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from django.db import transaction, connection
from django.core.exceptions import ValidationError
from datetime import datetime
from decimal import Decimal, ROUND_HALF_UP
import logging
import re

from .models import Dairy_Report, MTTB_GLMaster, MTTB_GLSub, MTTB_Ccy_DEFN, MTTB_Fin_Cycle, MTTB_Per_Code, MTTB_Users

logger = logging.getLogger(__name__)

def safe_decimal_convert(value, default=0, decimal_places=2):
    """
    Safely convert value to decimal with specified decimal places
    """
    try:
        if value is None or value == '' or value == 'None':
            return Decimal(str(default)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
        
        str_value = str(value).strip()
        if not str_value:
            return Decimal(str(default)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            
        decimal_value = Decimal(str_value)
        quantized_value = decimal_value.quantize(
            Decimal('0.' + '0' * decimal_places), 
            rounding=ROUND_HALF_UP
        )
        return quantized_value
        
    except (ValueError, TypeError, AttributeError) as e:
        logger.warning(f"Error converting value '{value}' to decimal: {str(e)}. Using default: {default}")
        return Decimal(str(default)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

def get_gltype_from_gl_code(gl_code):
    """
    Get glType with multiple lookup strategies and decimal handling
    
    Strategy 1: Direct GLMaster lookup by gl_code
    Strategy 2: GLSub lookup: gl_code → GLSub.glsub_code → GLMaster.glType  
    Strategy 3: If contains '.000', return '5'
    """
    try:
        if not gl_code:
            return None
            
        # Strategy 1: Direct lookup in GLMaster.gl_code
        try:
            glmaster_direct = MTTB_GLMaster.objects.filter(
                gl_code=gl_code,
                # Record_Status='C',
                # Auth_Status='A'
            ).first()
            
            if glmaster_direct and glmaster_direct.glType:
                logger.debug(f"Found glType {glmaster_direct.glType} for {gl_code} via direct GLMaster lookup")
                return glmaster_direct.glType
        except Exception as e:
            logger.debug(f"Direct GLMaster lookup failed for {gl_code}: {str(e)}")
        
        # Strategy 2: GLSub lookup
        try:
            glsub = MTTB_GLSub.objects.select_related('gl_code').filter(
                glsub_code=gl_code,
                # Record_Status='C',
                # Auth_Status='A'
            ).first()
            
            if glsub and glsub.gl_code and glsub.gl_code.glType:
                logger.debug(f"Found glType {glsub.gl_code.glType} for {gl_code} via GLSub lookup")
                return glsub.gl_code.glType
        except Exception as e:
            logger.debug(f"GLSub lookup failed for {gl_code}: {str(e)}")
        
        # Strategy 3: Decimal pattern handling
        if '.000' in str(gl_code):
            logger.info(f"GL code {gl_code} contains '.000', setting glType = 5")
            return '5'
            
        logger.warning(f"No glType found for {gl_code}")
        return None
        
    except Exception as e:
        logger.warning(f"glType lookup failed for {gl_code}: {str(e)}")
        # Still check decimal pattern on error
        if '.000' in str(gl_code):
            return '5'
        return None

def get_gltype_lookup_dict():
    """
    Create a comprehensive dictionary mapping gl_code to glType
    Combines both direct GLMaster and GLSub lookups
    """
    try:
        lookup_dict = {}
        
        # Method 1: Direct GLMaster lookup
        glmaster_records = MTTB_GLMaster.objects.filter(
            # Record_Status='C',
            # Auth_Status='A',
            gl_code__isnull=False
        ).exclude(gl_code='')
        
        for glmaster in glmaster_records:
            if glmaster.gl_code and glmaster.glType:
                lookup_dict[glmaster.gl_code] = glmaster.glType
                
        logger.info(f"Added {len(lookup_dict)} direct GLMaster mappings")
        
        # Method 2: GLSub lookup (may override or add to above)
        glsub_records = MTTB_GLSub.objects.select_related('gl_code').filter(
            # Record_Status='C',
            # Auth_Status='A',
            # gl_code__Record_Status='C',
            # gl_code__Auth_Status='A'
        )
        
        glsub_count = 0
        for glsub in glsub_records:
            if glsub.glsub_code and glsub.gl_code and glsub.gl_code.glType:
                lookup_dict[glsub.glsub_code] = glsub.gl_code.glType
                glsub_count += 1
                
        logger.info(f"Added {glsub_count} GLSub mappings")
        logger.info(f"Total glType lookup dictionary with {len(lookup_dict)} entries")
        return lookup_dict
        
    except Exception as e:
        logger.error(f"Error creating glType lookup dictionary: {str(e)}")
        return {}

# @api_view(['POST'])
# @permission_classes([IsAuthenticated])
# def bulk_insert_dairy_reports(request):
#     """
#     Clear Dairy_Report table and insert data from both FCY and LCY stored procedures
    
#     Expected payload:
#     {
#         "date_start": "YYYY-MM-DD",
#         "date_end": "YYYY-MM-DD", 
#         "fin_year": "2025",
#         "period_code": "",
#         "category": "TRIAL_BALANCE"
#     }
#     """
#     try:
#         # Validate request data
#         date_start = request.data.get("date_start")
#         date_end = request.data.get("date_end")
#         fin_year = request.data.get("fin_year", "2025")
#         period_code = request.data.get("period_code", "")
#         default_category = request.data.get("category", "TRIAL_BALANCE")

#         if not all([date_start, date_end]):
#             return Response({
#                 'status': 'error',
#                 'message': 'ບໍ່ມີຂໍ້ມູນວັນທີ່ເລີ່ມຕົ້ນ ແລະ ວັນທີ່ສິ້ນສຸດ (Missing required parameters: date_start and date_end)'
#             }, status=status.HTTP_400_BAD_REQUEST)

#         # Date validation
#         try:
#             start_date_obj = datetime.strptime(date_start, '%Y-%m-%d').date()
#             end_date_obj = datetime.strptime(date_end, '%Y-%m-%d').date()
            
#             if start_date_obj > end_date_obj:
#                 return Response({
#                     'status': 'error',
#                     'message': 'ວັນທີເລີ່ມຕົ້ນຕ້ອງນ້ອຍກວ່າວັນທີສິ້ນສຸດ (Start date must be before end date)'
#                 }, status=status.HTTP_400_BAD_REQUEST)
                
#         except ValueError:
#             return Response({
#                 'status': 'error',
#                 'message': 'ຮູບແບບວັນທີບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້ YYYY-MM-DD (Invalid date format, please use YYYY-MM-DD)'
#             }, status=status.HTTP_400_BAD_REQUEST)

#         logger.info(f"[BulkInsertDairyReports] Starting bulk insert operation from {date_start} to {date_end}")

#         # Statistics tracking
#         stats = {
#             'cleared_records': 0,
#             'fcy_records_fetched': 0,
#             'fcy_records_inserted': 0,
#             'fcy_records_failed': 0,
#             'lcy_records_fetched': 0,
#             'lcy_records_inserted': 0,
#             'lcy_records_failed': 0,
#             'total_inserted': 0,
#             'total_failed': 0
#         }
        
#         failed_records = []
#         created_records = []

#         # Create glType lookup dictionary for performance
#         logger.info("Creating glType lookup dictionary...")
#         gltype_lookup = get_gltype_lookup_dict()
#         logger.info(f"glType lookup created with {len(gltype_lookup)} mappings")

#         # Get related objects once
#         ccy_objects = {}
#         fin_year_obj = None
#         period_obj = None

#         try:
#             if fin_year:
#                 from .models import MTTB_Fin_Cycle  # Replace with actual import
#                 fin_year_obj = MTTB_Fin_Cycle.objects.get(fin_cycle=fin_year)
#         except Exception as e:
#             logger.warning(f"Financial year {fin_year} not found: {str(e)}")

#         try:
#             if period_code:
#                 from .models import MTTB_Per_Code  # Replace with actual import
#                 period_obj = MTTB_Per_Code.objects.get(period_code=period_code)
#         except Exception as e:
#             logger.warning(f"Period code {period_code} not found: {str(e)}")

#         with transaction.atomic():
#             # Step 1: Clear existing Dairy_Report data
#             try:
#                 from .models import Dairy_Report  # Replace with actual import
                
#                 logger.info("Clearing existing Dairy_Report data...")
#                 stats['cleared_records'] = Dairy_Report.objects.all().count()
#                 Dairy_Report.objects.all().delete()
#                 logger.info(f"Successfully cleared {stats['cleared_records']} existing records")
                
#             except Exception as e:
#                 logger.error(f"Error clearing Dairy_Report data: {str(e)}")
#                 return Response({
#                     'status': 'error',
#                     'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນເກົ່າ: {str(e)} (Error clearing existing data)'
#                 }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

#             # Step 2: Execute FCY stored procedure and insert FCY data
#             logger.info("Executing FCY stored procedure...")
#             try:
#                 with connection.cursor() as cursor:
#                     fcy_query = """
#                         EXEC dbo.Somtop_Trail_Balance_All_Currency_fcy
#                             @DateStart = %s,
#                             @DateEnd = %s
#                     """
#                     cursor.execute(fcy_query, [date_start, date_end])
#                     fcy_columns = [col[0] for col in cursor.description]
#                     fcy_results = [dict(zip(fcy_columns, row)) for row in cursor.fetchall()]

#                 stats['fcy_records_fetched'] = len(fcy_results)
#                 logger.info(f"FCY stored procedure completed. Rows fetched: {stats['fcy_records_fetched']}")

#                 # Insert FCY data
#                 for index, item in enumerate(fcy_results):
#                     try:
#                         gl_code = item.get('GL', '')
#                         currency_code = item.get('Currency', '')
                        
#                         # Get or create currency object
#                         if currency_code and currency_code not in ccy_objects:
#                             try:
#                                 from .models import MTTB_Ccy_DEFN  # Replace with actual import
#                                 ccy_objects[currency_code] = MTTB_Ccy_DEFN.objects.get(ccy_code=currency_code)
#                             except Exception:
#                                 logger.warning(f"Currency {currency_code} not found")
#                                 ccy_objects[currency_code] = None

#                         # Determine glType
#                         record_gltype = default_category
#                         if gl_code and re.search(r'\.0', str(gl_code)):
#                             record_gltype = '6'
#                         else:
#                             lookup_gltype = gltype_lookup.get(gl_code)
#                             if lookup_gltype:
#                                 record_gltype = lookup_gltype
#                             else:
#                                 direct_gltype = get_gltype_from_gl_code(gl_code)
#                                 if direct_gltype:
#                                     record_gltype = direct_gltype

#                         # Create Dairy_Report record with FCY data
#                         dairy_report = Dairy_Report(
#                             DP_ID=len(created_records) + 1,
#                             gl_code=gl_code,
#                             Desc=item.get('_Desc', ''),
#                             CCy_Code=ccy_objects.get(currency_code),
#                             Fin_year=fin_year_obj,
#                             Period_code=period_obj,
#                             StartDate=start_date_obj,
#                             EndDate=end_date_obj,
#                             Category=record_gltype,
#                             # FCY fields from stored procedure
#                             OP_DR=safe_decimal_convert(item.get('Opening_Dr_FCY', 0)),
#                             OP_CR=safe_decimal_convert(item.get('Opening_Cr_FCY', 0)),
#                             Mo_DR=safe_decimal_convert(item.get('Flow_Dr_FCY', 0)),
#                             Mo_Cr=safe_decimal_convert(item.get('Flow_Cr_FCY', 0)),
#                             C1_DR=safe_decimal_convert(item.get('Closing_Dr_FCY', 0)),
#                             C1_CR=safe_decimal_convert(item.get('Closing_Cr_FCY', 0)),
#                             # LCY fields set to 0 for FCY records
#                             OP_DR_lcy=safe_decimal_convert(0),
#                             OP_CR_lcy=safe_decimal_convert(0),
#                             Mo_DR_lcy=safe_decimal_convert(0),
#                             Mo_Cr_lcy=safe_decimal_convert(0),
#                             C1_DR_lcy=safe_decimal_convert(0),
#                             C1_CR_lcy=safe_decimal_convert(0),
#                             Maker_Id=request.user,
#                             MSegment=item.get('MSegment', '')
#                         )
                        
#                         dairy_report.full_clean()
#                         dairy_report.save()
                        
#                         stats['fcy_records_inserted'] += 1
#                         created_records.append({
#                             'type': 'FCY',
#                             'gl_code': gl_code,
#                             'currency': currency_code,
#                             'category': record_gltype
#                         })
                        
#                     except Exception as e:
#                         stats['fcy_records_failed'] += 1
#                         error_msg = f"FCY record {index} error: {str(e)}"
#                         logger.error(error_msg)
#                         failed_records.append({
#                             'type': 'FCY',
#                             'index': index,
#                             'gl_code': item.get('GL', 'Unknown'),
#                             'currency': item.get('Currency', ''),
#                             'error': error_msg
#                         })

#             except Exception as e:
#                 logger.error(f"Error executing FCY stored procedure: {str(e)}")
#                 return Response({
#                     'status': 'error',
#                     'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ FCY stored procedure: {str(e)}'
#                 }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

#             # Step 3: Execute LCY stored procedure and insert LCY data
#             logger.info("Executing LCY consolidated stored procedure...")
#             try:
#                 with connection.cursor() as cursor:
#                     lcy_query = """
#                         EXEC dbo.Somtop_Trail_Balance_All_Currency_Consolidated_lcy
#                             @DateStart = %s,
#                             @DateEnd = %s
#                     """
#                     cursor.execute(lcy_query, [date_start, date_end])
#                     lcy_columns = [col[0] for col in cursor.description]
#                     lcy_results = [dict(zip(lcy_columns, row)) for row in cursor.fetchall()]

#                 stats['lcy_records_fetched'] = len(lcy_results)
#                 logger.info(f"LCY stored procedure completed. Rows fetched: {stats['lcy_records_fetched']}")

#                 # Get LAK currency object
#                 lak_ccy_obj = None
#                 try:
#                     from .models import MTTB_Ccy_DEFN  # Replace with actual import
#                     lak_ccy_obj = MTTB_Ccy_DEFN.objects.get(ccy_code='LAK')
#                 except Exception:
#                     logger.warning("LAK currency not found")

#                 # Insert LCY data
#                 for index, item in enumerate(lcy_results):
#                     try:
#                         gl_code = item.get('GL_Code', '')
                        
#                         # Determine glType
#                         record_gltype = default_category
#                         if gl_code and re.search(r'\.0', str(gl_code)):
#                             record_gltype = '6'
#                         else:
#                             lookup_gltype = gltype_lookup.get(gl_code)
#                             if lookup_gltype:
#                                 record_gltype = lookup_gltype
#                             else:
#                                 direct_gltype = get_gltype_from_gl_code(gl_code)
#                                 if direct_gltype:
#                                     record_gltype = direct_gltype

#                         # Create Dairy_Report record with LCY data
#                         dairy_report = Dairy_Report(
#                             DP_ID=len(created_records) + 1,
#                             gl_code=gl_code,
#                             Desc=item.get('Description', ''),
#                             CCy_Code=lak_ccy_obj,
#                             Fin_year=fin_year_obj,
#                             Period_code=period_obj,
#                             StartDate=start_date_obj,
#                             EndDate=end_date_obj,
#                             Category=record_gltype,
#                             # FCY fields set to 0 for LCY records
#                             OP_DR=safe_decimal_convert(item.get('Opening_Dr_LAK', 0)),
#                             OP_CR=safe_decimal_convert(item.get('Opening_Cr_LAK', 0)),
#                             Mo_DR=safe_decimal_convert(item.get('Flow_Dr_LAK', 0)),
#                             Mo_Cr=safe_decimal_convert(item.get('Flow_Cr_LAK', 0)),
#                             C1_DR=safe_decimal_convert(item.get('Closing_Dr_LAK', 0)),
#                             C1_CR=safe_decimal_convert(item.get('Closing_Cr_LAK', 0)),
#                             # LCY fields from stored procedure
#                             OP_DR_lcy=safe_decimal_convert(0),
#                             OP_CR_lcy=safe_decimal_convert(0),
#                             Mo_DR_lcy=safe_decimal_convert(0),
#                             Mo_Cr_lcy=safe_decimal_convert(0),
#                             C1_DR_lcy=safe_decimal_convert(0),
#                             C1_CR_lcy=safe_decimal_convert(0),
#                             Maker_Id=request.user,
#                             MSegment=item.get('MSegment', '')
#                         )
                        
#                         dairy_report.full_clean()
#                         dairy_report.save()
                        
#                         stats['lcy_records_inserted'] += 1
#                         created_records.append({
#                             'type': 'LCY',
#                             'gl_code': gl_code,
#                             'currency': 'LAK',
#                             'category': record_gltype
#                         })
                        
#                     except Exception as e:
#                         stats['lcy_records_failed'] += 1
#                         error_msg = f"LCY record {index} error: {str(e)}"
#                         logger.error(error_msg)
#                         failed_records.append({
#                             'type': 'LCY',
#                             'index': index,
#                             'gl_code': item.get('GL_Code', 'Unknown'),
#                             'currency': 'LAK',
#                             'error': error_msg
#                         })

#             except Exception as e:
#                 logger.error(f"Error executing LCY stored procedure: {str(e)}")
#                 return Response({
#                     'status': 'error',
#                     'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ LCY stored procedure: {str(e)}'
#                 }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

#         # Calculate totals
#         stats['total_inserted'] = stats['fcy_records_inserted'] + stats['lcy_records_inserted']
#         stats['total_failed'] = stats['fcy_records_failed'] + stats['lcy_records_failed']

#         # Prepare response
#         response_data = {
#             'status': 'success',
#             'message': f'🎉 ການດຳເນີນງານສຳເລັດ! ລຶບຂໍ້ມູນເກົ່າ {stats["cleared_records"]} ລາຍການ, ນຳເຂົ້າຂໍ້ມູນໃໝ່ {stats["total_inserted"]} ລາຍການ (Operation completed successfully! Cleared {stats["cleared_records"]} old records, inserted {stats["total_inserted"]} new records)',
#             'date_range': f"{date_start} to {date_end}",
#             'statistics': {
#                 'cleared_records': stats['cleared_records'],
#                 'fcy_procedure': {
#                     'fetched': stats['fcy_records_fetched'],
#                     'inserted': stats['fcy_records_inserted'],
#                     'failed': stats['fcy_records_failed']
#                 },
#                 'lcy_procedure': {
#                     'fetched': stats['lcy_records_fetched'],
#                     'inserted': stats['lcy_records_inserted'],
#                     'failed': stats['lcy_records_failed']
#                 },
#                 'totals': {
#                     'inserted': stats['total_inserted'],
#                     'failed': stats['total_failed']
#                 }
#             },
#             'sample_created_records': created_records[:5] if created_records else []
#         }

#         if failed_records:
#             response_data['failed_records_sample'] = failed_records[:5]
#             response_data['message'] += f' ⚠️ {stats["total_failed"]} ລາຍການຜິດພາດ ({stats["total_failed"]} records failed)'

#         logger.info(f"Bulk insert operation completed successfully:")
#         logger.info(f"- Cleared: {stats['cleared_records']} records")
#         logger.info(f"- FCY: {stats['fcy_records_inserted']}/{stats['fcy_records_fetched']} inserted")
#         logger.info(f"- LCY: {stats['lcy_records_inserted']}/{stats['lcy_records_fetched']} inserted")
#         logger.info(f"- Total: {stats['total_inserted']} inserted, {stats['total_failed']} failed")

#         return Response(response_data, status=status.HTTP_201_CREATED)

#     except Exception as e:
#         logger.error(f"Bulk insert dairy reports error: {str(e)}")
#         return Response({
#             'status': 'error',
#             'message': f'ເກີດຂໍ້ຜິດພາດໃນການດຳເນີນງານ: {str(e)} (Error in operation)'
#         }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



from django.db import transaction, connection
from django.http import JsonResponse
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime, date
import logging
import re

logger = logging.getLogger(__name__)

# EOD Integration Function for FN007
def execute_somtop_trial_balancesheet(eod_function, user, processing_date=None):
    """
    Execute FN007: Somtop Trial Balancesheet for EOD processing.
    This function integrates with the EOD system to use the current processing date.
    """
    try:
        # Get current processing date from system or use provided date
        if not processing_date:
            processing_date = date.today()
        
        # Convert to string format if it's a date object
        if isinstance(processing_date, date):
            date_str = processing_date.strftime('%Y-%m-%d')
        else:
            date_str = str(processing_date)


        logger.info(f"[FN007] Starting Somtop Trial Balancesheet for processing date: {date_str}")
        
        # Auto-calculate period_code and fin_year from processing date
        processing_date_obj = datetime.strptime(date_str, '%Y-%m-%d').date()
        period_code = processing_date_obj.strftime('%Y%m')
        fin_year = processing_date_obj.strftime('%Y')
        
        # Create request-like object for the bulk_insert function
        class MockRequest:
            def __init__(self, user, date_str, period_code, fin_year):
                self.user = user
                self.data = {
                    'date_start': date_str,
                    'date_end': date_str,
                    'period_code': period_code,
                    'fin_year': fin_year,
                    'category': 'TRIAL_BALANCE'
                }
        
        mock_request = MockRequest(user, date_str, period_code, fin_year)
        
        # Execute the bulk insert function
        result = bulk_insert_somtop_trial_balancesheet_internal(mock_request)
        
        if result.get('status') == 'success':
            message = f"FN007 ສຳເລັດ: {result.get('statistics', {}).get('totals', {}).get('inserted', 0)} ລາຍການ"
            logger.info(f"[FN007] Completed successfully for {date_str}")
            return True, message
        else:
            error_message = result.get('message', 'Unknown error')
            logger.error(f"[FN007] Failed for {date_str}: {error_message}")
            return False, f"FN007 ຜິດພາດ: {error_message}"
            
    except Exception as e:
        logger.error(f"[FN007] Error in EOD execution: {str(e)}", exc_info=True)
        return False, f"FN007 ຂໍ້ຜິດພາດ: {str(e)}"


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def bulk_insert_somtop_trial_balancesheet(request):
    """
    API endpoint for bulk inserting Somtop Trial Balancesheet.
    This is the public API that can be called directly or through EOD processing.
    """
    result = bulk_insert_somtop_trial_balancesheet_internal(request)
    
    if result['status'] == 'success':
        return Response(result, status=status.HTTP_201_CREATED)
    else:
        return Response(result, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


def bulk_insert_somtop_trial_balancesheet_internal(request):
    """
    Internal function for bulk inserting Somtop Trial Balancesheet.
    This can be called by both the API endpoint and EOD processing.
    
    Expected payload in request.data:
    {
        "date_start": "YYYY-MM-DD",
        "date_end": "YYYY-MM-DD",
        "fin_year": "2025",
        "period_code": "202508",
        "category": "TRIAL_BALANCE"
    }
    """
    try:
        # Validate request data
        date_start = request.data.get("date_start")
        date_end = request.data.get("date_end")
        fin_year = request.data.get("fin_year", "2025")
        period_code = request.data.get("period_code", "")
        default_category = request.data.get("category", "TRIAL_BALANCE")

        if not all([date_start, date_end]):
            return {
                'status': 'error',
                'message': 'ບໍ່ມີຂໍ້ມູນວັນທີ່ເລີ່ມຕົ້ນ ແລະ ວັນທີ່ສິ້ນສຸດ (Missing required parameters: date_start and date_end)'
            }

        # Date validation
        try:
            start_date_obj = datetime.strptime(date_start, '%Y-%m-%d').date()
            end_date_obj = datetime.strptime(date_end, '%Y-%m-%d').date()
            
            if start_date_obj > end_date_obj:
                return {
                    'status': 'error',
                    'message': 'ວັນທີເລີ່ມຕົ້ນຕ້ອງນ້ອຍກວ່າວັນທີສິ້ນສຸດ (Start date must be before end date)'
                }
                
        except ValueError:
            return {
                'status': 'error',
                'message': 'ຮູບແບບວັນທີບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້ YYYY-MM-DD (Invalid date format, please use YYYY-MM-DD)'
            }

        logger.info(f"[BulkInsertSomtopTrialBalancesheet] Starting bulk insert operation from {date_start} to {date_end}")

        # Statistics tracking
        stats = {
            'cleared_records': 0,
            'fcy_records_fetched': 0,
            'fcy_records_inserted': 0,
            'fcy_records_failed': 0,
            'lcy_records_fetched': 0,
            'lcy_records_inserted': 0,
            'lcy_records_failed': 0,
            'total_inserted': 0,
            'total_failed': 0
        }
        
        failed_records = []
        created_records = []

        # Create glType lookup dictionary for performance
        logger.info("Creating glType lookup dictionary...")
        gltype_lookup = get_gltype_lookup_dict()
        logger.info(f"glType lookup created with {len(gltype_lookup)} mappings")

        # Get related objects once
        ccy_objects = {}
        fin_year_obj = None
        period_obj = None

        try:
            if fin_year:
                from .models import MTTB_Fin_Cycle  # Replace with actual import
                fin_year_obj = MTTB_Fin_Cycle.objects.get(fin_cycle=fin_year)
        except Exception as e:
            logger.warning(f"Financial year {fin_year} not found: {str(e)}")

        try:
            if period_code:
                from .models import MTTB_Per_Code  # Replace with actual import
                period_obj = MTTB_Per_Code.objects.get(period_code=period_code)
        except Exception as e:
            logger.warning(f"Period code {period_code} not found: {str(e)}")

        with transaction.atomic():
            # Step 1: Clear existing STTB_Somtop_Trial_Balancesheet data
            try:
                from .models import STTB_Somtop_Trial_Balancesheet  # Replace with actual import
                logger.info("Clearing existing STTB_Somtop_Trial_Balancesheet data...")
                stats['cleared_records'] = STTB_Somtop_Trial_Balancesheet.objects.all().count()
                STTB_Somtop_Trial_Balancesheet.objects.all().delete()
                logger.info(f"Successfully cleared {stats['cleared_records']} existing records")
                
            except Exception as e:
                logger.error(f"Error clearing STTB_Somtop_Trial_Balancesheet data: {str(e)}")
                return {
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນເກົ່າ: {str(e)} (Error clearing existing data)'
                }

            # Step 2: Execute FCY stored procedure and insert FCY data
            logger.info("Executing FCY afterEOC stored procedure...")
            try:
                with connection.cursor() as cursor:
                    fcy_query = """
                        EXEC dbo.Somtop_Trail_Balance_All_Currency_fcy_afterEOC
                            @DateStart = %s,
                            @DateEnd = %s
                    """
                    cursor.execute(fcy_query, [date_start, date_end])
                    fcy_columns = [col[0] for col in cursor.description]
                    fcy_results = [dict(zip(fcy_columns, row)) for row in cursor.fetchall()]

                stats['fcy_records_fetched'] = len(fcy_results)
                logger.info(f"FCY afterEOC stored procedure completed. Rows fetched: {stats['fcy_records_fetched']}")

                # Insert FCY data
                for index, item in enumerate(fcy_results):
                    try:
                        gl_code = item.get('GL', '')
                        currency_code = item.get('Currency', '')
                        
                        # Get or create currency object
                        if currency_code and currency_code not in ccy_objects:
                            try:
                                from .models import MTTB_Ccy_DEFN  # Replace with actual import
                                ccy_objects[currency_code] = MTTB_Ccy_DEFN.objects.get(ccy_code=currency_code)
                            except Exception:
                                logger.warning(f"Currency {currency_code} not found")
                                ccy_objects[currency_code] = None

                        # Determine glType
                        record_gltype = default_category
                        if gl_code and re.search(r'\.0', str(gl_code)):
                            record_gltype = '6'
                        else:
                            lookup_gltype = gltype_lookup.get(gl_code)
                            if lookup_gltype:
                                record_gltype = lookup_gltype
                            else:
                                direct_gltype = get_gltype_from_gl_code(gl_code)
                                if direct_gltype:
                                    record_gltype = direct_gltype

                        # Create STTB_Somtop_Trial_Balancesheet record with FCY data
                        somtop_report = STTB_Somtop_Trial_Balancesheet(
                            gl_code=gl_code,
                            Desc=item.get('_Desc', ''),
                            CCy_Code=ccy_objects.get(currency_code),
                            Fin_year=fin_year_obj,
                            Period_code=period_obj,
                            Category=record_gltype,
                            StartDate=start_date_obj,
                            EndDate=end_date_obj,
                            OP_DR=safe_decimal_convert(item.get('Opening_Dr_FCY', 0)),
                            OP_CR=safe_decimal_convert(item.get('Opening_Cr_FCY', 0)),
                            Mo_DR=safe_decimal_convert(item.get('Flow_Dr_FCY', 0)),
                            Mo_Cr=safe_decimal_convert(item.get('Flow_Cr_FCY', 0)),
                            C1_DR=safe_decimal_convert(item.get('Closing_Dr_FCY', 0)),
                            C1_CR=safe_decimal_convert(item.get('Closing_Cr_FCY', 0)),
                            OP_DR_lcy=safe_decimal_convert(0),
                            OP_CR_lcy=safe_decimal_convert(0),
                            Mo_DR_lcy=safe_decimal_convert(0),
                            Mo_Cr_lcy=safe_decimal_convert(0),
                            C1_DR_lcy=safe_decimal_convert(0),
                            C1_CR_lcy=safe_decimal_convert(0),
                            Maker_Id=request.user,
                            MSegment=item.get('MSegment', '')
                        )
                        
                        somtop_report.full_clean()
                        somtop_report.save()
                        
                        stats['fcy_records_inserted'] += 1
                        created_records.append({
                            'type': 'FCY',
                            'gl_code': gl_code,
                            'currency': currency_code,
                            'category': record_gltype
                        })
                        
                    except Exception as e:
                        stats['fcy_records_failed'] += 1
                        error_msg = f"FCY record {index} error: {str(e)}"
                        logger.error(error_msg)
                        failed_records.append({
                            'type': 'FCY',
                            'index': index,
                            'gl_code': item.get('GL', 'Unknown'),
                            'currency': item.get('Currency', ''),
                            'error': error_msg
                        })

            except Exception as e:
                logger.error(f"Error executing FCY afterEOC stored procedure: {str(e)}")
                return {
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ FCY afterEOC stored procedure: {str(e)}'
                }

            # Step 3: Execute LCY stored procedure and insert LCY data
            logger.info("Executing LCY consolidated afterEOC stored procedure...")
            try:
                with connection.cursor() as cursor:
                    lcy_query = """
                        EXEC dbo.Somtop_Trail_Balance_All_Currency_Consolidated_lcy_afterEOC
                            @DateStart = %s,
                            @DateEnd = %s
                    """
                    cursor.execute(lcy_query, [date_start, date_end])
                    lcy_columns = [col[0] for col in cursor.description]
                    lcy_results = [dict(zip(lcy_columns, row)) for row in cursor.fetchall()]

                stats['lcy_records_fetched'] = len(lcy_results)
                logger.info(f"LCY consolidated afterEOC stored procedure completed. Rows fetched: {stats['lcy_records_fetched']}")

                # Get LAK currency object
                lak_ccy_obj = None
                try:
                    from .models import MTTB_Ccy_DEFN  # Replace with actual import
                    lak_ccy_obj = MTTB_Ccy_DEFN.objects.get(ccy_code='LAK')
                except Exception:
                    logger.warning("LAK currency not found")

                # Insert LCY data
                for index, item in enumerate(lcy_results):
                    try:
                        gl_code = item.get('GL_Code', '')
                        
                        # Determine glType
                        record_gltype = default_category
                        if gl_code and re.search(r'\.0', str(gl_code)):
                            record_gltype = '6'
                        else:
                            lookup_gltype = gltype_lookup.get(gl_code)
                            if lookup_gltype:
                                record_gltype = lookup_gltype
                            else:
                                direct_gltype = get_gltype_from_gl_code(gl_code)
                                if direct_gltype:
                                    record_gltype = direct_gltype

                        # Create STTB_Somtop_Trial_Balancesheet record with LCY data
                        somtop_report = STTB_Somtop_Trial_Balancesheet(
                            gl_code=gl_code,
                            Desc=item.get('Description', ''),
                            CCy_Code=lak_ccy_obj,
                            Fin_year=fin_year_obj,
                            Period_code=period_obj,
                            Category=record_gltype,
                            StartDate=start_date_obj,
                            EndDate=end_date_obj,
                            OP_DR=safe_decimal_convert(item.get('Opening_Dr_LAK', 0)),
                            OP_CR=safe_decimal_convert(item.get('Opening_Cr_LAK', 0)),
                            Mo_DR=safe_decimal_convert(item.get('Flow_Dr_LAK', 0)),
                            Mo_Cr=safe_decimal_convert(item.get('Flow_Cr_LAK', 0)),
                            C1_DR=safe_decimal_convert(item.get('Closing_Dr_LAK', 0)),
                            C1_CR=safe_decimal_convert(item.get('Closing_Cr_LAK', 0)),
                            OP_DR_lcy=safe_decimal_convert(item.get('Opening_Dr_LAK', 0)),
                            OP_CR_lcy=safe_decimal_convert(item.get('Opening_Cr_LAK', 0)),
                            Mo_DR_lcy=safe_decimal_convert(item.get('Flow_Dr_LAK', 0)),
                            Mo_Cr_lcy=safe_decimal_convert(item.get('Flow_Cr_LAK', 0)),
                            C1_DR_lcy=safe_decimal_convert(item.get('Closing_Dr_LAK', 0)),
                            C1_CR_lcy=safe_decimal_convert(item.get('Closing_Cr_LAK', 0)),
                            Maker_Id=request.user,
                            MSegment=item.get('MSegment', '')
                        )
                        
                        somtop_report.full_clean()
                        somtop_report.save()
                        
                        stats['lcy_records_inserted'] += 1
                        created_records.append({
                            'type': 'LCY',
                            'gl_code': gl_code,
                            'currency': 'LAK',
                            'category': record_gltype
                        })
                        
                    except Exception as e:
                        stats['lcy_records_failed'] += 1
                        error_msg = f"LCY record {index} error: {str(e)}"
                        logger.error(error_msg)
                        failed_records.append({
                            'type': 'LCY',
                            'index': index,
                            'gl_code': item.get('GL_Code', 'Unknown'),
                            'currency': 'LAK',
                            'error': error_msg
                        })

            except Exception as e:
                logger.error(f"Error executing LCY consolidated afterEOC stored procedure: {str(e)}")
                return {
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ LCY consolidated afterEOC stored procedure: {str(e)}'
                }

        # Calculate totals
        stats['total_inserted'] = stats['fcy_records_inserted'] + stats['lcy_records_inserted']
        stats['total_failed'] = stats['fcy_records_failed'] + stats['lcy_records_failed']

        # Prepare response
        response_data = {
            'status': 'success',
            'message': f'🎉 ການດຳເນີນງານສຳເລັດ! ລຶບຂໍ້ມູນເກົ່າ {stats["cleared_records"]} ລາຍການ, ນຳເຂົ້າຂໍ້ມູນໃໝ່ {stats["total_inserted"]} ລາຍການ (Operation completed successfully! Cleared {stats["cleared_records"]} old records, inserted {stats["total_inserted"]} new records)',
            'date_range': f"{date_start} to {date_end}",
            'statistics': {
                'cleared_records': stats['cleared_records'],
                'fcy_procedure': {
                    'fetched': stats['fcy_records_fetched'],
                    'inserted': stats['fcy_records_inserted'],
                    'failed': stats['fcy_records_failed']
                },
                'lcy_procedure': {
                    'fetched': stats['lcy_records_fetched'],
                    'inserted': stats['lcy_records_inserted'],
                    'failed': stats['lcy_records_failed']
                },
                'totals': {
                    'inserted': stats['total_inserted'],
                    'failed': stats['total_failed']
                }
            },
            'sample_created_records': created_records[:5] if created_records else []
        }

        if failed_records:
            response_data['failed_records_sample'] = failed_records[:5]
            response_data['message'] += f' ⚠️ {stats["total_failed"]} ລາຍການຜິດພາດ ({stats["total_failed"]} records failed)'

        logger.info(f"Bulk insert Somtop Trial Balancesheet operation completed successfully:")
        logger.info(f"- Cleared: {stats['cleared_records']} records")
        logger.info(f"- FCY: {stats['fcy_records_inserted']}/{stats['fcy_records_fetched']} inserted")
        logger.info(f"- LCY: {stats['lcy_records_inserted']}/{stats['lcy_records_fetched']} inserted")
        logger.info(f"- Total: {stats['total_inserted']} inserted, {stats['total_failed']} failed")

        return response_data

    except Exception as e:
        logger.error(f"Bulk insert Somtop Trial Balancesheet error: {str(e)}")
        return {
            'status': 'error',
            'message': f'ເກີດຂໍ້ຜິດພາດໃນການດຳເນີນງານ: {str(e)} (Error in operation)'
        }
def execute_dairy_somtop_trailbalance(eod_function, user, processing_date=None):
    """
    Execute FN004: Dairy and Somtop Trail Balance for EOD processing.
    This function integrates with the EOD system to use the current processing date.
    """
    try:
        # Get current processing date from system or use provided date
        if not processing_date:
            processing_date = date.today()
            
        # Convert to string format if it's a date object
        if isinstance(processing_date, date):
            date_str = processing_date.strftime('%Y-%m-%d')
        else:
            date_str = str(processing_date)
        
        logger.info(f"[FN004] Starting Dairy Somtop Trail Balance for processing date: {date_str}")
        
        # Create request-like object for the bulk_insert function
        class MockRequest:
            def __init__(self, user, date_str):
                self.user = user
                self.data = {
                    'date_start': date_str,
                    'date_end': date_str,
                    'category': 'TRIAL_BALANCE'
                }
        
        mock_request = MockRequest(user, date_str)
        
        # Execute the bulk insert function
        result = bulk_insert_dairy_reports_internal(mock_request)
        
        if result.get('status') == 'success':
            message = f"FN004 ສຳເລັດ: {result.get('statistics', {}).get('totals', {}).get('inserted', 0)} ລາຍການ"
            logger.info(f"[FN004] Completed successfully for {date_str}")
            return True, message
        else:
            error_message = result.get('message', 'Unknown error')
            logger.error(f"[FN004] Failed for {date_str}: {error_message}")
            return False, f"FN004 ຜິດພາດ: {error_message}"
            
    except Exception as e:
        logger.error(f"[FN004] Error in EOD execution: {str(e)}", exc_info=True)
        return False, f"FN004 ຂໍ້ຜິດພາດ: {str(e)}"


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def bulk_insert_dairy_reports(request):
    """
    API endpoint for bulk inserting dairy reports.
    This is the public API that can be called directly or through EOD processing.
    """
    result = bulk_insert_dairy_reports_internal(request)
    
    if result['status'] == 'success':
        return Response(result, status=status.HTTP_201_CREATED)
    else:
        return Response(result, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


def bulk_insert_dairy_reports_internal(request):
    """
    Internal function for bulk inserting dairy reports.
    This can be called by both the API endpoint and EOD processing.
    
    Expected payload in request.data:
    {
        "date_start": "YYYY-MM-DD",
        "date_end": "YYYY-MM-DD", 
        "category": "TRIAL_BALANCE"
    }
    """
    try:
        # Validate request data
        date_start = request.data.get("date_start")
        date_end = request.data.get("date_end")
        default_category = request.data.get("category", "TRIAL_BALANCE")

        if not all([date_start, date_end]):
            return {
                'status': 'error',
                'message': 'ບໍ່ມີຂໍ້ມູນວັນທີ່ເລີ່ມຕົ້ນ ແລະ ວັນທີ່ສິ້ນສຸດ (Missing required parameters: date_start and date_end)'
            }

        # Date validation and period_code calculation
        try:
            start_date_obj = datetime.strptime(date_start, '%Y-%m-%d').date()
            end_date_obj = datetime.strptime(date_end, '%Y-%m-%d').date()
            
            if start_date_obj > end_date_obj:
                return {
                    'status': 'error',
                    'message': 'ວັນທີເລີ່ມຕົ້ນຕ້ອງນ້ອຍກວ່າວັນທີສິ້ນສຸດ (Start date must be before end date)'
                }

            # Auto-calculate period_code from date_end (YYYYMM format)
            period_code = end_date_obj.strftime('%Y%m')
            # Auto-calculate fin_year from date_end (YYYY format) 
            fin_year = end_date_obj.strftime('%Y')
            
        except ValueError:
            return {
                'status': 'error',
                'message': 'ຮູບແບບວັນທີບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້ YYYY-MM-DD (Invalid date format, please use YYYY-MM-DD)'
            }

        logger.info(f"[BulkInsertDairyReports] Starting bulk insert operation from {date_start} to {date_end}, period: {period_code}, fin_year: {fin_year}")

        # Statistics tracking
        stats = {
            'cleared_records': 0,
            'fcy_records_fetched': 0,
            'fcy_records_inserted': 0,
            'fcy_records_failed': 0,
            'lcy_records_fetched': 0,
            'lcy_records_inserted': 0,
            'lcy_records_failed': 0,
            'total_inserted': 0,
            'total_failed': 0
        }
        
        failed_records = []
        created_records = []

        # Create glType lookup dictionary for performance
        logger.info("Creating glType lookup dictionary...")
        gltype_lookup = get_gltype_lookup_dict()
        logger.info(f"glType lookup created with {len(gltype_lookup)} mappings")

        # Get related objects once
        ccy_objects = {}
        fin_year_obj = None
        period_obj = None
        
        try:
            if fin_year:
                from .models import MTTB_Fin_Cycle  # Replace with actual import
                fin_year_obj = MTTB_Fin_Cycle.objects.get(fin_cycle=fin_year)
        except Exception as e:
            logger.warning(f"Financial year {fin_year} not found: {str(e)}")

        try:
            if period_code:
                from .models import MTTB_Per_Code  # Replace with actual import
                period_obj = MTTB_Per_Code.objects.get(period_code=period_code)
        except Exception as e:
            logger.warning(f"Period code {period_code} not found: {str(e)}")

        with transaction.atomic():
            # Step 1: Clear existing Dairy_Report data
            try:
                from .models import Dairy_Report  # Replace with actual import
                logger.info("Clearing existing Dairy_Report data...")
                stats['cleared_records'] = Dairy_Report.objects.all().count()
                Dairy_Report.objects.all().delete()
                logger.info(f"Successfully cleared {stats['cleared_records']} existing records")
            except Exception as e:
                logger.error(f"Error clearing Dairy_Report data: {str(e)}")
                return {
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນເກົ່າ: {str(e)} (Error clearing existing data)'
                }

            # Step 2: Execute FCY stored procedure and insert FCY data
            logger.info("Executing FCY stored procedure...")
            try:
                with connection.cursor() as cursor:
                    fcy_query = """
                    EXEC dbo.Somtop_Trail_Balance_All_Currency_fcy @DateStart = %s, @DateEnd = %s
                    """
                    cursor.execute(fcy_query, [date_start, date_end])
                    fcy_columns = [col[0] for col in cursor.description]
                    fcy_results = [dict(zip(fcy_columns, row)) for row in cursor.fetchall()]
                    
                stats['fcy_records_fetched'] = len(fcy_results)
                logger.info(f"FCY stored procedure completed. Rows fetched: {stats['fcy_records_fetched']}")

                # Insert FCY data
                for index, item in enumerate(fcy_results):
                    try:
                        gl_code = item.get('GL', '')
                        currency_code = item.get('Currency', '')
                        
                        # Get or create currency object
                        if currency_code and currency_code not in ccy_objects:
                            try:
                                from .models import MTTB_Ccy_DEFN  # Replace with actual import
                                ccy_objects[currency_code] = MTTB_Ccy_DEFN.objects.get(ccy_code=currency_code)
                            except Exception:
                                logger.warning(f"Currency {currency_code} not found")
                                ccy_objects[currency_code] = None

                        # Determine glType
                        record_gltype = default_category
                        if gl_code and re.search(r'\.0', str(gl_code)):
                            record_gltype = '6'
                        else:
                            lookup_gltype = gltype_lookup.get(gl_code)
                            if lookup_gltype:
                                record_gltype = lookup_gltype
                            else:
                                direct_gltype = get_gltype_from_gl_code(gl_code)
                                if direct_gltype:
                                    record_gltype = direct_gltype

                        # Create Dairy_Report record with FCY data
                        dairy_report = Dairy_Report(
                            DP_ID=len(created_records) + 1,
                            gl_code=gl_code,
                            Desc=item.get('_Desc', ''),
                            CCy_Code=ccy_objects.get(currency_code),
                            Fin_year=fin_year_obj,
                            Period_code=period_obj,
                            StartDate=start_date_obj,
                            EndDate=end_date_obj,
                            Category=record_gltype,
                            # FCY fields from stored procedure
                            OP_DR=safe_decimal_convert(item.get('Opening_Dr_FCY', 0)),
                            OP_CR=safe_decimal_convert(item.get('Opening_Cr_FCY', 0)),
                            Mo_DR=safe_decimal_convert(item.get('Flow_Dr_FCY', 0)),
                            Mo_Cr=safe_decimal_convert(item.get('Flow_Cr_FCY', 0)),
                            C1_DR=safe_decimal_convert(item.get('Closing_Dr_FCY', 0)),
                            C1_CR=safe_decimal_convert(item.get('Closing_Cr_FCY', 0)),
                            # LCY fields set to 0 for FCY records
                            OP_DR_lcy=safe_decimal_convert(0),
                            OP_CR_lcy=safe_decimal_convert(0),
                            Mo_DR_lcy=safe_decimal_convert(0),
                            Mo_Cr_lcy=safe_decimal_convert(0),
                            C1_DR_lcy=safe_decimal_convert(0),
                            C1_CR_lcy=safe_decimal_convert(0),
                            Maker_Id=request.user,
                            MSegment=item.get('MSegment', '')
                        )
                        
                        dairy_report.full_clean()
                        dairy_report.save()
                        stats['fcy_records_inserted'] += 1
                        created_records.append({
                            'type': 'FCY',
                            'gl_code': gl_code,
                            'currency': currency_code,
                            'category': record_gltype
                        })
                        
                    except Exception as e:
                        stats['fcy_records_failed'] += 1
                        error_msg = f"FCY record {index} error: {str(e)}"
                        logger.error(error_msg)
                        failed_records.append({
                            'type': 'FCY',
                            'index': index,
                            'gl_code': item.get('GL', 'Unknown'),
                            'currency': item.get('Currency', ''),
                            'error': error_msg
                        })

            except Exception as e:
                logger.error(f"Error executing FCY stored procedure: {str(e)}")
                return {
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ FCY stored procedure: {str(e)}'
                }

            # Step 3: Execute LCY stored procedure and insert LCY data
            logger.info("Executing LCY consolidated stored procedure...")
            try:
                with connection.cursor() as cursor:
                    lcy_query = """
                    EXEC dbo.Somtop_Trail_Balance_All_Currency_Consolidated_lcy @DateStart = %s, @DateEnd = %s
                    """
                    cursor.execute(lcy_query, [date_start, date_end])
                    lcy_columns = [col[0] for col in cursor.description]
                    lcy_results = [dict(zip(lcy_columns, row)) for row in cursor.fetchall()]
                    
                stats['lcy_records_fetched'] = len(lcy_results)
                logger.info(f"LCY stored procedure completed. Rows fetched: {stats['lcy_records_fetched']}")

                # Get LAK currency object
                lak_ccy_obj = None
                try:
                    from .models import MTTB_Ccy_DEFN  # Replace with actual import
                    lak_ccy_obj = MTTB_Ccy_DEFN.objects.get(ccy_code='LAK')
                except Exception:
                    logger.warning("LAK currency not found")

                # Insert LCY data
                for index, item in enumerate(lcy_results):
                    try:
                        gl_code = item.get('GL_Code', '')
                        
                        # Determine glType
                        record_gltype = default_category
                        if gl_code and re.search(r'\.0', str(gl_code)):
                            record_gltype = '6'
                        else:
                            lookup_gltype = gltype_lookup.get(gl_code)
                            if lookup_gltype:
                                record_gltype = lookup_gltype
                            else:
                                direct_gltype = get_gltype_from_gl_code(gl_code)
                                if direct_gltype:
                                    record_gltype = direct_gltype

                        # Create Dairy_Report record with LCY data
                        dairy_report = Dairy_Report(
                            DP_ID=len(created_records) + 1,
                            gl_code=gl_code,
                            Desc=item.get('Description', ''),
                            CCy_Code=lak_ccy_obj,
                            Fin_year=fin_year_obj,
                            Period_code=period_obj,
                            StartDate=start_date_obj,
                            EndDate=end_date_obj,
                            Category=record_gltype,
                            # Using LCY data for main fields (assuming this is what you want)
                            OP_DR=safe_decimal_convert(item.get('Opening_Dr_LAK', 0)),
                            OP_CR=safe_decimal_convert(item.get('Opening_Cr_LAK', 0)),
                            Mo_DR=safe_decimal_convert(item.get('Flow_Dr_LAK', 0)),
                            Mo_Cr=safe_decimal_convert(item.get('Flow_Cr_LAK', 0)),
                            C1_DR=safe_decimal_convert(item.get('Closing_Dr_LAK', 0)),
                            C1_CR=safe_decimal_convert(item.get('Closing_Cr_LAK', 0)),
                            # LCY fields - you might want to use the same values or set to 0
                            OP_DR_lcy=safe_decimal_convert(item.get('Opening_Dr_LAK', 0)),
                            OP_CR_lcy=safe_decimal_convert(item.get('Opening_Cr_LAK', 0)),
                            Mo_DR_lcy=safe_decimal_convert(item.get('Flow_Dr_LAK', 0)),
                            Mo_Cr_lcy=safe_decimal_convert(item.get('Flow_Cr_LAK', 0)),
                            C1_DR_lcy=safe_decimal_convert(item.get('Closing_Dr_LAK', 0)),
                            C1_CR_lcy=safe_decimal_convert(item.get('Closing_Cr_LAK', 0)),
                            Maker_Id=request.user,
                            MSegment=item.get('MSegment', '')
                        )
                        
                        dairy_report.full_clean()
                        dairy_report.save()
                        stats['lcy_records_inserted'] += 1
                        created_records.append({
                            'type': 'LCY',
                            'gl_code': gl_code,
                            'currency': 'LAK',
                            'category': record_gltype
                        })
                        
                    except Exception as e:
                        stats['lcy_records_failed'] += 1
                        error_msg = f"LCY record {index} error: {str(e)}"
                        logger.error(error_msg)
                        failed_records.append({
                            'type': 'LCY',
                            'index': index,
                            'gl_code': item.get('GL_Code', 'Unknown'),
                            'currency': 'LAK',
                            'error': error_msg
                        })

            except Exception as e:
                logger.error(f"Error executing LCY stored procedure: {str(e)}")
                return {
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ LCY stored procedure: {str(e)}'
                }

        # Calculate totals
        stats['total_inserted'] = stats['fcy_records_inserted'] + stats['lcy_records_inserted']
        stats['total_failed'] = stats['fcy_records_failed'] + stats['lcy_records_failed']

        # Prepare response
        response_data = {
            'status': 'success',
            'message': f'🎉 ການດຳເນີນງານສຳເລັດ! ລຶບຂໍ້ມູນເກົ່າ {stats["cleared_records"]} ລາຍການ, ນຳເຂົ້າຂໍ້ມູນໃໝ່ {stats["total_inserted"]} ລາຍການ (Operation completed successfully! Cleared {stats["cleared_records"]} old records, inserted {stats["total_inserted"]} new records)',
            'date_range': f"{date_start} to {date_end}",
            'period_code': period_code,
            'fin_year': fin_year,
            'statistics': {
                'cleared_records': stats['cleared_records'],
                'fcy_procedure': {
                    'fetched': stats['fcy_records_fetched'],
                    'inserted': stats['fcy_records_inserted'],
                    'failed': stats['fcy_records_failed']
                },
                'lcy_procedure': {
                    'fetched': stats['lcy_records_fetched'],
                    'inserted': stats['lcy_records_inserted'],
                    'failed': stats['lcy_records_failed']
                },
                'totals': {
                    'inserted': stats['total_inserted'],
                    'failed': stats['total_failed']
                }
            },
            'sample_created_records': created_records[:5] if created_records else []
        }

        if failed_records:
            response_data['failed_records_sample'] = failed_records[:5]
            response_data['message'] += f' ⚠️ {stats["total_failed"]} ລາຍການຜິດພາດ ({stats["total_failed"]} records failed)'

        logger.info(f"Bulk insert operation completed successfully:")
        logger.info(f"- Cleared: {stats['cleared_records']} records")
        logger.info(f"- Period: {period_code}, Fin Year: {fin_year}")
        logger.info(f"- FCY: {stats['fcy_records_inserted']}/{stats['fcy_records_fetched']} inserted")
        logger.info(f"- LCY: {stats['lcy_records_inserted']}/{stats['lcy_records_fetched']} inserted")
        logger.info(f"- Total: {stats['total_inserted']} inserted, {stats['total_failed']} failed")

        return response_data

    except Exception as e:
        logger.error(f"Bulk insert dairy reports error: {str(e)}")
        return {
            'status': 'error',
            'message': f'ເກີດຂໍ້ຜິດພາດໃນການດຳເນີນງານ: {str(e)} (Error in operation)'
        }



from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import filters
from .models import CompanyProfileInfo
from .serializers import CompanyProfileSerializer

class CompanyProfileViewSet(viewsets.ModelViewSet):
    queryset = CompanyProfileInfo.objects.all()
    serializer_class = CompanyProfileSerializer
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['is_active', 'industry_type', 'country']
    search_fields = ['name_la', 'name_en', 'description']
    ordering_fields = ['name_la', 'created_at', 'updated_at']
    ordering = ['-created_at']

    def get_queryset(self):
        queryset = CompanyProfileInfo.objects.all()
        is_active = self.request.query_params.get('is_active', None)
        if is_active is not None:
            queryset = queryset.filter(is_active=is_active.lower() == 'true')
        return queryset
    def get_permissions(self):
        if self.request.method == 'POST':
            return [AllowAny()]
        return [IsAuthenticated()]

    @action(detail=True, methods=['patch'])
    def toggle_active(self, request, pk=None):
        company = self.get_object()
        company.is_active = not company.is_active
        company.save()
        serializer = self.get_serializer(company)
        return Response(serializer.data)

    @action(detail=False, methods=['get'])
    def active_companies(self, request):
        active_companies = self.get_queryset().filter(is_active=True)
        serializer = self.get_serializer(active_companies, many=True)
        return Response(serializer.data)

    def perform_create(self, serializer):
        serializer.save()

    def perform_update(self, serializer):
        serializer.save()


# Main Trial Balance
from django.db import connection
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

def run_trial_balance_all_currency_proc(m_segment: str, fin_year_id: str, period_code_id: str):
    """
    Execute the trial balance all currency stored procedure
    
    Args:
        m_segment (str): Market segment (LCY, FCY)
        fin_year_id (str): Financial year (e.g., 2025)
        period_code_id (str): Period code (e.g., 202508)
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            # Execute stored procedure with parameters
            sql = """
                EXEC dbo.Trial_Balance_All_Currency_afterEOC
                    @MSegment = %s,
                    @Fin_year_id = %s,
                    @Period_code_id = %s
            """
            
            cursor.execute(sql, [m_segment, fin_year_id, period_code_id])
            
            # Get column names
            columns = [col[0] for col in cursor.description]
            
            # Fetch all results and convert to list of dictionaries
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing trial balance all currency procedure: {str(e)}")
        raise

def run_trial_balance_by_currency_proc(ccy_code_id: str, m_segment: str, fin_year_id: str, period_code_id: str):
    """
    Execute the trial balance by currency stored procedure
    
    Args:
        ccy_code_id (str): Currency code (LAK, USD, THB, etc.)
        m_segment (str): Market segment (LCY, FCY)
        fin_year_id (str): Financial year (e.g., 2025)
        period_code_id (str): Period code (e.g., 202508)
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            # Use parameterized SQL to prevent SQL injection
            sql = """
                EXEC dbo.Trial_Balance_By_Currency_And_Consolidated_afterEOC
                    @CCy_Code_id = %s,
                    @MSegment = %s,
                    @Fin_year_id = %s,
                    @Period_code_id = %s
            """
            
            cursor.execute(sql, [ccy_code_id, m_segment, fin_year_id, period_code_id])
            
            # Get column names
            columns = [col[0] for col in cursor.description]
            
            # Fetch all results and convert to list of dictionaries
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing trial balance by currency procedure: {str(e)}")
        raise

def validate_currency_code(currency_code: str) -> bool:
    """
    Validate currency code format and allowed values
    
    Args:
        currency_code (str): Currency code to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    if not currency_code or not isinstance(currency_code, str):
        return False
    
    # Check length (should be 3-4 characters based on stored procedure nvarchar(4))
    if len(currency_code) < 3 or len(currency_code) > 4:
        return False
    
    # Common currency codes supported
    allowed_currencies = ['LAK', 'USD', 'THB', 'EUR', 'JPY', 'CNY', 'VND', 'KHR', 'MMK']
    
    return currency_code.upper() in allowed_currencies

def validate_market_segment(m_segment: str) -> bool:
    """
    Validate market segment
    
    Args:
        m_segment (str): Market segment to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    if not m_segment or not isinstance(m_segment, str):
        return False
    
    # Check length based on stored procedure nvarchar(4)
    if len(m_segment) > 4:
        return False
    
    allowed_segments = ['LCY', 'FCY']
    return m_segment.upper() in allowed_segments

def validate_financial_year(fin_year: str) -> bool:
    """
    Validate financial year format
    
    Args:
        fin_year (str): Financial year to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    if not fin_year or not isinstance(fin_year, str):
        return False
    
    # Check length based on stored procedure nvarchar(10)
    if len(fin_year) > 10:
        return False
    
    # Should be 4 digits and reasonable year range
    try:
        year = int(fin_year)
        return 2020 <= year <= 2050 and len(fin_year) == 4
    except ValueError:
        return False

def validate_period_code(period_code: str) -> bool:
    """
    Validate period code format (YYYYMM)
    
    Args:
        period_code (str): Period code to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    if not period_code or not isinstance(period_code, str):
        return False
    
    # Check length based on stored procedure nvarchar(10)
    if len(period_code) > 10:
        return False
    
    # Should be 6 digits (YYYYMM format)
    if len(period_code) != 6:
        return False
    
    try:
        year = int(period_code[:4])
        month = int(period_code[4:6])
        return 2020 <= year <= 2050 and 1 <= month <= 12
    except ValueError:
        return False

def validate_trial_balance_params(ccy_code_id: str, m_segment: str, fin_year_id: str, period_code_id: str) -> tuple:
    """
    Validate all trial balance parameters
    
    Returns:
        tuple: (is_valid: bool, error_message: str)
    """
    if not validate_currency_code(ccy_code_id):
        return False, "ລະຫັດສະກຸນເງິນບໍ່ຖືກຕ້ອງ (Invalid currency code)"
    
    if not validate_market_segment(m_segment):
        return False, "ປະເພດຕະຫຼາດບໍ່ຖືກຕ້ອງ (ຕ້ອງເປັນ LCY ຫຼື FCY) (Invalid market segment, must be LCY or FCY)"
    
    if not validate_financial_year(fin_year_id):
        return False, "ປີການເງິນບໍ່ຖືກຕ້ອງ (Invalid financial year)"
    
    if not validate_period_code(period_code_id):
        return False, "ລະຫັດງວດບໍ່ຖືກຕ້ອງ (ຮູບແບບ: YYYYMM) (Invalid period code format: YYYYMM)"
    
    return True, ""

def validate_required_params(m_segment: str, fin_year_id: str, period_code_id: str) -> tuple:
    """
    Validate required parameters for all currency trial balance
    
    Returns:
        tuple: (is_valid: bool, error_message: str)
    """
    if not validate_market_segment(m_segment):
        return False, "ປະເພດຕະຫຼາດບໍ່ຖືກຕ້ອງ (ຕ້ອງເປັນ LCY ຫຼື FCY) (Invalid market segment, must be LCY or FCY)"
    
    if not validate_financial_year(fin_year_id):
        return False, "ປີການເງິນບໍ່ຖືກຕ້ອງ (Invalid financial year)"
    
    if not validate_period_code(period_code_id):
        return False, "ລະຫັດງວດບໍ່ຖືກຕ້ອງ (ຮູບແບບ: YYYYMM) (Invalid period code format: YYYYMM)"
    
    return True, ""

@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def main_trial_balance_all_currency_view(request):
    """
    API endpoint for main trial balance all currencies (GL codes <= 5 digits)
    
    Required parameters:
    - m_segment: Market segment (LCY, FCY)
    - fin_year_id: Financial year (e.g., 2025)
    - period_code_id: Period code (e.g., 202508)
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "count": number_of_records,
        "data": [trial_balance_records],
        "parameters": {parameters_used}
    }
    """
    try:
        # Get parameters from request
        if request.method == 'GET':
            m_segment = request.GET.get('m_segment', '').strip().upper()
            fin_year_id = request.GET.get('fin_year_id', '').strip()
            period_code_id = request.GET.get('period_code_id', '').strip()
        else:  # POST
            m_segment = request.data.get('m_segment', '').strip().upper()
            fin_year_id = request.data.get('fin_year_id', '').strip()
            period_code_id = request.data.get('period_code_id', '').strip()
        
        # Check for missing required parameters
        missing_params = []
        if not m_segment:
            missing_params.append('m_segment')
        if not fin_year_id:
            missing_params.append('fin_year_id')
        if not period_code_id:
            missing_params.append('period_code_id')
        
        if missing_params:
            return Response({
                "status": "error",
                "message": f"ຂາດພາລາມິເຕີທີ່ຈຳເປັນ: {', '.join(missing_params)} (Missing required parameters: {', '.join(missing_params)})",
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Validate parameters
        is_valid, error_message = validate_required_params(m_segment, fin_year_id, period_code_id)
        if not is_valid:
            return Response({
                "status": "error",
                "message": error_message,
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        logger.info(f"[MainTrialBalance-AllCurrency] Executing procedure with params: "
                   f"Segment={m_segment}, Year={fin_year_id}, Period={period_code_id}")
        
        # Execute stored procedure
        result = run_trial_balance_all_currency_proc(m_segment, fin_year_id, period_code_id)
        
        logger.info(f"[MainTrialBalance-AllCurrency] Procedure completed successfully. Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນ Trial Balance ທຸກສະກຸນເງິນສຳເລັດ (Main trial balance for all currencies retrieved successfully)",
            "count": len(result),
            "data": result,
            "parameters": {
                "m_segment": m_segment,
                "fin_year_id": fin_year_id,
                "period_code_id": period_code_id
            }
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[MainTrialBalance-AllCurrency] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນ Trial Balance (Internal server error occurred while retrieving trial balance data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def main_trial_balance_by_currency_view(request):
    """
    API endpoint for main trial balance by specific currency
    
    Required parameters:
    - currency: Currency code (LAK, USD, THB, etc.)
    - m_segment: Market segment (LCY, FCY)
    - fin_year_id: Financial year (e.g., 2025)
    - period_code_id: Period code (e.g., 202508)
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "currency": "currency_code",
        "count": number_of_records,
        "data": [trial_balance_records],
        "parameters": {parameters_used}
    }
    """
    try:
        # Get parameters from request
        if request.method == 'GET':
            currency = request.GET.get('currency', '').strip().upper()
            m_segment = request.GET.get('m_segment', '').strip().upper()
            fin_year_id = request.GET.get('fin_year_id', '').strip()
            period_code_id = request.GET.get('period_code_id', '').strip()
        else:  # POST
            currency = request.data.get('currency', '').strip().upper()
            m_segment = request.data.get('m_segment', '').strip().upper()
            fin_year_id = request.data.get('fin_year_id', '').strip()
            period_code_id = request.data.get('period_code_id', '').strip()
        
        # Check for missing required parameters
        missing_params = []
        if not currency:
            missing_params.append('currency')
        if not m_segment:
            missing_params.append('m_segment')
        if not fin_year_id:
            missing_params.append('fin_year_id')
        if not period_code_id:
            missing_params.append('period_code_id')
        
        if missing_params:
            return Response({
                "status": "error",
                "message": f"ຂາດພາລາມິເຕີທີ່ຈຳເປັນ: {', '.join(missing_params)} (Missing required parameters: {', '.join(missing_params)})",
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Validate parameters
        is_valid, error_message = validate_trial_balance_params(currency, m_segment, fin_year_id, period_code_id)
        if not is_valid:
            return Response({
                "status": "error",
                "message": error_message,
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        logger.info(f"[MainTrialBalance-ByCurrency] Executing procedure with params: "
                   f"Currency={currency}, Segment={m_segment}, Year={fin_year_id}, Period={period_code_id}")
        
        # Execute stored procedure
        result = run_trial_balance_by_currency_proc(currency, m_segment, fin_year_id, period_code_id)
        
        logger.info(f"[MainTrialBalance-ByCurrency] Procedure completed successfully. Currency: {currency}, Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນ Trial Balance ສຳລັບ {currency} ສຳເລັດ (Main trial balance data for {currency} retrieved successfully)",
            "currency": currency,
            "count": len(result),
            "data": result,
            "parameters": {
                "currency": currency,
                "m_segment": m_segment,
                "fin_year_id": fin_year_id,
                "period_code_id": period_code_id
            }
        }, status=status.HTTP_200_OK)
          
    except Exception as e:
        logger.exception(f"[MainTrialBalance-ByCurrency] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນ Trial Balance (Internal server error occurred while retrieving trial balance data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def trial_balance_by_currency_view(request):
    """
    API endpoint for trial balance by specific currency
    
    Required parameters:
    - ccy_code_id: Currency code (LAK, USD, THB, etc.)
    - m_segment: Market segment (LCY, FCY)
    - fin_year_id: Financial year (e.g., 2025)
    - period_code_id: Period code (e.g., 202508)
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "count": number_of_records,
        "data": [trial_balance_records],
        "parameters": {parameters_used}
    }
    """
    try:
        # Get parameters from request
        if request.method == 'GET':
            ccy_code_id = request.GET.get('ccy_code_id', '').strip().upper()
            m_segment = request.GET.get('m_segment', '').strip().upper()
            fin_year_id = request.GET.get('fin_year_id', '').strip()
            period_code_id = request.GET.get('period_code_id', '').strip()
        else:  # POST
            ccy_code_id = request.data.get('ccy_code_id', '').strip().upper()
            m_segment = request.data.get('m_segment', '').strip().upper()
            fin_year_id = request.data.get('fin_year_id', '').strip()
            period_code_id = request.data.get('period_code_id', '').strip()
        
        # Check for missing required parameters
        missing_params = []
        if not ccy_code_id:
            missing_params.append('ccy_code_id')
        if not m_segment:
            missing_params.append('m_segment')
        if not fin_year_id:
            missing_params.append('fin_year_id')
        if not period_code_id:
            missing_params.append('period_code_id')
        
        if missing_params:
            return Response({
                "status": "error",
                "message": f"ຂາດພາລາມິເຕີທີ່ຈຳເປັນ: {', '.join(missing_params)} (Missing required parameters: {', '.join(missing_params)})",
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Validate parameters
        is_valid, error_message = validate_trial_balance_params(ccy_code_id, m_segment, fin_year_id, period_code_id)
        if not is_valid:
            return Response({
                "status": "error",
                "message": error_message,
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        logger.info(f"[TrialBalance-ByCurrency] Executing procedure with params: "
                   f"CCy={ccy_code_id}, Segment={m_segment}, Year={fin_year_id}, Period={period_code_id}")
        
        # Execute stored procedure
        result = run_trial_balance_by_currency_proc(ccy_code_id, m_segment, fin_year_id, period_code_id)
        
        logger.info(f"[TrialBalance-ByCurrency] Procedure completed successfully. Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນ Trial Balance ສະກຸນເງິນ {ccy_code_id} ສຳເລັດ (Trial balance for {ccy_code_id} retrieved successfully)",
            "count": len(result),
            "data": result,
            "parameters": {
                "ccy_code_id": ccy_code_id,
                "m_segment": m_segment,
                "fin_year_id": fin_year_id,
                "period_code_id": period_code_id
            }
        }, status=status.HTTP_200_OK)
          
    except Exception as e:
        logger.exception(f"[TrialBalance-ByCurrency] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນ Trial Balance (Internal server error occurred while retrieving trial balance data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        
# Store Procedure IncomeStatement ------> 
from django.db import connection
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

def run_income_statement_acc_proc(segment: str, currency: str, period_code_id: str):
    """
    Execute the income statement ACC stored procedure
    
    Args:
        segment (str): FCY or LCY
        currency (str): Currency code (LAK, USD, THB, etc.)
        period_code_id (str): Period code ID
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            # Use parameterized SQL to prevent SQL injection
            sql = """
                EXEC dbo.incomestatement_acc_By_Currency_And_Consolidated
                    @segment = %s,
                    @currency = %s,
                    @period_code_id = %s
            """

            cursor.execute(sql, [segment, currency, period_code_id])

            # Get column names
            columns = [col[0] for col in cursor.description]
            
            # Fetch all results and convert to list of dictionaries
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing income statement ACC procedure: {str(e)}")
        raise

def run_income_statement_mfi_proc(segment: str, currency: str, period_code_id: str):
    """
    Execute the income statement MFI stored procedure
    
    Args:
        segment (str): FCY or LCY
        currency (str): Currency code (LAK, USD, THB, etc.)
        period_code_id (str): Period code ID
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            # Use parameterized SQL to prevent SQL injection
            sql = """
                EXEC dbo.incomestatement_mfi_By_Currency_And_Consolidated
                    @segment = %s,
                    @currency = %s,
                    @period_code_id = %s
            """

            cursor.execute(sql, [segment, currency, period_code_id])

            # Get column names
            columns = [col[0] for col in cursor.description]
            
            # Fetch all results and convert to list of dictionaries
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing income statement MFI procedure: {str(e)}")
        raise

def validate_segment(segment: str) -> bool:
    """
    Validate segment parameter
    
    Args:
        segment (str): Segment value to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    if not segment or not isinstance(segment, str):
        return False
    
    valid_segments = ['FCY', 'LCY']
    return segment.upper() in valid_segments

def validate_currency_code(currency_code: str) -> bool:
    """
    Validate currency code format and allowed values
    
    Args:
        currency_code (str): Currency code to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    if not currency_code or not isinstance(currency_code, str):
        return False
    
    # Check length (should be 3-5 characters)
    if len(currency_code) < 3 or len(currency_code) > 5:
        return False
    
    # Common currency codes supported
    allowed_currencies = ['LAK', 'USD', 'THB', 'EUR', 'JPY', 'CNY', 'VND']
    
    return currency_code.upper() in allowed_currencies

def validate_period_code(period_code: str):
    """
    Validate period code format (YYYYMM)
    Args:
        period_code (str): Period code to validate
    Returns:
        bool: True if valid, False otherwise
    """
    if not period_code or not isinstance(period_code, str):
        return False
    # Check length based on stored procedure nvarchar(10)
    if len(period_code) > 6:
        return False
    # Check format (YYYYMM)
    if not re.match(r'^\d{6}$', period_code):
        return False
    return True

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def income_statement_acc_view(request):
    """
    API endpoint for income statement ACC data
    
    Expected payload:
    {
        "segment": "FCY|LCY",
        "currency": "LAK|USD|THB|etc"
        "period_code_id": "YYYYMM"
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "segment": "segment_type",
        "currency": "currency_code",
        "type": "ACC",
        "count": number_of_records,
        "data": [income_statement_records]
    }
    """
    # Extract parameters from request
    segment = request.data.get("segment")
    currency = request.data.get("currency")
    period_code_id = request.data.get("period_code_id")
    
    # Validate required parameters
    if not segment or not currency or not period_code_id:
        return Response({
            "status": "error",
            "message": "ບໍ່ມີຂໍ້ມູນທີ່ຈຳເປັນ: segment ແລະ currency ແລະ period_code_id ແມ່ນຕ້ອງການ (Missing required parameters: segment and currency and period_code_id are required)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Convert to uppercase for consistency
    segment = segment.upper()
    currency = currency.upper()
    
    # Validate segment
    if not validate_segment(segment):
        return Response({
            "status": "error",
            "message": "ຄ່າ segment ບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້: FCY ຫຼື LCY (Invalid segment. Supported values: FCY, LCY)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate currency code
    if not validate_currency_code(currency):
        return Response({
            "status": "error",
            "message": "ລະຫັດສະກຸນເງິນບໍ່ຖືກຕ້ອງ ສະກຸນເງິນທີ່ຮອງຮັບ: LAK, USD, THB, EUR, JPY, CNY, VND (Invalid currency code. Supported currencies: LAK, USD, THB, EUR, JPY, CNY, VND)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[IncomeStatement-ACC] Executing procedure for segment={segment}, currency={currency}, period_code_id={period_code_id}")
        
        # Execute stored procedure
        result = run_income_statement_acc_proc(segment, currency, period_code_id)

        logger.info(f"[IncomeStatement-ACC] Procedure completed successfully. Segment: {segment}, Currency: {currency}, Period Code ID: {period_code_id}, Records: {len(result)}")

        # Determine display message based on segment
        display_currency = f"{currency} (FCY)" if segment == 'FCY' else f"LAK (ທຽບເທົ່າ)"
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ ACC ສຳລັບ {display_currency} ສຳເລັດ (Income statement ACC data retrieved successfully - {display_currency})",
            "segment": segment,
            "currency": currency,
            "period_code_id": period_code_id,
            "type": "ACC",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[IncomeStatement-ACC] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ ACC (Internal server error occurred while retrieving income statement ACC data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def income_statement_mfi_view(request):
    """
    API endpoint for income statement MFI data
    
    Expected payload:
    {
        "segment": "FCY|LCY",
        "currency": "LAK|USD|THB|etc"
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "segment": "segment_type",
        "currency": "currency_code",
        "type": "MFI",
        "count": number_of_records,
        "data": [income_statement_records]
    }
    """
    # Extract parameters from request
    segment = request.data.get("segment")
    currency = request.data.get("currency")
    period_code_id = request.data.get("period_code_id")
    
    # Validate required parameters
    if not segment or not currency or not period_code_id:
        return Response({
            "status": "error",
            "message": "ບໍ່ມີຂໍ້ມູນທີ່ຈຳເປັນ: segment ແລະ currency ແລະ period_code_id ແມ່ນຕ້ອງການ (Missing required parameters: segment and currency and period_code_id are required)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Convert to uppercase for consistency
    segment = segment.upper()
    currency = currency.upper()
    
    # Validate segment
    if not validate_segment(segment):
        return Response({
            "status": "error",
            "message": "ຄ່າ segment ບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້: FCY ຫຼື LCY (Invalid segment. Supported values: FCY, LCY)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate currency code
    if not validate_currency_code(currency):
        return Response({
            "status": "error",
            "message": "ລະຫັດສະກຸນເງິນບໍ່ຖືກຕ້ອງ ສະກຸນເງິນທີ່ຮອງຮັບ: LAK, USD, THB, EUR, JPY, CNY, VND (Invalid currency code. Supported currencies: LAK, USD, THB, EUR, JPY, CNY, VND)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[IncomeStatement-MFI] Executing procedure for segment={segment}, currency={currency}, period_code_id={period_code_id}")
        
        # Execute stored procedure
        result = run_income_statement_mfi_proc(segment, currency, period_code_id)

        logger.info(f"[IncomeStatement-MFI] Procedure completed successfully. Segment: {segment}, Currency: {currency}, Period Code ID: {period_code_id}, Records: {len(result)}")
        
        # Determine display message based on segment
        display_currency = f"{currency} (FCY)" if segment == 'FCY' else f"LAK (ທຽບເທົ່າ)"
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ MFI ສຳລັບ {display_currency} ສຳເລັດ (Income statement MFI data retrieved successfully - {display_currency})",
            "segment": segment,
            "currency": currency,
            "period_code_id": period_code_id,
            "type": "MFI",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[IncomeStatement-MFI] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ MFI (Internal server error occurred while retrieving income statement MFI data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def income_statement_acc_get_view(request):
    """
    GET endpoint for income statement ACC data (using query parameters)
    
    Query parameters:
    - segment: FCY or LCY
    - currency: Currency code (LAK, USD, THB, etc.)
    """
    # Extract parameters from query params
    segment = request.query_params.get("segment")
    currency = request.query_params.get("currency")
    
    # Validate required parameters
    if not segment or not currency:
        return Response({
            "status": "error",
            "message": "ບໍ່ມີ query parameters ທີ່ຈຳເປັນ: segment ແລະ currency (Missing required query parameters: segment and currency)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Convert to uppercase for consistency
    segment = segment.upper()
    currency = currency.upper()
    
    # Validate parameters
    if not validate_segment(segment) or not validate_currency_code(currency):
        return Response({
            "status": "error",
            "message": "ຄ່າ parameters ບໍ່ຖືກຕ້ອງ (Invalid parameters. Supported: segment=FCY/LCY, currency=LAK/USD/THB/etc)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[IncomeStatement-ACC-GET] Executing procedure for segment={segment}, currency={currency}")
        
        # Execute stored procedure
        result = run_income_statement_acc_proc(segment, currency)
        
        logger.info(f"[IncomeStatement-ACC-GET] Procedure completed successfully. Records: {len(result)}")
        
        display_currency = f"{currency} (FCY)" if segment == 'FCY' else f"LAK (ທຽບເທົ່າ)"
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ ACC ສຳລັບ {display_currency} ສຳເລັດ",
            "segment": segment,
            "currency": currency,
            "type": "ACC",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[IncomeStatement-ACC-GET] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ ACC",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def income_statement_mfi_get_view(request):
    """
    GET endpoint for income statement MFI data (using query parameters)
    
    Query parameters:
    - segment: FCY or LCY
    - currency: Currency code (LAK, USD, THB, etc.)
    """
    # Extract parameters from query params
    segment = request.query_params.get("segment")
    currency = request.query_params.get("currency")
    
    # Validate required parameters
    if not segment or not currency:
        return Response({
            "status": "error",
            "message": "ບໍ່ມີ query parameters ທີ່ຈຳເປັນ: segment ແລະ currency (Missing required query parameters: segment and currency)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Convert to uppercase for consistency
    segment = segment.upper()
    currency = currency.upper()
    
    # Validate parameters
    if not validate_segment(segment) or not validate_currency_code(currency):
        return Response({
            "status": "error",
            "message": "ຄ່າ parameters ບໍ່ຖືກຕ້ອງ (Invalid parameters. Supported: segment=FCY/LCY, currency=LAK/USD/THB/etc)",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[IncomeStatement-MFI-GET] Executing procedure for segment={segment}, currency={currency}")
        
        # Execute stored procedure
        result = run_income_statement_mfi_proc(segment, currency)
        
        logger.info(f"[IncomeStatement-MFI-GET] Procedure completed successfully. Records: {len(result)}")
        
        display_currency = f"{currency} (FCY)" if segment == 'FCY' else f"LAK (ທຽບເທົ່າ)"
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ MFI ສຳລັບ {display_currency} ສຳເລັດ",
            "segment": segment,
            "currency": currency,
            "type": "MFI",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[IncomeStatement-MFI-GET] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ MFI",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# Optional: ViewSet approach for more advanced functionality
from rest_framework import viewsets
from rest_framework.decorators import action

class IncomeStatementViewSet(viewsets.ViewSet):
    """
    ViewSet for Income Statement operations
    """
    permission_classes = [IsAuthenticated]
    
    @action(detail=False, methods=['post', 'get'])
    def acc_data(self, request):
        """
        Get income statement ACC data
        
        POST: Use request body
        GET: Use query parameters
        """
        if request.method == 'POST':
            return income_statement_acc_view(request)
        else:
            return income_statement_acc_get_view(request)
    
    @action(detail=False, methods=['post', 'get'])
    def mfi_data(self, request):
        """
        Get income statement MFI data
        
        POST: Use request body
        GET: Use query parameters
        """
        if request.method == 'POST':
            return income_statement_mfi_view(request)
        else:
            return income_statement_mfi_get_view(request)
    
    @action(detail=False, methods=['get'])
    def supported_options(self, request):
        """
        Get list of supported segments and currencies for income statement
        """
        segments = [
            {
                'value': 'FCY',
                'title': 'Foreign Currency (FCY)',
                'description': 'ສະກຸນເງິນຕ່າງປະເທດ',
                'currencies': ['USD', 'THB', 'EUR', 'JPY', 'CNY', 'VND']
            },
            {
                'value': 'LCY',
                'title': 'Local Currency Equivalent (LCY)', 
                'description': 'ທຽບເທົ່າກີບລາວ',
                'currencies': ['LAK']
            }
        ]
        
        currencies = {
            'LAK': 'ກີບລາວ (Lao Kip)',
            'USD': 'ໂດລາສະຫະລັດ (US Dollar)', 
            'THB': 'ບາດໄທ (Thai Baht)',
            'EUR': 'ເອີໂຣ (Euro)',
            'JPY': 'ເຢນຍີ່ປຸ່ນ (Japanese Yen)',
            'CNY': 'ຫຍວນຈີນ (Chinese Yuan)',
            'VND': 'ດົງຫວຽດນາມ (Vietnamese Dong)'
        }
        
        return Response({
            "status": "success",
            "message": "ດຶງຂໍ້ມູນ segments ແລະສະກຸນເງິນທີ່ຮອງຮັບສຳເລັດ",
            "count": len(segments),
            "data": {
                "segments": segments,
                "currencies": currencies,
                "types": ["ACC", "MFI"]
            }
        }, status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def compare_acc_mfi(self, request):
        """
        Compare ACC and MFI income statement data for the same segment and currency
        
        Expected payload:
        {
            "segment": "FCY|LCY",
            "currency": "USD|THB|etc"
        }
        """
        segment = request.data.get("segment")
        currency = request.data.get("currency")
        
        if not segment or not currency:
            return Response({
                "status": "error",
                "message": "ບໍ່ມີຂໍ້ມູນທີ່ຈຳເປັນ (Missing required parameters: segment and currency)",
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        segment = segment.upper()
        currency = currency.upper()
        
        if not validate_segment(segment) or not validate_currency_code(currency):
            return Response({
                "status": "error",
                "message": "ຄ່າ parameters ບໍ່ຖືກຕ້ອງ (Invalid parameters)",
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Get both ACC and MFI data
            acc_result = run_income_statement_acc_proc(segment, currency)
            mfi_result = run_income_statement_mfi_proc(segment, currency)
            
            display_currency = f"{currency} (FCY)" if segment == 'FCY' else f"LAK (ທຽບເທົ່າ)"
            
            return Response({
                "status": "success",
                "message": f"ສົມທຽບຂໍ້ມູນງົບກຳໄລຂາດທຸນ ACC ແລະ MFI ສຳລັບ {display_currency} ສຳເລັດ",
                "segment": segment,
                "currency": currency,
                "display_currency": display_currency,
                "data": {
                    "acc": {
                        "count": len(acc_result),
                        "data": acc_result
                    },
                    "mfi": {
                        "count": len(mfi_result),
                        "data": mfi_result
                    }
                }
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.exception(f"[IncomeStatement-Compare] Error comparing ACC and MFI: {str(e)}")
            
            return Response({
                "status": "error",
                "message": "ເກີດຂໍ້ຜິດພາດໃນການສົມທຽບຂໍ້ມູນ ACC ແລະ MFI",
                "data": None
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from .models import FA_Asset_Audit
from .serializers import FAAssetAuditSerializer

class FAAssetAuditViewSet(viewsets.ModelViewSet):
    serializer_class = FAAssetAuditSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        queryset = FA_Asset_Audit.objects.select_related(
            'asset_list_id', 'department_id'
        ).all().order_by('-audit_id')

        # Optional filtering by asset_list_id or department_id
        asset_list_id = self.request.query_params.get('asset_list_id')
        department_id = self.request.query_params.get('department_id')

        if asset_list_id:
            queryset = queryset.filter(asset_list_id=asset_list_id)

        if department_id:
            queryset = queryset.filter(department_id=department_id)

        return queryset

    def perform_create(self, serializer):
        user = self.request.user
        serializer.save(
            Maker_Id=user,
            Maker_DT_Stamp=timezone.now()
        )

    def perform_update(self, serializer):
        user = self.request.user
        serializer.save(
            Checker_Id=user,
            Checker_DT_Stamp=timezone.now()
        )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_open(self, request, pk=None):
        """Set Record_Status = 'O' """
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)  
        if obj.Record_Status == 'O':
            return Response({'detail': 'Already open.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        
        obj.Record_Status = 'O'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Open.', 'entry': serializer.data})

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def set_close(self, request, pk=None):
        """Set Record_Status = 'C' (Close)"""
        obj = self.get_object()
        user_obj = MTTB_Users.objects.get(user_id=request.user.user_id)
        if obj.Record_Status == 'C':
            return Response({'detail': 'Already closed.'}, status=status.HTTP_406_NOT_ACCEPTABLE)
        obj.Record_Status = 'C'
        obj.Checker_Id = user_obj
        obj.Checker_DT_Stamp = timezone.now()
        obj.save()
        serializer = self.get_serializer(obj)
        return Response({'message': 'Set to Close.', 'entry': serializer.data})



# Get the End Validation
# from datetime import datetime, timedelta, time
# from django.utils import timezone
# from django.db import transaction
# import pytz
# import logging
# from .models import MTTB_LCL_Holiday, STTB_Dates, MTTB_EOC_MAINTAIN, MTTB_DATA_Entry, ACTB_DAIRY_LOG, DETB_JRNL_LOG, DETB_JRNL_LOG_MASTER
# from rest_framework.decorators import api_view, permission_classes
# from rest_framework.permissions import IsAuthenticated
# from rest_framework.response import Response
# from rest_framework import status

# # Set up logging
# logger = logging.getLogger(__name__)

# @api_view(['POST'])
# @permission_classes([IsAuthenticated])
# def end_of_day_journal_view(request):
#     """
#     API endpoint for End of Day (EOD) journal processing with transaction support.
#     Supports both normal and back-date EOD processing.
#     """
#     try:
#         tz = pytz.timezone('Asia/Bangkok')
#         target_date = request.data.get('target_date')
#         eod_id = request.data.get('eod_id')
        
#         # Determine mode
#         if target_date and eod_id:
#             # Back-date mode
#             if isinstance(target_date, str):
#                 processing_date = datetime.strptime(target_date, '%Y-%m-%d').date()
#             else:
#                 processing_date = target_date
#             is_back_date = True
#             logger.info(f"Starting BACK-DATE EOD process for date: {processing_date}, EOD ID: {eod_id}, User: {request.user}")
#         else:
#             # Normal mode
#             value_date = request.data.get('value_date')
#             if not value_date:
#                 processing_date = timezone.now().astimezone(tz).date()
#             elif isinstance(value_date, str):
#                 processing_date = datetime.strptime(value_date, '%Y-%m-%d').date()
#             else:
#                 processing_date = value_date
#             is_back_date = False
#             eod_id = None
#             logger.info(f"Starting NORMAL EOD process for date: {processing_date}, User: {request.user}")
        
#         with transaction.atomic():
#             # Step 1: Validate EOD requirements
#             if is_back_date:
#                 validation_success, validation_message = validate_backdate_eod_requirements(processing_date, eod_id)
#             else:
#                 validation_success, validation_message = validate_normal_eod_requirements(processing_date)
            
#             if not validation_success:
#                 logger.error(f"EOD validation failed: {validation_message}")
#                 raise Exception(validation_message)
            
#             # Step 2: Validate all journals are approved
#             journals_approved, journal_message = validate_journal_approvals(processing_date)
#             if not journals_approved:
#                 logger.error(f"Journal validation failed: {journal_message}")
#                 raise Exception(journal_message)
            
#             # Step 3: Execute EOD functions
#             eod_success, eod_message = execute_eod_process(request.user, processing_date, is_back_date)
#             if not eod_success:
#                 logger.error(f"EOD process failed: {eod_message}")
#                 raise Exception(eod_message)
            
#             # Step 4: Clear EOD journal
#             clear_success, clear_message = clear_eod_journal_with_transaction(processing_date)
#             if not clear_success:
#                 logger.error(f"EOD journal clear failed: {clear_message}")
#                 raise Exception(clear_message)
            
#             # Step 5: Complete EOD and create next working day
#             if is_back_date:
#                 complete_success, complete_message = complete_backdate_eod_and_create_next(eod_id, request.user, processing_date)
#             else:
#                 complete_success, complete_message = complete_normal_eod_and_create_next(request.user, processing_date)
            
#             if not complete_success:
#                 logger.error(f"EOD completion failed: {complete_message}")
#                 raise Exception(complete_message)
            
#             # All steps successful
#             mode_text = "back-date" if is_back_date else "normal"
#             final_message = f"ການປະມວນຜົນ EOD {mode_text} ສຳເລັດແລ້ວ ສຳລັບວັນທີ {processing_date}"
#             logger.info(f"{mode_text.upper()} EOD process successful for {processing_date}")

#             return Response({
#                 "message": final_message,
#                 "success": True,
#                 "is_back_date": is_back_date,
#                 "processing_date": processing_date.isoformat(),
#                 "details": {
#                     "validation": validation_message,
#                     "journal_validation": journal_message,
#                     "eod_process": eod_message,
#                     "clear_journal": clear_message,
#                     "completion": complete_message
#                 }
#             }, status=status.HTTP_201_CREATED)

#     except Exception as e:
#         logger.error(f"EOD process failed for {processing_date if 'processing_date' in locals() else 'unknown date'}: {str(e)}")
#         return Response({
#             "error": f"ການປະມວນຜົນ EOD ລົ້ມເຫລວ: {str(e)}",
#             "success": False
#         }, status=status.HTTP_400_BAD_REQUEST)

# def validate_normal_eod_requirements(processing_date):
#     """
#     Validates if normal EOD can be performed.
#     """
#     try:
#         tz = pytz.timezone('Asia/Bangkok')
#         year_str = str(processing_date.year)
#         month_str = str(processing_date.month).zfill(2)
        
#         # Check MTTB_DATA_Entry for bypass settings
#         data_entry = MTTB_DATA_Entry.objects.filter().first()
#         mod_no_enabled = data_entry and data_entry.MOD_NO == 'Y'
        
#         if not mod_no_enabled:
#             # Check if processing_date is a working day
#             try:
#                 holiday_record = MTTB_LCL_Holiday.objects.get(HYear=year_str, HMonth=month_str)
#                 holiday_list = holiday_record.Holiday_List
#                 if len(holiday_list) != 31:
#                     return False, "Invalid Holiday_List length. Must be 31 characters."
#                 day_index = processing_date.day - 1
#                 if holiday_list[day_index] != 'W':
#                     return False, f"{processing_date} is not a working day."
#             except MTTB_LCL_Holiday.DoesNotExist:
#                 return False, f"No holiday record for {year_str}-{month_str}."
        
#         # Check the latest STTB_Dates row
#         latest_eod = STTB_Dates.objects.latest('date_id')
#         expected_start_date = latest_eod.Start_Date.astimezone(tz).date()
#         if expected_start_date != processing_date:
#             return False, f"Processing date ({processing_date}) does not match expected Start_Date ({expected_start_date})."
        
#         if latest_eod.eod_time == 'Y':
#             return False, f"EOD already completed for {processing_date}."
        
#         return True, f"Normal EOD validation passed for {processing_date}"

#     except STTB_Dates.DoesNotExist:
#         return False, "No records found in STTB_Dates."
#     except Exception as e:
#         return False, f"Error in normal EOD validation: {str(e)}"

# def validate_journal_approvals(processing_date):
#     """
#     Validate that all journals for the processing date are approved.
#     """
#     try:
#         unapproved_journals = DETB_JRNL_LOG.objects.filter(
#             Value_date=processing_date,
#             Auth_Status__in=['U', 'P']
#         ).count()

#         if unapproved_journals > 0:
#             return False, f"Found {unapproved_journals} unapproved journals for {processing_date}"

#         return True, f"All journals for {processing_date} are approved"

#     except Exception as e:
#         return False, f"Error validating journal approvals: {str(e)}"

# def execute_eod_process(user, processing_date, is_back_date=False):
#     """
#     Execute all EOD functions in sequence for back-date processing.
#     """
#     try:
#         with transaction.atomic():
#             eod_functions = MTTB_EOC_MAINTAIN.objects.filter(
#                 eoc_type='EOD',
#                 Auth_Status='A',
#                 Record_Status='O'
#             ).select_related('function_id').order_by('eoc_seq_no')

#             if not eod_functions:
#                 return False, "No active EOD functions found"

#             total_executed = 0
#             execution_results = []

#             for eod_function in eod_functions:
#                 func_success, func_message = execute_eod_function(eod_function, user, processing_date)
#                 if not func_success:
#                     return False, f"Function {eod_function.function_id.description_la} failed: {func_message}"
#                 total_executed += 1
#                 execution_results.append({
#                     'function': eod_function.function_id.description_la,
#                     'status': 'success',
#                     'message': func_message
#                 })
#                 logger.info(f"EOD Function {eod_function.function_id.function_id} executed successfully for {processing_date}")

#             return True, f"Successfully executed {total_executed} EOD functions for {processing_date}"

#     except Exception as e:
#         return False, f"Error in EOD process execution: {str(e)}"

# def execute_eod_function(eod_function, user, processing_date):
#     """
#     Execute a specific EOD function (placeholder for actual implementation).
#     """
#     function_id = eod_function.function_id.function_id
#     logger.info(f"Executing function {function_id} for {processing_date}")
#     try:
#         # Placeholder for actual function execution
#         return True, f"Function {function_id} executed successfully"
#     except Exception as e:
#         return False, f"Error executing function {function_id}: {str(e)}"

# def complete_normal_eod_and_create_next(user, processing_date):
#     """
#     Mark current normal EOD as completed and create next working day entry.
#     """
#     try:
#         utc_tz = pytz.UTC
#         current_time = timezone.now().astimezone(utc_tz)
        
#         # Get current EOD record
#         current_eod = STTB_Dates.objects.latest('date_id')
#         current_eod.eod_time = 'Y'
#         current_eod.Checker_Id = user.user_name
#         current_eod.Checker_DT_Stamp = current_time
#         current_eod.save()
        
#         # Create next working day entry
#         start_date = current_eod.next_working_Day.astimezone(utc_tz).date()
#         start_date_dt = utc_tz.localize(datetime.combine(start_date, time(0, 0, 0)))
        
#         prev_working_date = current_eod.Start_Date.astimezone(utc_tz).date()
#         prev_working_day_dt = utc_tz.localize(datetime.combine(prev_working_date, time(0, 0, 0)))
        
#         next_working_date = calculate_next_working_day(start_date + timedelta(days=1))
#         next_working_day_dt = utc_tz.localize(datetime.combine(next_working_date, time(0, 0, 0)))
        
#         new_eod = STTB_Dates.objects.create(
#             Start_Date=start_date_dt,
#             prev_Working_Day=prev_working_day_dt,
#             next_working_Day=next_working_day_dt,
#             eod_time='N'
#         )
        
#         logger.info(f"Normal EOD completed. New EOD created: ID={new_eod.date_id}, Start={start_date_dt}, Prev={prev_working_day_dt}, Next={next_working_day_dt}")
#         return True, f"Normal EOD completed and new EOD created for {start_date_dt.date()}"
        
#     except Exception as e:
#         return False, f"Error completing normal EOD: {str(e)}"

# def calculate_next_working_day(date):
#     """
#     Calculate the next working day based on holiday calendar.
#     """
#     try:
#         current_date = date
#         max_iterations = 10
#         iteration = 0

#         while iteration < max_iterations:
#             year_str = str(current_date.year)
#             month_str = str(current_date.month).zfill(2)

#             try:
#                 holiday_record = MTTB_LCL_Holiday.objects.get(HYear=year_str, HMonth=month_str)
#                 holiday_list = holiday_record.Holiday_List

#                 if len(holiday_list) >= current_date.day:
#                     day_index = current_date.day - 1
#                     if holiday_list[day_index] == 'W':
#                         return current_date

#             except MTTB_LCL_Holiday.DoesNotExist:
#                 return current_date

#             current_date = current_date + timedelta(days=1)
#             iteration += 1

#         logger.warning(f"Could not find next working day after {max_iterations} iterations, using fallback")
#         return date + timedelta(days=1)
#     except Exception as e:
#         logger.error(f"Error calculating next working day: {str(e)}")
#         return date + timedelta(days=1)

# def clear_eod_journal_with_transaction(value_date):
#     """
#     Clear EOD journal entries for the specified date within a transaction.
#     """
#     try:
#         if isinstance(value_date, str):
#             value_date = datetime.strptime(value_date, '%Y-%m-%d').date()

#         with transaction.atomic():
#             cleared_count = 0
#             cleared_details = []

#             # Clear ACTB_DAIRY_LOG
#             actb_count = ACTB_DAIRY_LOG.objects.filter(value_dt=value_date).count()
#             if actb_count > 0:
#                 ACTB_DAIRY_LOG.objects.filter(value_dt=value_date).delete()
#                 cleared_count += actb_count
#                 cleared_details.append(f"ACTB_DAIRY_LOG: {actb_count}")

#             # Clear DETB_JRNL_LOG
#             jrnl_count = DETB_JRNL_LOG.objects.filter(Value_date=value_date).count()
#             if jrnl_count > 0:
#                 DETB_JRNL_LOG.objects.filter(Value_date=value_date).delete()
#                 cleared_count += jrnl_count
#                 cleared_details.append(f"DETB_JRNL_LOG: {jrnl_count}")

#             # Clear DETB_JRNL_LOG_MASTER
#             master_count = DETB_JRNL_LOG_MASTER.objects.filter(Value_date=value_date).count()
#             if master_count > 0:
#                 DETB_JRNL_LOG_MASTER.objects.filter(Value_date=value_date).delete()
#                 cleared_count += master_count
#                 cleared_details.append(f"DETB_JRNL_LOG_MASTER: {master_count}")

#             if cleared_count > 0:
#                 details_str = ", ".join(cleared_details)
#                 message = f"ລຶບຂໍ້ມູນ EOD ສຳເລັດສຳລັບວັນທີ {value_date} (ດ້ວຍ Transaction). ລາຍການທີ່ລຶບ: {details_str}. ລວມ: {cleared_count} ລາຍການ"
#                 logger.info(f"EOD journal cleared with transaction for date {value_date}. Total: {cleared_count}")
#                 return True, message
#             else:
#                 message = f"ບໍ່ມີຂໍ້ມູນ EOD ໃຫ້ລຶບສຳລັບວັນທີ {value_date}"
#                 logger.info(f"No EOD journal entries found for date {value_date}")
#                 return True, message

#     except Exception as e:
#         error_message = f"ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນ EOD ດ້ວຍ Transaction ສຳລັບວັນທີ {value_date}: {str(e)}"
#         logger.error(error_message)
#         return False, error_message

# @api_view(['GET'])
# @permission_classes([IsAuthenticated])
# def check_journal_submission_available(request):
#     """
#     Check if journal submission is available for normal or back-date EOD.
#     - Start_Date: The date that needs EOD processing (target date when eod_time='N').
#     - next_working_Day: The date after EOD completion for normal journal entry.
#     - eod_time: 'N' means Start_Date EOD is not completed; 'Y' means completed.
#     """
#     try:
#         tz = pytz.timezone('Asia/Bangkok')
#         today = timezone.now().astimezone(tz).date()
#         logger.info(f"Checking journal submission availability for {today}")

#         # Get bypass settings
#         try:
#             data_entry = MTTB_DATA_Entry.objects.filter().first()
#             bypass_eod_check = data_entry and data_entry.BACK_VALUE == 'Y'
#             bypass_working_day = data_entry and data_entry.MOD_NO == 'Y'
#         except Exception:
#             bypass_eod_check = False
#             bypass_working_day = False

#         logger.info(f"BACK_VALUE enabled: {bypass_eod_check}, MOD_NO enabled: {bypass_working_day}")

#         # Get latest EOD record
#         try:
#             latest_eod = STTB_Dates.objects.latest('date_id')
#         except STTB_Dates.DoesNotExist:
#             return Response({
#                 "available": False,
#                 "reason": "No EOD records found in STTB_Dates"
#             }, status=status.HTTP_200_OK)

#         # Extract dates in UTC for consistency with database
#         utc_tz = pytz.UTC
#         date_that_needs_eod_processing = latest_eod.Start_Date.astimezone(utc_tz).date()
#         date_for_normal_journal_entry = latest_eod.next_working_Day.astimezone(utc_tz).date()
#         is_eod_completed = latest_eod.eod_time == 'Y'

#         logger.info(f"Latest EOD record: date_id={latest_eod.date_id}, Start_Date={date_that_needs_eod_processing}, "
#                     f"next_working_Day={date_for_normal_journal_entry}, eod_time={latest_eod.eod_time}")

#         # Decision logic
#         if is_eod_completed:
#             # EOD is completed for date_that_needs_eod_processing
#             if date_for_normal_journal_entry == today and (bypass_working_day or is_working_day(today)):
#                 return Response({
#                     "available": True,
#                     "reason": f"ມື້ນີ້ວັນທີ ({today}) ສາມາດບັນທຶກບັນຊີໄດ້. EOD ວັນທີ {date_that_needs_eod_processing} ສຳເລັດແລ້ວ.",
#                     "target_date": today.isoformat(),
#                     "is_back_date": False,
#                     "current_eod": {
#                         "date_id": latest_eod.date_id,
#                         "processed_date": date_that_needs_eod_processing.isoformat(),
#                         "journal_entry_date": date_for_normal_journal_entry.isoformat(),
#                         "eod_status": "Y"
#                     }
#                 }, status=status.HTTP_200_OK)
#             else:
#                 return Response({
#                     "available": False,
#                     "reason": f"EOD ວັນທີ {date_that_needs_eod_processing} ສຳເລັດແລ້ວ ແຕ່ວັນທີບໍ່ຕົງກັນ ຫຼືບໍ່ແມ່ນວັນເຮັດວຽກ."
#                 }, status=status.HTTP_200_OK)
#         else:
#             # EOD is not completed for date_that_needs_eod_processing
#             if bypass_eod_check:
#                 target_date_for_back_processing = date_that_needs_eod_processing
#                 is_back_date = target_date_for_back_processing < today

#                 logger.info(f"Back-date processing: target_date={target_date_for_back_processing}, is_back_date={is_back_date}")

#                 return Response({
#                     "available": True,
#                     "reason": f"ອະນຸຍາດໃຫ້ບັນທຶກຍ້ອນຫຼັງ. ກຳລັງປະມວນຜົນ EOD ວັນທີ ({target_date_for_back_processing})",
#                     "target_date": target_date_for_back_processing.isoformat(),
#                     "is_back_date": is_back_date,
#                     "back_value_enabled": True,
#                     "current_eod": {
#                         "date_id": latest_eod.date_id,
#                         "eod_process_date": target_date_for_back_processing.isoformat(),
#                         "next_working_day": date_for_normal_journal_entry.isoformat(),
#                         "eod_status": "N"
#                     }
#                 }, status=status.HTTP_200_OK)
#             else:
#                 return Response({
#                     "available": False,
#                     "reason": f"EOD ວັນທີ ({date_that_needs_eod_processing}) ຍັງບໍ່ສຳເລັດ. ກະລຸນາສຳເລັດ EOD ກ່ອນບັນທຶກບັນຊີ."
#                 }, status=status.HTTP_200_OK)

#     except Exception as e:
#         logger.error(f"Error checking journal submission availability: {str(e)}")
#         return Response({
#             "available": False,
#             "reason": f"Error: {str(e)}"
#         }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# def is_working_day(date):
#     """
#     Check if the given date is a working day based on holiday calendar.
#     """
#     try:
#         year_str = str(date.year)
#         month_str = str(date.month).zfill(2)
#         try:
#             holiday_record = MTTB_LCL_Holiday.objects.get(HYear=year_str, HMonth=month_str)
#             holiday_list = holiday_record.Holiday_List
#             if len(holiday_list) >= date.day:
#                 day_index = date.day - 1
#                 return holiday_list[day_index] == 'W'
#         except MTTB_LCL_Holiday.DoesNotExist:
#             return True  # Assume working day if no holiday record
#         return False
#     except Exception as e:
#         logger.error(f"Error checking working day: {str(e)}")
#         return False

# from django.utils import timezone
# import pytz
# import logging
# from .models import STTB_Dates, MTTB_DATA_Entry, MTTB_LCL_Holiday
# from rest_framework.decorators import api_view, permission_classes
# from rest_framework.permissions import IsAuthenticated
# from rest_framework.response import Response
# from rest_framework import status

# # Set up logging
# logger = logging.getLogger(__name__)

# @api_view(['GET'])
# @permission_classes([IsAuthenticated])
# def check_journal_submission_available(request):
#     """
#     Check if journal submission is available for normal or back-date.
#     FIELD MEANINGS:
#     - Start_Date = The date open for journal entry and EOD processing when eod_time='N'
#     - next_working_Day = The date after current Start_Date
#     - eod_time = N means Start_Date is open for journal entry, EOD not completed yet
#     - eod_time = Y means EOD completed for Start_Date, day closed for journal entry
#     """
#     try:
#         tz = pytz.timezone('Asia/Bangkok')
#         today = timezone.now().astimezone(tz).date()

#         # Get bypass settings
#         try:
#             data_entry = MTTB_DATA_Entry.objects.filter().first()
#             back_value_enabled = data_entry and data_entry.BACK_VALUE == 'Y'
#             mod_no_enabled = data_entry and data_entry.MOD_NO == 'Y'
#         except Exception:
#             back_value_enabled = False
#             mod_no_enabled = False

#         # Get latest EOD record
#         try:
#             latest_eod = STTB_Dates.objects.latest('date_id')
#         except STTB_Dates.DoesNotExist:
#             return Response({
#                 "available": False,
#                 "reason": "No EOD records found."
#             }, status=status.HTTP_200_OK)

#         # Extract dates
#         current_start_date = latest_eod.Start_Date.astimezone(tz).date()
#         next_working_date = latest_eod.next_working_Day.astimezone(tz).date()
#         is_eod_completed = latest_eod.eod_time == 'Y'

#         logger.info(f"Latest EOD record: date_id={latest_eod.date_id}, Start_Date={current_start_date}, "
#                     f"next_working_Day={next_working_date}, eod_time={latest_eod.eod_time}")

#         # Decision logic
#         if is_eod_completed:
#             # EOD completed, journal submission closed for Start_Date
#             return Response({
#                 "available": False,
#                 "reason": f"EOD already completed for {current_start_date}. Journal submission closed.",
#                 "current_eod": {
#                     "date_id": latest_eod.date_id,
#                     "processed_date": current_start_date.isoformat(),
#                     "journal_entry_date": next_working_date.isoformat(),
#                     "eod_status": "Y"
#                 }
#             }, status=status.HTTP_200_OK)
#         else:
#             # EOD not completed, check if open for journal
#             if current_start_date == today:
#                 # Normal day check
#                 if mod_no_enabled or is_working_day(today):
#                     return Response({
#                         "available": True,
#                         "reason": f"Journal submission available for today ({today}).",
#                         "target_date": today.isoformat(),
#                         "is_back_date": False,
#                         "current_eod": {
#                             "date_id": latest_eod.date_id,
#                             "eod_process_date": current_start_date.isoformat(),
#                             "next_working_day": next_working_date.isoformat(),
#                             "eod_status": "N"
#                         }
#                     }, status=status.HTTP_200_OK)
#                 else:
#                     return Response({
#                         "available": False,
#                         "reason": f"Today ({today}) is not a working day."
#                     }, status=status.HTTP_200_OK)
#             elif back_value_enabled:
#                 # Back-date allowed
#                 is_back_date = current_start_date < today
#                 return Response({
#                     "available": True,
#                     "reason": f"Back-date journal submission allowed for {current_start_date}.",
#                     "target_date": current_start_date.isoformat(),
#                     "is_back_date": is_back_date,
#                     "back_value_enabled": True,
#                     "current_eod": {
#                         "date_id": latest_eod.date_id,
#                         "eod_process_date": current_start_date.isoformat(),
#                         "next_working_day": next_working_date.isoformat(),
#                         "eod_status": "N"
#                     }
#                 }, status=status.HTTP_200_OK)
#             else:
#                 # Neither normal nor back-date allowed
#                 return Response({
#                     "available": False,
#                     "reason": f"EOD for previous date ({current_start_date}) not completed, and back-date not enabled."
#                 }, status=status.HTTP_200_OK)

#     except Exception as e:
#         logger.error(f"Error in check_journal_submission_available: {str(e)}")
#         return Response({
#             "available": False,
#             "reason": f"Error: {str(e)}"
#         }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# def is_working_day(date):
#     """
#     Check if the given date is a working day based on holiday calendar.
#     """
#     try:
#         year_str = str(date.year)
#         month_str = str(date.month).zfill(2)
#         holiday_record = MTTB_LCL_Holiday.objects.get(HYear=year_str, HMonth=month_str)
#         holiday_list = holiday_record.Holiday_List
#         if len(holiday_list) != 31:
#             return False
#         day_index = date.day - 1
#         return holiday_list[day_index] == 'W'
#     except MTTB_LCL_Holiday.DoesNotExist:
#         return True  # Assume working day if no record
#     except Exception as e:
#         logger.error(f"Error checking if {date} is working day: {str(e)}")
#         return False
from datetime import datetime, timedelta, time
from django.utils import timezone
from django.db import transaction
import pytz
import logging
from .models import MTTB_LCL_Holiday, STTB_Dates, MTTB_EOC_MAINTAIN, MTTB_DATA_Entry, ACTB_DAIRY_LOG, DETB_JRNL_LOG, DETB_JRNL_LOG_MASTER
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def end_of_day_journal_view(request):
    """
    API endpoint for End of Day (EOD) journal processing with transaction support.
    Supports both normal and back-date EOD processing.
    Now includes End of Month (EOM) processing detection and execution.
    """
    try:
        tz = pytz.timezone('Asia/Bangkok')
        target_date = request.data.get('target_date')
        eod_id = request.data.get('eod_id')
        
        # Determine mode
        if target_date and eod_id:
            # Back-date mode
            if isinstance(target_date, str):
                processing_date = datetime.strptime(target_date, '%Y-%m-%d').date()
            else:
                processing_date = target_date
            is_back_date = True
            logger.info(f"Starting BACK-DATE EOD process for date: {processing_date}, EOD ID: {eod_id}, User: {request.user}")
        else:
            # Normal mode
            value_date = request.data.get('value_date')
            if not value_date:
                processing_date = timezone.now().astimezone(tz).date()
            elif isinstance(value_date, str):
                processing_date = datetime.strptime(value_date, '%Y-%m-%d').date()
            else:
                processing_date = value_date
            is_back_date = False
            eod_id = None
            logger.info(f"Starting NORMAL EOD process for date: {processing_date}, User: {request.user}")
        
        with transaction.atomic():
            # Step 1: Validate EOD requirements
            if is_back_date:
                validation_success, validation_message = validate_backdate_eod_requirements(processing_date, eod_id)
            else:
                validation_success, validation_message = validate_normal_eod_requirements(processing_date)
            
            if not validation_success:
                logger.error(f"EOD validation failed: {validation_message}")
                raise Exception(validation_message)
            
            # Step 2: Validate all journals are approved
            journals_approved, journal_message = validate_journal_approvals(processing_date)
            if not journals_approved:
                logger.error(f"Journal validation failed: {journal_message}")
                raise Exception(journal_message)
            
            # Step 3: Execute EOD functions
            eod_success, eod_message = execute_eod_process(request.user, processing_date, is_back_date)
            if not eod_success:
                logger.error(f"EOD process failed: {eod_message}")
                raise Exception(eod_message)
            
            # Step 4: Check for EOM and EOY processing
            eom_executed = False
            eoy_executed = False
            eom_message = ""
            eoy_message = ""
            
            # Check if this is the last working day of the year (December)
            if is_last_working_day_of_year(processing_date):
                logger.info(f"Last working day of year detected for {processing_date}. Starting EOY process...")
                
                eoy_success, eoy_message = execute_eoy_process(request.user, processing_date, is_back_date)
                eoy_executed = True
                
                if not eoy_success:
                    logger.error(f"EOY process failed for {processing_date}: {eoy_message}")
                    raise Exception(f"EOD completed but EOY process failed: {eoy_message}")
                    
            # Check if this is the last working day of the month (but not EOY)
            elif is_last_working_day_of_month(processing_date):
                logger.info(f"Last working day of month detected for {processing_date}. Starting EOM process...")
                
                eom_success, eom_message = execute_eom_process(request.user, processing_date, is_back_date)
                eom_executed = True
                
                if not eom_success:
                    logger.error(f"EOM process failed for {processing_date}: {eom_message}")
                    raise Exception(f"EOD completed but EOM process failed: {eom_message}")
            else:
                logger.info(f"Regular working day for {processing_date}. Skipping EOM/EOY processes.")
            
            # Step 5: Clear EOD journal
            clear_success, clear_message = clear_eod_journal_with_transaction(processing_date)
            if not clear_success:
                logger.error(f"EOD journal clear failed: {clear_message}")
                raise Exception(clear_message)
            
            # Step 6: Complete EOD and create next working day
            if is_back_date:
                complete_success, complete_message = complete_backdate_eod_and_create_next(eod_id, request.user, processing_date)
            else:
                complete_success, complete_message = complete_normal_eod_and_create_next(request.user, processing_date)
            
            if not complete_success:
                logger.error(f"EOD completion failed: {complete_message}")
                raise Exception(complete_message)
            
            # All steps successful
            mode_text = "back-date" if is_back_date else "normal"
            if eoy_executed:
                final_message = f"ການປະມວນຜົນ EOD ແລະ EOY {mode_text} ສຳເລັດແລ້ວ ສຳລັບວັນທີ {processing_date}. ປີນີ້ຖືກສິ້ນສຸດແລ້ວ."
            elif eom_executed:
                final_message = f"ການປະມວນຜົນ EOD ແລະ EOM {mode_text} ສຳເລັດແລ້ວ ສຳລັບວັນທີ {processing_date}. ເດືອນນີ້ຖືກສິ້ນສຸດແລ້ວ."
            else:
                final_message = f"ການປະມວນຜົນ EOD {mode_text} ສຳເລັດແລ້ວ ສຳລັບວັນທີ {processing_date}. ມື້ນີ້ຖືກສົ່ງແລ້ວ."
            
            logger.info(f"{mode_text.upper()} EOD process successful for {processing_date}. EOM executed: {eom_executed}, EOY executed: {eoy_executed}")

            response_data = {
                "message": final_message,
                "success": True,
                "is_back_date": is_back_date,
                "processing_date": processing_date.isoformat(),
                "eom_executed": eom_executed,
                "eoy_executed": eoy_executed,
                "is_last_working_day_of_month": is_last_working_day_of_month(processing_date),
                "is_last_working_day_of_year": is_last_working_day_of_year(processing_date),
                "details": {
                    "validation": validation_message,
                    "journal_validation": journal_message,
                    "eod_process": eod_message,
                    "clear_journal": clear_message,
                    "completion": complete_message
                }
            }

            if eom_executed:
                response_data["details"]["eom_process"] = eom_message
                
            if eoy_executed:
                response_data["details"]["eoy_process"] = eoy_message

            return Response(response_data, status=status.HTTP_201_CREATED)

    except Exception as e:
        logger.error(f"EOD process failed for {processing_date if 'processing_date' in locals() else 'unknown date'}: {str(e)}")
        return Response({
            "error": f"ການປະມວນຜົນ EOD ລົ້ມເຫລວ: {str(e)}",
            "success": False
        }, status=status.HTTP_400_BAD_REQUEST)


def validate_normal_eod_requirements(processing_date):
    """
    Validates if normal EOD can be performed.
    """
    try:
        tz = pytz.timezone('Asia/Bangkok')
        year_str = str(processing_date.year)
        month_str = str(processing_date.month).zfill(2)
        
        # Check MTTB_DATA_Entry for bypass settings
        data_entry = MTTB_DATA_Entry.objects.filter().first()
        mod_no_enabled = data_entry and data_entry.MOD_NO == 'Y'
        
        if not mod_no_enabled:
            # Check if processing_date is a working day
            try:
                holiday_record = MTTB_LCL_Holiday.objects.get(HYear=year_str, HMonth=month_str)
                holiday_list = holiday_record.Holiday_List
                if len(holiday_list) != 31:
                    return False, "Invalid Holiday_List length. Must be 31 characters."
                day_index = processing_date.day - 1
                if holiday_list[day_index] != 'W':
                    return False, f"{processing_date} is not a working day."
            except MTTB_LCL_Holiday.DoesNotExist:
                return False, f"No holiday record for {year_str}-{month_str}."
        
        # Check the latest STTB_Dates row
        try:
            latest_eod = STTB_Dates.objects.latest('date_id')
        except STTB_Dates.DoesNotExist:
            return False, "No records found in STTB_Dates."
        
        expected_start_date = latest_eod.Start_Date.astimezone(tz).date()
        if expected_start_date != processing_date:
            return False, f"Processing date ({processing_date}) does not match expected Start_Date ({expected_start_date})."
        
        if latest_eod.eod_time == 'Y':
            return False, f"EOD already completed for {processing_date}."
        
        return True, f"Normal EOD validation passed for {processing_date}"

    except Exception as e:
        return False, f"Error in normal EOD validation: {str(e)}"

def validate_backdate_eod_requirements(target_date, eod_id):
    """
    Validate if back-date EOD can be performed, considering MOD_NO and BACK_VALUE settings.
    """
    try:
        tz = pytz.timezone('Asia/Bangkok')
        today = timezone.now().astimezone(tz).date()

        # Check if BACK_VALUE and MOD_NO are enabled
        data_entry = MTTB_DATA_Entry.objects.filter().first()
        if not data_entry or data_entry.BACK_VALUE != 'Y':
            return False, "Back-date processing is not enabled (BACK_VALUE != 'Y')"
        if not data_entry or data_entry.MOD_NO != 'Y':
            return False, "Working day bypass not enabled (MOD_NO != 'Y')"

        # Verify the EOD record exists
        try:
            eod_record = STTB_Dates.objects.get(date_id=eod_id)
        except STTB_Dates.DoesNotExist:
            return False, f"EOD record with ID {eod_id} not found"

        # Check if target_date matches the EOD record's Start_Date
        eod_start_date = eod_record.Start_Date.astimezone(tz).date()
        if eod_start_date != target_date:
            return False, f"Target date ({target_date}) does not match EOD record Start_Date ({eod_start_date})"

        # Check if EOD is still pending
        if eod_record.eod_time == 'Y':
            return False, f"EOD for {target_date} is already completed"

        # Verify target_date is in the past
        if target_date >= today:
            return False, f"Target date ({target_date}) must be in the past for back-dating"

        return True, f"Back-date EOD validation passed for {target_date} (EOD ID: {eod_id})"

    except Exception as e:
        return False, f"Error in back-date EOD validation: {str(e)}"

def validate_journal_approvals(processing_date):
    """
    Validate that all journals for the processing date are approved.
    """
    try:
        unapproved_journals = DETB_JRNL_LOG.objects.filter(
            Value_date=processing_date,
            Auth_Status__in=['U', 'P']
        ).exclude(Txn_code='ARD').count()

        if unapproved_journals > 0:
            return False, f"Found {unapproved_journals} unapproved journals for {processing_date}"

        return True, f"All journals for {processing_date} are approved"

    except Exception as e:
        return False, f"Error validating journal approvals: {str(e)}"

def execute_eod_process(user, processing_date, is_back_date=False):
    """
    Execute all EOD functions in sequence for back-date or normal processing.
    """
    try:
        with transaction.atomic():
            eod_functions = MTTB_EOC_MAINTAIN.objects.filter(
                eoc_type='EOD',
                Auth_Status='A',
                Record_Status='O'
            ).select_related('function_id').order_by('eoc_seq_no')

            if not eod_functions:
                return False, "No active EOD functions found"

            total_executed = 0
            execution_results = []

            for eod_function in eod_functions:
                func_success, func_message = execute_eod_function(eod_function, user, processing_date)
                if not func_success:
                    return False, f"Function {eod_function.function_id.description_la} failed: {func_message}"
                total_executed += 1
                execution_results.append({
                    'function': eod_function.function_id.description_la,
                    'status': 'success',
                    'message': func_message
                })
                logger.info(f"EOD Function {eod_function.function_id.function_id} executed successfully for {processing_date}")

            return True, f"Successfully executed {total_executed} EOD functions for {processing_date}"

    except Exception as e:
        return False, f"Error in EOD process execution: {str(e)}"



def execute_eod_function(eod_function, user, processing_date=None, is_back_date=False):
    """
    Execute a specific EOD function based on its function_id mapping.
    """
    function_id = eod_function.function_id.function_id
    context = f"back-date for {processing_date}" if is_back_date else f"normal for {processing_date or 'today'}"
    logger.info(f"Executing function {function_id} ({context})")

    try:
        # Map function IDs to their corresponding execution methods
        function_mapping = {
            'FN006': execute_bulk_journal,        # Bulk Journal Processing
            'FN004': lambda eod_func, usr: execute_dairy_somtop_trailbalance(eod_func, usr, processing_date),  # Dairy Reports
            'FN009': lambda eod_func, usr: execute_somtop_trial_balancesheet(eod_func, usr, processing_date),  # Somtop Trial Balancesheet
            'EOD_INTEREST': execute_interest_calculation,
            'EOD_INTEREST': execute_interest_calculation,
            'EOD_REPORT': execute_report_generation,
            'EOD_BACKUP': execute_backup_process,
        }

        if function_id in function_mapping:
            # Execute the mapped function
            return function_mapping[function_id](eod_function, user)
        else:
            # Generic execution for unmapped functions
            return execute_generic_function(eod_function, user)

    except Exception as e:
        logger.error(f"Error executing function {function_id}: {str(e)}", exc_info=True)
        return False, f"ຂໍ້ຜິດພາດໃນການປະມວນຜົນ {function_id}: {str(e)}"

def complete_normal_eod_and_create_next(user, processing_date):
    """
    Mark current normal EOD as completed and create next working day entry.
    Creates new STTB_Dates record with:
    Start_Date = current record's next_working_Day (e.g., 2025-08-12), with dynamic submission time
    prev_Working_Day = current record's Start_Date (e.g., 2025-08-11), with dynamic submission time
    next_working_Day = next working day after Start_Date (e.g., 2025-08-13), with 00:00:00 time
    eod_time = N
    """
    try:
        utc_tz = pytz.UTC
        current_time = timezone.now().astimezone(utc_tz)
        current_time_time = current_time.time()
        
        # Mark current EOD as completed
        current_eod = STTB_Dates.objects.latest('date_id')
        current_eod.eod_time = 'Y'
        current_eod.Checker_Id = user.user_name
        current_eod.Checker_DT_Stamp = current_time
        current_eod.save()
        
        # Create next working day entry
        start_date = current_eod.next_working_Day.astimezone(utc_tz).date()
        print(f"Creating next EOD for start date: {start_date}")
        start_date_dt = utc_tz.localize(datetime.combine(start_date, current_time_time))
        print(f"Start date with time: {start_date_dt}")
        
        prev_working_date = current_eod.Start_Date.astimezone(utc_tz).date()
        prev_working_day_dt = utc_tz.localize(datetime.combine(prev_working_date, current_time_time))
        
        next_working_date = calculate_next_working_day(start_date + timedelta(days=1))
        next_working_day_dt = utc_tz.localize(datetime.combine(next_working_date, time(0, 0, 0)))
        
        new_eod = STTB_Dates.objects.create(
            Start_Date=start_date_dt,
            prev_Working_Day=prev_working_day_dt,
            next_working_Day=next_working_day_dt,
            eod_time='N'
        )
        
        logger.info(f"Normal EOD completed. New EOD created: ID={new_eod.date_id}, Start={start_date_dt}, Prev={prev_working_day_dt}, Next={next_working_day_dt}")
        return True, f"Normal EOD completed and new EOD created for {start_date_dt.date()}"

    except Exception as e:
        return False, f"Error completing normal EOD and creating next day: {str(e)}"




def complete_backdate_eod_and_create_next(eod_id, user, processing_date):
    """
    Mark the back-date EOD as completed and create the next working day entry.
    Creates new STTB_Dates record with:
    Start_Date = current record's next_working_Day,
    prev_Working_Day = current record's Start_Date,
    next_working_Day = next working day after Start_Date,
    eod_time = N
    """
    try:
        utc_tz = pytz.UTC
        current_time = timezone.now().astimezone(utc_tz)

        # Mark current EOD as completed
        try:
            eod_record = STTB_Dates.objects.get(date_id=eod_id)
        except STTB_Dates.DoesNotExist:
            return False, f"EOD record {eod_id} not found"

        eod_record.eod_time = 'Y'
        eod_record.Checker_Id = user.user_name
        eod_record.Checker_DT_Stamp = current_time
        eod_record.save()

        # Create next working day entry
        start_date = eod_record.next_working_Day.astimezone(utc_tz).date()
        start_date_dt = utc_tz.localize(datetime.combine(start_date, time(4, 21, 54, 46981)))

        prev_working_date = eod_record.Start_Date.astimezone(utc_tz).date()
        prev_working_day_dt = utc_tz.localize(datetime.combine(prev_working_date, time(4, 21, 54, 47002)))

        next_working_date = calculate_next_working_day(start_date + timedelta(days=1))
        next_working_day_dt = utc_tz.localize(datetime.combine(next_working_date, time(0, 0, 0)))

        new_eod = STTB_Dates.objects.create(
            Start_Date=start_date_dt,
            prev_Working_Day=prev_working_day_dt,
            next_working_Day=next_working_day_dt,
            eod_time='N'
        )

        logger.info(f"Back-date EOD {eod_id} completed. New EOD created: ID={new_eod.date_id}, Start={start_date_dt}, Prev={prev_working_day_dt}, Next={next_working_day_dt}")
        return True, f"Back-date EOD {eod_id} completed and new EOD created for {start_date_dt.date()}"

    except Exception as e:
        return False, f"Error completing back-date EOD and creating next day: {str(e)}"

def calculate_next_working_day(date):
    """
    Calculate the next working day based on holiday calendar.
    """
    try:
        current_date = date
        max_iterations = 10
        iteration = 0

        while iteration < max_iterations:
            year_str = str(current_date.year)
            month_str = str(current_date.month).zfill(2)

            try:
                holiday_record = MTTB_LCL_Holiday.objects.get(HYear=year_str, HMonth=month_str)
                holiday_list = holiday_record.Holiday_List

                if len(holiday_list) >= current_date.day:
                    day_index = current_date.day - 1
                    if holiday_list[day_index] == 'W':
                        return current_date

            except MTTB_LCL_Holiday.DoesNotExist:
                return current_date

            current_date = current_date + timedelta(days=1)
            iteration += 1

        logger.warning(f"Could not find next working day after {max_iterations} iterations, using fallback")
        return date + timedelta(days=1)
    except Exception as e:
        logger.error(f"Error calculating next working day: {str(e)}")
        return date + timedelta(days=1)

def clear_eod_journal_with_transaction(value_date):
    """
    Clear EOD journal entries for the specified date within a transaction.
    """
    try:
        if isinstance(value_date, str):
            value_date = datetime.strptime(value_date, '%Y-%m-%d').date()

        with transaction.atomic():
            cleared_count = 0
            cleared_details = []

            # Clear ACTB_DAIRY_LOG
            actb_count = ACTB_DAIRY_LOG.objects.filter(value_dt=value_date).count()
            if actb_count > 0:
                ACTB_DAIRY_LOG.objects.filter(value_dt=value_date).delete()
                cleared_count += actb_count
                cleared_details.append(f"ACTB_DAIRY_LOG: {actb_count}")

            # Clear DETB_JRNL_LOG
            jrnl_count = DETB_JRNL_LOG.objects.filter(Value_date=value_date).count()
            if jrnl_count > 0:
                DETB_JRNL_LOG.objects.filter(Value_date=value_date).delete()
                cleared_count += jrnl_count
                cleared_details.append(f"DETB_JRNL_LOG: {jrnl_count}")

            # Clear DETB_JRNL_LOG_MASTER
            master_count = DETB_JRNL_LOG_MASTER.objects.filter(Value_date=value_date).count()
            if master_count > 0:
                DETB_JRNL_LOG_MASTER.objects.filter(Value_date=value_date).delete()
                cleared_count += master_count
                cleared_details.append(f"DETB_JRNL_LOG_MASTER: {master_count}")

            if cleared_count > 0:
                details_str = ", ".join(cleared_details)
                message = f"ລຶບຂໍ້ມູນ EOD ສຳເລັດສຳລັບວັນທີ {value_date} (ດ້ວຍ Transaction). ລາຍການທີ່ລຶບ: {details_str}. ລວມ: {cleared_count} ລາຍການ"
                logger.info(f"EOD journal cleared with transaction for date {value_date}. Total: {cleared_count}")
                return True, message
            else:
                message = f"ບໍ່ມີຂໍ້ມູນ EOD ໃຫ້ລຶບສຳລັບວັນທີ {value_date}"
                logger.info(f"No EOD journal entries found for date {value_date}")
                return True, message

    except Exception as e:
        error_message = f"ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນ EOD ດ້ວຍ Transaction ສຳລັບວັນທີ {value_date}: {str(e)}"
        logger.error(error_message)
        return False, error_message


def execute_eoy_process(user, processing_date, is_back_date=False):
    """
    Execute all EOY functions in sequence for back-date or normal processing.
    """
    try:
        with transaction.atomic():
            # Get EOY functions from MTTB_EOC_MAINTAIN table
            eoy_functions = MTTB_EOC_MAINTAIN.objects.filter(
                eoc_type='EOY',  # End of Year functions
                Auth_Status='A',
                Record_Status='O'
            ).select_related('function_id').order_by('eoc_seq_no')

            if not eoy_functions:
                return False, "No active EOY functions found"

            total_executed = 0
            execution_results = []

            for eoy_function in eoy_functions:
                # Create initial status log
                status_log = create_eoc_status_log(
                    eoc_function=eoy_function,
                    eoc_type='EOY',
                    processing_date=processing_date,
                    status='N'
                )
                
                try:
                    # Update status to Working
                    update_eoc_status_log(status_log, 'W')
                    
                    func_success, func_message = execute_eoy_function(eoy_function, user, processing_date)
                    
                    if not func_success:
                        # Update status to Error
                        update_eoc_status_log(status_log, 'E', func_message)
                        return False, f"EOY Function {eoy_function.function_id.description_la} failed: {func_message}"
                    
                    # Update status to Completed
                    update_eoc_status_log(status_log, 'C')
                    
                    total_executed += 1
                    execution_results.append({
                        'function': eoy_function.function_id.description_la,
                        'status': 'success',
                        'message': func_message
                    })
                    logger.info(f"EOY Function {eoy_function.function_id.function_id} executed successfully for {processing_date}")
                    
                except Exception as func_error:
                    # Update status to Error
                    update_eoc_status_log(status_log, 'E', str(func_error))
                    raise func_error

            return True, f"Successfully executed {total_executed} EOY functions for {processing_date}"

    except Exception as e:
        logger.error(f"Error in EOY process execution: {str(e)}")
        return False, f"Error in EOY process execution: {str(e)}"


def execute_eoy_function(eoy_function, user, processing_date=None, is_back_date=False):
    """
    Execute a specific EOY function based on its function_id mapping.
    """
    function_id = eoy_function.function_id.function_id
    context = f"back-date for {processing_date}" if is_back_date else f"normal for {processing_date or 'today'}"
    logger.info(f"Executing EOY function {function_id} ({context})")

    try:
        # Map EOY function IDs to their corresponding execution methods
        eoy_function_mapping = {
            # 'FN001': lambda eoy_func, usr: execute_eoy_annual_reports(eoy_func, usr, processing_date),
            # 'FN008': lambda eoy_func, usr: execute_eoy_year_end_closing(eoy_func, usr, processing_date),
            # 'FN009': lambda eoy_func, usr: execute_eoy_tax_reports(eoy_func, usr, processing_date),
            # 'EOY_AUDIT': execute_eoy_audit_preparation,
            # 'EOY_ARCHIVE': execute_eoy_data_archival,
            # 'EOY_BACKUP': execute_eoy_annual_backup,
            # Add more EOY function mappings as needed
        }

        if function_id in eoy_function_mapping:
            return eoy_function_mapping[function_id](eoy_function, user, processing_date)
        else:
            return execute_generic_eoy_function(eoy_function, user, processing_date)

    except Exception as e:
        logger.error(f"Error executing EOY function {function_id}: {str(e)}", exc_info=True)
        return False, f"ຂໍ້ຜິດພາດໃນການປະມວນຜົນ EOY {function_id}: {str(e)}"

def create_eoc_status_log(eoc_function, eoc_type, processing_date, status='N'):
    """
    Create a new EOC status log entry.
    """
    try:
        from .models import STTB_EOC_STATUS
        
        status_log = STTB_EOC_STATUS.objects.create(
            eoc_seq_no=eoc_function.eoc_seq_no,
            eoc_id=eoc_function,
            eoc_type=eoc_type,
            eod_date=timezone.now(),
            eoc_status=status,
            error=None
        )
        
        logger.info(f"Created EOC status log: {eoc_type}-{eoc_function.function_id.function_id} with status {status}")
        return status_log
        
    except Exception as e:
        logger.error(f"Error creating EOC status log: {str(e)}")
        return None


def update_eoc_status_log(status_log, new_status, error_message=None):
    """
    Update an existing EOC status log entry.
    """
    try:
        if status_log:
            status_log.eoc_status = new_status
            if error_message and new_status == 'E':
                status_log.error = error_message[:550]  # Truncate to field limit
            status_log.save()
            
            logger.info(f"Updated EOC status log ID {status_log.eoc_stt_id} to status {new_status}")
            
    except Exception as e:
        logger.error(f"Error updating EOC status log: {str(e)}")


def execute_generic_eoy_function(eoy_function, user, processing_date=None):
    """
    Generic execution for unmapped EOY functions.
    """
    try:
        function_id = eoy_function.function_id.function_id
        logger.info(f"[{function_id}] Starting generic EOY function for {processing_date}")
        
        # TODO: Implement generic EOY function logic
        
        logger.info(f"[{function_id}] Completed successfully for {processing_date}")
        return True, f"Generic EOY function {function_id} completed successfully"
        
    except Exception as e:
        logger.error(f"Generic EOY function error: {str(e)}", exc_info=True)
        return False, f"Generic EOY function error: {str(e)}"

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def check_journal_submission_available(request):
    """
    Check if journal submission is available for normal or back-date.
    FIELD MEANINGS:
    - Start_Date = The date open for journal entry and EOD processing when eod_time='N'
    - next_working_Day = The date after current Start_Date
    - eod_time = N means Start_Date is open for journal entry, EOD not completed yet
    - eod_time = Y means EOD completed for Start_Date, day closed for journal entry
    """
    try:
        tz = pytz.timezone('Asia/Bangkok')
        today = timezone.now().astimezone(tz).date()

        # Get bypass settings
        try:
            data_entry = MTTB_DATA_Entry.objects.filter().first()
            back_value_enabled = data_entry and data_entry.BACK_VALUE == 'Y'
            mod_no_enabled = data_entry and data_entry.MOD_NO == 'Y'
        except Exception:
            back_value_enabled = False
            mod_no_enabled = False

        logger.info(f"Checking journal submission availability for {today}, BACK_VALUE={back_value_enabled}, MOD_NO={mod_no_enabled}")

        # Get latest EOD record
        try:
            latest_eod = STTB_Dates.objects.latest('date_id')
        except STTB_Dates.DoesNotExist:
            return Response({
                "available": False,
                "reason": "No EOD records found."
            }, status=status.HTTP_200_OK)

        # Extract dates
        utc_tz = pytz.UTC
        current_start_date = latest_eod.Start_Date.astimezone(utc_tz).date()
        next_working_date = latest_eod.next_working_Day.astimezone(utc_tz).date()
        is_eod_completed = latest_eod.eod_time == 'Y'

        logger.info(f"Latest EOD record: date_id={latest_eod.date_id}, Start_Date={current_start_date}, "
                    f"next_working_Day={next_working_date}, eod_time={latest_eod.eod_time}")

        # Decision logic
        if is_eod_completed:
            # EOD completed, journal submission closed for Start_Date
            return Response({
                "available": False,
                "reason": f"EOD already completed for {current_start_date}. Journal submission closed.",
                "current_eod": {
                    "date_id": latest_eod.date_id,
                    "processed_date": current_start_date.isoformat(),
                    "journal_entry_date": next_working_date.isoformat(),
                    "eod_status": "Y"
                }
            }, status=status.HTTP_200_OK)
        else:
            # EOD not completed, check if open for journal
            if current_start_date == today:
                # Normal day check
                if mod_no_enabled or is_working_day(today):
                    return Response({
                        "available": True,
                        "reason": f"Journal submission available for today ({today}).",
                        "target_date": today.isoformat(),
                        "is_back_date": False,
                        "current_eod": {
                            "date_id": latest_eod.date_id,
                            "eod_process_date": current_start_date.isoformat(),
                            "next_working_day": next_working_date.isoformat(),
                            "eod_status": "N"
                        }
                    }, status=status.HTTP_200_OK)
                else:
                    return Response({
                        "available": False,
                        "reason": f"Today ({today}) is not a working day."
                    }, status=status.HTTP_200_OK)
            elif back_value_enabled:
                # Back-date allowed
                is_back_date = current_start_date < today
                return Response({
                    "available": True,
                    "reason": f"Back-date journal submission allowed for {current_start_date}.",
                    "target_date": current_start_date.isoformat(),
                    "is_back_date": is_back_date,
                    "back_value_enabled": True,
                    "current_eod": {
                        "date_id": latest_eod.date_id,
                        "eod_process_date": current_start_date.isoformat(),
                        "next_working_day": next_working_date.isoformat(),
                        "eod_status": "N"
                    }
                }, status=status.HTTP_200_OK)
            else:
                # Neither normal nor back-date allowed
                return Response({
                    "available": False,
                    "reason": f"EOD for previous date ({current_start_date}) not completed, and back-date not enabled."
                }, status=status.HTTP_200_OK)

    except Exception as e:
        logger.error(f"Error in check_journal_submission_available: {str(e)}")
        return Response({
            "available": False,
            "reason": f"Error: {str(e)}"
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

def is_working_day(date):
    """
    Check if the given date is a working day based on holiday calendar.
    """
    try:
        year_str = str(date.year)
        month_str = str(date.month).zfill(2)
        try:
            holiday_record = MTTB_LCL_Holiday.objects.get(HYear=year_str, HMonth=month_str)
            holiday_list = holiday_record.Holiday_List
            if len(holiday_list) != 31:
                return False
            day_index = date.day - 1
            return holiday_list[day_index] == 'W'
        except MTTB_LCL_Holiday.DoesNotExist:
            return True  # Assume working day if no record
        except Exception as e:
            logger.error(f"Error checking if {date} is working day: {str(e)}")
            return False
    except Exception as e:
        logger.error(f"Error in is_working_day function: {str(e)}")

from datetime import datetime, timedelta, time
from django.utils import timezone
from django.db import transaction
import pytz
import logging
import calendar
from .models import MTTB_LCL_Holiday, STTB_Dates, MTTB_EOC_MAINTAIN, MTTB_DATA_Entry, ACTB_DAIRY_LOG, DETB_JRNL_LOG, DETB_JRNL_LOG_MASTER
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

# Set up logging
logger = logging.getLogger(__name__)

def is_last_working_day_of_month(check_date=None):
    """
    Check if the given date (or today) is the last working day of the month.
    Uses MTTB_LCL_Holiday.Holiday_List to find the last 'W' in the 31-character string.
    
    Args:
        check_date: Date to check (default: today)
    
    Returns:
        bool: True if it's the last working day of the month
    """
    if check_date is None:
        tz = pytz.timezone('Asia/Bangkok')
        check_date = timezone.now().astimezone(tz).date()
    
    if isinstance(check_date, str):
        check_date = datetime.strptime(check_date, '%Y-%m-%d').date()
    
    try:
        year_str = str(check_date.year)
        month_str = str(check_date.month).zfill(2)
        
        try:
            holiday_record = MTTB_LCL_Holiday.objects.get(HYear=year_str, HMonth=month_str)
            holiday_list = holiday_record.Holiday_List
            
            if len(holiday_list) != 31:
                logger.warning(f"Invalid Holiday_List length for {year_str}-{month_str}: {len(holiday_list)} chars")
                return False
            
            # Find the last 'W' (working day) in the holiday_list
            last_working_day_index = -1
            for i in range(30, -1, -1):  # Check from day 31 backwards to day 1
                if holiday_list[i] == 'W':
                    last_working_day_index = i
                    break
            
            if last_working_day_index == -1:
                logger.warning(f"No working days found in {year_str}-{month_str}")
                return False
            
            # Convert index to actual day (index 0 = day 1)
            last_working_day_of_month = last_working_day_index + 1
            
            logger.info(f"Last working day of month {check_date.strftime('%Y-%m')}: day {last_working_day_of_month}")
            logger.info(f"Checking date: {check_date} (day {check_date.day}), Is last working day: {check_date.day == last_working_day_of_month}")
            
            return check_date.day == last_working_day_of_month
            
        except MTTB_LCL_Holiday.DoesNotExist:
            logger.warning(f"No holiday record found for {year_str}-{month_str}, assuming not last working day")
            return False
            
    except Exception as e:
        logger.error(f"Error in is_last_working_day_of_month: {str(e)}")
        return False

from datetime import datetime, timedelta, time
from django.utils import timezone
from django.db import transaction
import pytz
import logging
import calendar
from .models import MTTB_LCL_Holiday, STTB_Dates, MTTB_EOC_MAINTAIN, MTTB_DATA_Entry, ACTB_DAIRY_LOG, DETB_JRNL_LOG, DETB_JRNL_LOG_MASTER
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

# Set up logging
logger = logging.getLogger(__name__)

def is_last_working_day_of_year(check_date=None):
    """
    Check if the given date is the last working day of December (end of year).
    Uses MTTB_LCL_Holiday.Holiday_List to find the last 'W' in December.
    
    Args:
        check_date: Date to check (default: today)
    
    Returns:
        bool: True if it's the last working day of the year (December)
    """
    if check_date is None:
        tz = pytz.timezone('Asia/Bangkok')
        check_date = timezone.now().astimezone(tz).date()
    
    if isinstance(check_date, str):
        check_date = datetime.strptime(check_date, '%Y-%m-%d').date()
    
    # Only check December dates
    if check_date.month != 12:
        return False
    
    try:
        year_str = str(check_date.year)
        month_str = "12"  # December
        
        try:
            holiday_record = MTTB_LCL_Holiday.objects.get(HYear=year_str, HMonth=month_str)
            holiday_list = holiday_record.Holiday_List
            
            if len(holiday_list) != 31:
                logger.warning(f"Invalid Holiday_List length for {year_str}-12: {len(holiday_list)} chars")
                return False
            
            # Find the last 'W' (working day) in December's holiday_list
            last_working_day_index = -1
            for i in range(30, -1, -1):  # Check from day 31 backwards to day 1
                if holiday_list[i] == 'W':
                    last_working_day_index = i
                    break
            
            if last_working_day_index == -1:
                logger.warning(f"No working days found in December {year_str}")
                return False
            
            # Convert index to actual day (index 0 = day 1)
            last_working_day_of_december = last_working_day_index + 1
            
            logger.info(f"Last working day of year {check_date.year}: December {last_working_day_of_december}")
            logger.info(f"Checking date: {check_date} (December {check_date.day}), Is last working day of year: {check_date.day == last_working_day_of_december}")
            
            return check_date.day == last_working_day_of_december
            
        except MTTB_LCL_Holiday.DoesNotExist:
            logger.warning(f"No holiday record found for December {year_str}, assuming not last working day of year")
            return False
            
    except Exception as e:
        logger.error(f"Error in is_last_working_day_of_year: {str(e)}")
        return False
    """
    Check if the given date (or today) is the last working day of the month.
    Uses MTTB_LCL_Holiday.Holiday_List to find the last 'W' in the 31-character string.
    
    Args:
        check_date: Date to check (default: today)
    
    Returns:
        bool: True if it's the last working day of the month
    """
    if check_date is None:
        tz = pytz.timezone('Asia/Bangkok')
        check_date = timezone.now().astimezone(tz).date()
    
    if isinstance(check_date, str):
        check_date = datetime.strptime(check_date, '%Y-%m-%d').date()
    
    try:
        year_str = str(check_date.year)
        month_str = str(check_date.month).zfill(2)
        
        try:
            holiday_record = MTTB_LCL_Holiday.objects.get(HYear=year_str, HMonth=month_str)
            holiday_list = holiday_record.Holiday_List
            
            if len(holiday_list) != 31:
                logger.warning(f"Invalid Holiday_List length for {year_str}-{month_str}: {len(holiday_list)} chars")
                return False
            
            # Find the last 'W' (working day) in the holiday_list
            last_working_day_index = -1
            for i in range(30, -1, -1):  # Check from day 31 backwards to day 1
                if holiday_list[i] == 'W':
                    last_working_day_index = i
                    break
            
            if last_working_day_index == -1:
                logger.warning(f"No working days found in {year_str}-{month_str}")
                return False
            
            # Convert index to actual day (index 0 = day 1)
            last_working_day_of_month = last_working_day_index + 1
            
            logger.info(f"Last working day of month {check_date.strftime('%Y-%m')}: day {last_working_day_of_month}")
            logger.info(f"Checking date: {check_date} (day {check_date.day}), Is last working day: {check_date.day == last_working_day_of_month}")
            
            return check_date.day == last_working_day_of_month
            
        except MTTB_LCL_Holiday.DoesNotExist:
            logger.warning(f"No holiday record found for {year_str}-{month_str}, assuming not last working day")
            return False
            
    except Exception as e:
        logger.error(f"Error in is_last_working_day_of_month: {str(e)}")
        return False
def execute_eom_process(user, processing_date, is_back_date=False):
    """
    Execute all EOM functions in sequence for back-date or normal processing.
    """
    try:
        with transaction.atomic():
            # Get EOM functions from MTTB_EOC_MAINTAIN table
            eom_functions = MTTB_EOC_MAINTAIN.objects.filter(
                eoc_type='EOM',  # End of Month functions
                Auth_Status='A',
                Record_Status='O'
            ).select_related('function_id').order_by('eoc_seq_no')

            if not eom_functions:
                return False, "No active EOM functions found"

            total_executed = 0
            execution_results = []

            for eom_function in eom_functions:
                func_success, func_message = execute_eom_function(eom_function, user, processing_date)
                if not func_success:
                    return False, f"EOM Function {eom_function.function_id.description_la} failed: {func_message}"
                    
                total_executed += 1
                execution_results.append({
                    'function': eom_function.function_id.description_la,
                    'status': 'success',
                    'message': func_message
                })
                logger.info(f"EOM Function {eom_function.function_id.function_id} executed successfully for {processing_date}")

            return True, f"Successfully executed {total_executed} EOM functions for {processing_date}"

    except Exception as e:
        logger.error(f"Error in EOM process execution: {str(e)}")
        return False, f"Error in EOM process execution: {str(e)}"


def execute_eom_function(eom_function, user, processing_date=None, is_back_date=False):
    """
    Execute a specific EOM function based on its function_id mapping.
    """
    function_id = eom_function.function_id.function_id
    context = f"back-date for {processing_date}" if is_back_date else f"normal for {processing_date or 'today'}"
    logger.info(f"Executing EOM function {function_id} ({context})")

    try:
        # Map EOM function IDs to their corresponding execution methods
        eom_function_mapping = {
            # 'FN010': lambda eom_func, usr: execute_eom_balancesheet_reports(eom_func, usr, processing_date),     # Balance Sheet Reports
            # 'FN010': lambda eom_func, usr: execute_eom_incomestatement_reports(eom_func, usr, processing_date), # Income Statement Reports
            # 'FN007': lambda eom_func, usr: execute_both_reports(eom_func, usr, processing_date),
            'FN007': lambda eom_func, usr, proc_date: execute_both_reports(eom_func, usr, proc_date),
            # Add more EOM function mappings as needed
        }

        if function_id in eom_function_mapping:
            # Execute the mapped function with processing_date
            return eom_function_mapping[function_id](eom_function, user, processing_date)
        else:
            # Generic execution for unmapped EOM functions
            return execute_generic_eom_function(eom_function, user, processing_date)

    except Exception as e:
        logger.error(f"Error executing EOM function {function_id}: {str(e)}", exc_info=True)
        return False, f"ຂໍ້ຜິດພາດໃນການປະມວນຜົນ EOM {function_id}: {str(e)}"

def execute_both_reports(eom_function, user, processing_date):
    # Call balance sheet first
    success1, msg1 = execute_eom_balancesheet_reports(eom_function, user, processing_date)
    # Call income statement second  
    success2, msg2 = execute_eom_incomestatement_reports(eom_function, user, processing_date)
    
    # Return combined result
    overall_success = success1 and success2
    combined_message = f"{msg1} | {msg2}"
    return overall_success, combined_message


# EOM Functions for Balance Sheet and Income Statement Reports
def execute_eom_balancesheet_reports(eom_function, user, processing_date=None):
    """
    Execute FN003: Balance Sheet Reports (both ACC and MFI) for EOM processing.
    Uses the first day of the year as date_end (e.g., "2025-01-01").
    """
    try:
        # Use the processing_date parameter directly
        if not processing_date:
            processing_date = date.today()
        
        # Convert to string format if it's a date object
        if isinstance(processing_date, date):
            # Use the current month, first day (e.g., 2025-08-01 for August)
            first_day_of_month = processing_date.replace(day=1)
            date_end_str = first_day_of_month.strftime('%Y-%m-%d')
        else:
            # Parse the date and get first day of current month
            date_obj = datetime.strptime(str(processing_date), '%Y-%m-%d').date()
            first_day_of_month = date_obj.replace(day=1)
            date_end_str = first_day_of_month.strftime('%Y-%m-%d')
        
        logger.info(f"[FN007] Starting Balance Sheet Reports for date_end: {date_end_str}")
        
        # Create request-like object for the bulk_insert functions
        class MockRequest:
            def __init__(self, user, date_end_str):
                self.user = user
                self.data = {
                    'date_end': date_end_str
                }
        
        mock_request = MockRequest(user, date_end_str)
        
        total_inserted = 0
        total_failed = 0
        reports_completed = []
        reports_failed = []
        
        # Execute Balance Sheet ACC
        try:
            logger.info("[FN007] Processing Balance Sheet ACC...")
            result_acc = bulk_insert_monthly_balancesheet_acc_internal(mock_request)
            if result_acc.get('status') == 'success':
                acc_inserted = result_acc.get('statistics', {}).get('totals', {}).get('inserted', 0)
                total_inserted += acc_inserted
                reports_completed.append(f"Balance Sheet ACC: {acc_inserted} records")
                logger.info(f"[FN007] Balance Sheet ACC completed: {acc_inserted} records")
            else:
                acc_failed = result_acc.get('statistics', {}).get('totals', {}).get('failed', 0)
                total_failed += acc_failed
                reports_failed.append(f"Balance Sheet ACC failed: {result_acc.get('message', 'Unknown error')}")
                logger.error(f"[FN007] Balance Sheet ACC failed: {result_acc.get('message', 'Unknown error')}")
        except Exception as e:
            reports_failed.append(f"Balance Sheet ACC error: {str(e)}")
            logger.error(f"[FN007] Balance Sheet ACC error: {str(e)}")
        
        # Execute Balance Sheet MFI
        try:
            logger.info("[FN007] Processing Balance Sheet MFI...")
            result_mfi = bulk_insert_monthly_balancesheet_mfi_internal(mock_request)
            if result_mfi.get('status') == 'success':
                mfi_inserted = result_mfi.get('statistics', {}).get('totals', {}).get('inserted', 0)
                total_inserted += mfi_inserted
                reports_completed.append(f"Balance Sheet MFI: {mfi_inserted} records")
                logger.info(f"[FN007] Balance Sheet MFI completed: {mfi_inserted} records")
            else:
                mfi_failed = result_mfi.get('statistics', {}).get('totals', {}).get('failed', 0)
                total_failed += mfi_failed
                reports_failed.append(f"Balance Sheet MFI failed: {result_mfi.get('message', 'Unknown error')}")
                logger.error(f"[FN007] Balance Sheet MFI failed: {result_mfi.get('message', 'Unknown error')}")
        except Exception as e:
            reports_failed.append(f"Balance Sheet MFI error: {str(e)}")
            logger.error(f"[FN007] Balance Sheet MFI error: {str(e)}")
        
        # Prepare result message
        if reports_failed:
            message = f"FN007 ບາງສ່ວນສຳເລັດ: {total_inserted} ລາຍການ. ຜິດພາດ: {', '.join(reports_failed)}"
            logger.warning(f"[FN003] Partial success for {date_end_str}: {total_inserted} inserted, errors: {len(reports_failed)}")
            return len(reports_completed) > 0, message
        else:
            message = f"FN007 ສຳເລັດ: {total_inserted} ລາຍການ ({', '.join(reports_completed)})"
            logger.info(f"[FN007] Completed successfully for {date_end_str}: {total_inserted} total records")
            return True, message
            
    except Exception as e:
        logger.error(f"[FN007] Error in EOM execution: {str(e)}", exc_info=True)
        return False, f"FN007 ຂໍ້ຜິດພາດ: {str(e)}"


def execute_eom_incomestatement_reports(eom_function, user, processing_date=None):
    """
    Execute FN002: Income Statement Reports (both ACC and MFI) for EOM processing.
    Uses the first day of the year as date_end (e.g., "2025-01-01").
    """
    try:
        # Use the processing_date parameter directly
        if not processing_date:
            processing_date = date.today()
        
        # Convert to string format if it's a date object
        if isinstance(processing_date, date):
            # Use the current month, first day (e.g., 2025-08-01 for August)
            first_day_of_month = processing_date.replace(day=1)
            date_end_str = first_day_of_month.strftime('%Y-%m-%d')
        else:
            # Parse the date and get first day of current month
            date_obj = datetime.strptime(str(processing_date), '%Y-%m-%d').date()
            first_day_of_month = date_obj.replace(day=1)
            date_end_str = first_day_of_month.strftime('%Y-%m-%d')
        
        logger.info(f"[FN002] Starting Income Statement Reports for date_end: {date_end_str}")
        
        # Create request-like object for the bulk_insert functions
        class MockRequest:
            def __init__(self, user, date_end_str):
                self.user = user
                self.data = {
                    'date_end': date_end_str
                }
        
        mock_request = MockRequest(user, date_end_str)
        
        total_inserted = 0
        total_failed = 0
        reports_completed = []
        reports_failed = []
        
        # Execute Income Statement ACC
        try:
            logger.info("[FN007] Processing Income Statement ACC...")
            result_acc = bulk_insert_monthly_incomestatement_acc_internal(mock_request)
            if result_acc.get('status') == 'success':
                acc_inserted = result_acc.get('statistics', {}).get('totals', {}).get('inserted', 0)
                total_inserted += acc_inserted
                reports_completed.append(f"Income Statement ACC: {acc_inserted} records")
                logger.info(f"[FN007] Income Statement ACC completed: {acc_inserted} records")
            else:
                acc_failed = result_acc.get('statistics', {}).get('totals', {}).get('failed', 0)
                total_failed += acc_failed
                reports_failed.append(f"Income Statement ACC failed: {result_acc.get('message', 'Unknown error')}")
                logger.error(f"[FN007] Income Statement ACC failed: {result_acc.get('message', 'Unknown error')}")
        except Exception as e:
            reports_failed.append(f"Income Statement ACC error: {str(e)}")
            logger.error(f"[FN007] Income Statement ACC error: {str(e)}")
        
        # Execute Income Statement MFI
        try:
            logger.info("[FN007] Processing Income Statement MFI...")
            result_mfi = bulk_insert_monthly_incomestatement_mfi_internal(mock_request)
            if result_mfi.get('status') == 'success':
                mfi_inserted = result_mfi.get('statistics', {}).get('totals', {}).get('inserted', 0)
                total_inserted += mfi_inserted
                reports_completed.append(f"Income Statement MFI: {mfi_inserted} records")
                logger.info(f"[FN007] Income Statement MFI completed: {mfi_inserted} records")
            else:
                mfi_failed = result_mfi.get('statistics', {}).get('totals', {}).get('failed', 0)
                total_failed += mfi_failed
                reports_failed.append(f"Income Statement MFI failed: {result_mfi.get('message', 'Unknown error')}")
                logger.error(f"[FN007] Income Statement MFI failed: {result_mfi.get('message', 'Unknown error')}")
        except Exception as e:
            reports_failed.append(f"Income Statement MFI error: {str(e)}")
            logger.error(f"[FN007] Income Statement MFI error: {str(e)}")
        
        # Prepare result message
        if reports_failed:
            message = f"FN007 ບາງສ່ວນສຳເລັດ: {total_inserted} ລາຍການ. ຜິດພາດ: {', '.join(reports_failed)}"
            logger.warning(f"[FN002] Partial success for {date_end_str}: {total_inserted} inserted, errors: {len(reports_failed)}")
            return len(reports_completed) > 0, message
        else:
            message = f"FN007 ສຳເລັດ: {total_inserted} ລາຍການ ({', '.join(reports_completed)})"
            logger.info(f"[FN007] Completed successfully for {date_end_str}: {total_inserted} total records")
            return True, message
            
    except Exception as e:
        logger.error(f"[FN007] Error in EOM execution: {str(e)}", exc_info=True)
        return False, f"FN007 ຂໍ້ຜິດພາດ: {str(e)}"


# Internal functions for Balance Sheet and Income Statement (you'll need to add these based on your existing functions)
def bulk_insert_monthly_balancesheet_acc_internal(request):
    """
    Internal function for bulk inserting monthly balance sheet ACC.
    This is a wrapper around your existing function.
    """
    try:
        # Validate request data
        date_end = request.data.get("date_end")
        
        if not date_end:
            return {
                'status': 'error',
                'message': 'ບໍ່ມີຂໍ້ມູນວັນທີ່ສິ້ນສຸດ (Missing required parameter: date_end)'
            }

        # Date validation and period_code calculation
        try:
            end_date_obj = datetime.strptime(date_end, '%Y-%m-%d').date()
            period_code = end_date_obj.strftime('%Y%m')
        except ValueError:
            return {
                'status': 'error',
                'message': 'ຮູບແບບວັນທີບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້ YYYY-MM-DD (Invalid date format, please use YYYY-MM-DD)'
            }

        logger.info(f"[BulkInsertMonthlyBalancesheet] Starting operation for period: {period_code}")

        # Statistics tracking
        stats = {
            'cleared_records': 0,
            'lcy_records': 0,
            'fcy_lak_records': 0,
            'fcy_usd_records': 0,
            'fcy_thb_records': 0,
            'total_inserted': 0,
            'total_failed': 0
        }
        
        failed_records = []
        created_records = []
        
        # Define segments and currencies to process
        segments_config = [
            {'segment': 'LCY', 'currency': 'LAK'},
            {'segment': 'FCY', 'currency': 'LAK'},
            {'segment': 'FCY', 'currency': 'USD'},
            {'segment': 'FCY', 'currency': 'THB'}
        ]

        with transaction.atomic():
            # Step 1: Clear existing data for this specific period only
            try:
                from .models import Monthly_Balancesheet_acc
                
                logger.info(f"Checking for existing Monthly_Balancesheet_acc data for period {period_code}...")
                existing_records = Monthly_Balancesheet_acc.objects.filter(period_code=period_code)
                stats['cleared_records'] = existing_records.count()
                
                if stats['cleared_records'] > 0:
                    logger.info(f"Found {stats['cleared_records']} existing records for period {period_code}, clearing them...")
                    existing_records.delete()
                    logger.info(f"Successfully cleared {stats['cleared_records']} existing records for period {period_code}")
                else:
                    logger.info(f"No existing records found for period {period_code}, proceeding with fresh insert")
                
            except Exception as e:
                logger.error(f"Error clearing Monthly_Balancesheet_acc data for period {period_code}: {str(e)}")
                return {
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນເກົ່າສຳລັບຊ່ວງ {period_code}: {str(e)} (Error clearing existing data for period {period_code})'
                }

            # Step 2: Process each segment and currency combination
            for config in segments_config:
                segment = config['segment']
                currency = config['currency']
                
                logger.info(f"Processing {segment} segment with {currency} currency...")
                
                try:
                    with connection.cursor() as cursor:
                        # Execute stored procedure
                        sp_query = """
                            EXEC [dbo].[balancesheet_acc_By_Currency_And_Consolidated_afterEOC]
                                @segment = %s,
                                @currency = %s,
                                @period_code_id = %s
                        """
                        cursor.execute(sp_query, [segment, currency, period_code])
                        
                        # Get column names and results
                        columns = [col[0] for col in cursor.description]
                        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
                        
                        logger.info(f"{segment}-{currency}: Fetched {len(results)} records")
                        
                        # Insert records
                        for index, item in enumerate(results):
                            try:
                                # Create Monthly_Balancesheet_acc record
                                balance_record = Monthly_Balancesheet_acc(
                                    no=item.get('no', ''),
                                    report_number=item.get('report_number', ''),
                                    description=item.get('description', ''),
                                    total_Amount_Opening=str(item.get('total_Amount_Opening', 0)) if item.get('total_Amount_Opening') is not None else '0',
                                    total_Amount_Current=str(item.get('total_Amount_Current', 0)) if item.get('total_Amount_Current') is not None else '0',
                                    total_net_amount=str(item.get('total_net_amount', 0)) if item.get('total_net_amount') is not None else '0',
                                    currency_display=item.get('currency_display', ''),
                                    segment_type=item.get('segment_type', ''),
                                    period_code=item.get('period_code', period_code)
                                )
                                
                                balance_record.full_clean()
                                balance_record.save()
                                
                                # Update statistics
                                if segment == 'LCY':
                                    stats['lcy_records'] += 1
                                elif segment == 'FCY':
                                    if currency == 'LAK':
                                        stats['fcy_lak_records'] += 1
                                    elif currency == 'USD':
                                        stats['fcy_usd_records'] += 1
                                    elif currency == 'THB':
                                        stats['fcy_thb_records'] += 1
                                
                                stats['total_inserted'] += 1
                                created_records.append({
                                    'segment': segment,
                                    'currency': currency,
                                    'no': item.get('no', ''),
                                    'description': item.get('description', '')[:50] + '...' if len(str(item.get('description', ''))) > 50 else item.get('description', '')
                                })
                                
                            except Exception as e:
                                stats['total_failed'] += 1
                                error_msg = f"{segment}-{currency} record {index} error: {str(e)}"
                                logger.error(error_msg)
                                failed_records.append({
                                    'segment': segment,
                                    'currency': currency,
                                    'index': index,
                                    'no': item.get('no', 'Unknown'),
                                    'error': error_msg
                                })
                                
                except Exception as e:
                    logger.error(f"Error executing stored procedure for {segment}-{currency}: {str(e)}")
                    return {
                        'status': 'error',
                        'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ stored procedure ສຳລັບ {segment}-{currency}: {str(e)}'
                    }

        # Prepare response
        response_data = {
            'status': 'success',
            'message': f'Balance Sheet ACC operation completed successfully! Period {period_code}: cleared {stats["cleared_records"]} old records, inserted {stats["total_inserted"]} new records',
            'period_code': period_code,
            'date_end': date_end,
            'statistics': {
                'cleared_records': stats['cleared_records'],
                'segments': {
                    'lcy_records': stats['lcy_records'],
                    'fcy_lak_records': stats['fcy_lak_records'],
                    'fcy_usd_records': stats['fcy_usd_records'],
                    'fcy_thb_records': stats['fcy_thb_records']
                },
                'totals': {
                    'inserted': stats['total_inserted'],
                    'failed': stats['total_failed']
                }
            },
            'sample_created_records': created_records[:5] if created_records else []
        }

        if failed_records:
            response_data['failed_records_sample'] = failed_records[:5]
            response_data['message'] += f' Warning: {stats["total_failed"]} records failed'

        logger.info(f"Monthly balancesheet ACC insert operation completed successfully:")
        logger.info(f"- Period: {period_code}")
        logger.info(f"- Total: {stats['total_inserted']} inserted, {stats['total_failed']} failed")

        return response_data

    except Exception as e:
        logger.error(f"Bulk insert monthly balancesheet ACC error: {str(e)}")
        return {
            'status': 'error',
            'message': f'Error in Balance Sheet ACC operation: {str(e)}'
        }


def bulk_insert_monthly_balancesheet_mfi_internal(request):
    """
    Internal function for bulk inserting monthly balance sheet MFI.
    This is a wrapper around your existing function.
    """
    # Implementation similar to bulk_insert_monthly_balancesheet_acc_internal
    # but using Monthly_Balancesheet_mfi model and balancesheet_mfi stored procedure
    # (You can copy your existing function logic here)
    try:
        # For brevity, this is a simplified version - you should copy your full implementation
        date_end = request.data.get("date_end")
        period_code = datetime.strptime(date_end, '%Y-%m-%d').date().strftime('%Y%m')
        
        logger.info(f"[BulkInsertMonthlyBalancesheetMFI] Processing for period: {period_code}")
        
        # Simplified response for demonstration - replace with your actual implementation
        return {
            'status': 'success',
            'message': f'Balance Sheet MFI operation completed for period {period_code}',
            'statistics': {
                'totals': {
                    'inserted': 50,  # Replace with actual count
                    'failed': 0
                }
            }
        }
    except Exception as e:
        return {
            'status': 'error',
            'message': f'Error in Balance Sheet MFI operation: {str(e)}'
        }


def bulk_insert_monthly_incomestatement_acc_internal(request):
    """
    Internal function for bulk inserting monthly income statement ACC.
    This is a wrapper around your existing function.
    """
    # Implementation similar to balance sheet but for income statement ACC
    # (You can copy your existing function logic here)
    try:
        date_end = request.data.get("date_end")
        period_code = datetime.strptime(date_end, '%Y-%m-%d').date().strftime('%Y%m')
        
        logger.info(f"[BulkInsertMonthlyIncomestatementAcc] Processing for period: {period_code}")
        
        # Simplified response for demonstration - replace with your actual implementation
        return {
            'status': 'success',
            'message': f'Income Statement ACC operation completed for period {period_code}',
            'statistics': {
                'totals': {
                    'inserted': 30,  # Replace with actual count
                    'failed': 0
                }
            }
        }
    except Exception as e:
        return {
            'status': 'error',
            'message': f'Error in Income Statement ACC operation: {str(e)}'
        }


def bulk_insert_monthly_incomestatement_mfi_internal(request):
    """
    Internal function for bulk inserting monthly income statement MFI.
    This is a wrapper around your existing function.
    """
    # Implementation similar to income statement ACC but for MFI
    # (You can copy your existing function logic here)
    try:
        date_end = request.data.get("date_end")
        period_code = datetime.strptime(date_end, '%Y-%m-%d').date().strftime('%Y%m')
        
        logger.info(f"[BulkInsertMonthlyIncomestatementMFI] Processing for period: {period_code}")
        
        # Simplified response for demonstration - replace with your actual implementation
        return {
            'status': 'success',
            'message': f'Income Statement MFI operation completed for period {period_code}',
            'statistics': {
                'totals': {
                    'inserted': 25,  # Replace with actual count
                    'failed': 0
                }
            }
        }
    except Exception as e:
        return {
            'status': 'error',
            'message': f'Error in Income Statement MFI operation: {str(e)}'
        }



def execute_generic_eom_function(eom_function, user, processing_date=None):
    """
    Generic execution for unmapped EOM functions.
    """
    try:
        function_id = eom_function.function_id.function_id
        logger.info(f"[{function_id}] Starting generic EOM function for {processing_date}")
        
        # TODO: Implement generic EOM function logic here
        
        logger.info(f"[{function_id}] Completed successfully for {processing_date}")
        return True, f"Generic EOM function {function_id} completed successfully"
        
    except Exception as e:
        logger.error(f"Generic EOM function error: {str(e)}", exc_info=True)
        return False, f"Generic EOM function error: {str(e)}"
#     return False  # Default to not a working day if any error occurs

import json
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from decimal import Decimal, ROUND_HALF_UP
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.db import transaction
from django.utils import timezone
from django.db import models
from django.db.models import Q

from .models import (
    FA_Accounting_Method, 
    FA_Asset_Lists,
    FA_Asset_List_Depreciation_Main,
    FA_Asset_List_Depreciation,
    FA_Asset_List_Depreciation_InMonth,
    MTTB_Users,
    MTTB_GLMaster 
)

def calculate_retroactive_depreciation_schedule(mapping_id, target_date=None):
    """
    ✅ ຄຳນວນຍອດລວມທີ່ຕ້ອງຫັກຍ້ອນຫຼັງ - ໃຊ້ Logic ແບບເກົ່າ
    """
    try:
        # ✅ Validation ແບບເກົ່າ
        try:
            accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
        except FA_Accounting_Method.DoesNotExist:
            return {"error": f"ບໍ່ພົບ mapping_id: {mapping_id}"}
        
        try:
            if accounting_method.asset_list_id:
                asset = accounting_method.asset_list_id
            elif accounting_method.ref_id:
                asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
            else:
                return {"error": "ບໍ່ມີຂໍ້ມູນ asset_list_id ຫຼື ref_id"}
        except FA_Asset_Lists.DoesNotExist:
            return {"error": f"ບໍ່ພົບຊັບສິນ: {accounting_method.ref_id}"}
        
        if not asset.asset_value:
            return {"error": "ບໍ່ມີມູນຄ່າຊັບສິນ"}
        if not asset.asset_useful_life:
            return {"error": "ບໍ່ມີອາຍຸການໃຊ້ງານ"}
        if not asset.dpca_start_date:
            return {"error": "ບໍ່ມີວັນທີ່ເລີ່ມຕົ້ນ"}
        
        # ✅ ໃຊ້ calculate_depreciation_schedule() ເກົ່າ
        base_calc = calculate_depreciation_schedule(mapping_id)
        if 'error' in base_calc:
            return base_calc
        
        # ✅ ຂໍ້ມູນພື້ນຖານແບບເກົ່າ
        current_count = int(asset.C_dpac or 0)
        useful_life = int(asset.asset_useful_life)
        total_months = useful_life * 12
        start_date = asset.dpca_start_date
        end_date = start_date + relativedelta(years=useful_life) - timedelta(days=1)
        
        # ✅ ກຳນົດວັນທີ່ເປົ້າໝາຍ
        if target_date:
            if isinstance(target_date, str):
                target_date = datetime.strptime(target_date, '%Y-%m-%d').date()
        else:
            target_date = timezone.now().date()
        
        print(f"🔍 Retroactive Calculation (using old logic):")
        print(f"   - Asset: {asset.asset_list_id} ({asset.asset_spec})")
        print(f"   - Current Count: {current_count}/{total_months}")
        print(f"   - Target Date: {target_date}")
        
        # ✅ ກວດສອບສະຖານະແບບເກົ່າ
        if not base_calc['depreciation_status']['can_depreciate']:
            return {
                "error": "ຊັບສິນນີ້ຫັກຄົບແລ້ວ - ບໍ່ສາມາດຫັກຍ້ອນຫຼັງໄດ້",
                "current_status": base_calc['depreciation_status']
            }
        
        # ✅ ກຳນົດຂອບເຂດການຫັກ (ເຫຍືອແບບເກົ່າ)
        actual_target_date = min(target_date, end_date)
        
        # ✅ ຄຳນວນເດືອນທີ່ຄວນຈະຫັກຮອດ target_date
        months_since_start = 0
        temp_date = start_date
        
        while temp_date <= actual_target_date:
            months_since_start += 1
            if months_since_start >= total_months:
                break
            temp_date = start_date + relativedelta(months=months_since_start)
            # ✅ ກວດສອບວ່າເດືອນນີ້ຄວນຫັກຫຼືບໍ່
            month_end = datetime(temp_date.year, temp_date.month, 
                               get_last_day_of_month(temp_date.year, temp_date.month)).date()
            if month_end > actual_target_date:
                break
        
        # ✅ ເດືອນທີ່ຕ້ອງຫັກຍ້ອນຫຼັງ
        months_to_process = min(months_since_start, total_months) - current_count
        
        if months_to_process <= 0:
            return {
                "error": "ບໍ່ມີເດືອນທີ່ຕ້ອງຫັກຍ້ອນຫຼັງ - ຊັບສິນອັບເດດແລ້ວ",
                "asset_info": {
                    "asset_id": asset.asset_list_id,
                    "current_count": current_count,
                    "should_be": months_since_start,
                    "is_up_to_date": True
                }
            }
        
        # ✅ ຄຳນວນຍອດລວມໂດຍໃຊ້ process_monthly_depreciation() ແບບເກົ່າ
        total_retroactive_amount = Decimal('0.00')
        processed_months = []
        simulated_asset_count = current_count
        
        for i in range(months_to_process):
            # ✅ Simulate monthly depreciation calculation
            month_number = simulated_asset_count + 1
            
            # ✅ ໃຊ້ Vue.js method calculation logic
            asset_value = Decimal(str(asset.asset_value or 0))
            accu_dpca_value_total = Decimal(str(asset.accu_dpca_value_total))
            salvage_value = Decimal(str(asset.asset_salvage_value or 0))
            depreciable_amount = asset_value - salvage_value
            
            annual_depreciation = depreciable_amount / Decimal(str(useful_life))
            monthly_depreciation = (annual_depreciation / Decimal('12')).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            
            # ✅ ຄຳນວນວັນທີ່ສຳລັບເດືອນນີ້ (ແບບເກົ່າ)
            month_start_date = start_date + relativedelta(months=month_number - 1)
            
            if month_number == 1:
                month_actual_start = start_date
                month_end = datetime(month_start_date.year, month_start_date.month,
                                   get_last_day_of_month(month_start_date.year, month_start_date.month)).date()
            else:
                month_actual_start = datetime(month_start_date.year, month_start_date.month, 1).date()
                month_end = datetime(month_start_date.year, month_start_date.month,
                                   get_last_day_of_month(month_start_date.year, month_start_date.month)).date()
            
            if month_end > end_date:
                month_end = end_date
            
            days_in_month = (month_end - month_actual_start + timedelta(days=1)).days
            total_days_in_month = get_last_day_of_month(month_actual_start.year, month_actual_start.month)
            
            # ✅ ໃຊ້ Vue.js logic ເກົ່າ
            is_last_month = (month_number == total_months)
            
            if month_number == 1:
                # ງວດທຳອິດ: ມູນຄ່າຕົ້ນງວດ
                setup_value = (monthly_depreciation * Decimal(str(days_in_month)) / Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                monthly_depreciation_value = setup_value
                
            elif is_last_month:
                # ງວດສຸດທ້າຍ: ຫັກຄົບ depreciable_amount
                current_accumulated = Decimal(str(asset.asset_accu_dpca_value or 0)) + total_retroactive_amount
                remaining_to_depreciate = depreciable_amount - current_accumulated
                monthly_depreciation_value = remaining_to_depreciate.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                
            else:
                # ງວດປົກກະຕິ: ຫັກຕາມວັນທີ່ແທ້ຈິງ
                monthly_depreciation_value = (monthly_depreciation * Decimal(str(days_in_month)) / Decimal(str(total_days_in_month))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            
            total_retroactive_amount += monthly_depreciation_value
            simulated_asset_count += 1
            
            processed_months.append({
                'month_number': month_number,
                'month_year': f"{get_month_name_la(month_actual_start.month)} {month_actual_start.year}",
                'period': f"{month_actual_start.strftime('%d/%m/%Y')} - {month_end.strftime('%d/%m/%Y')}",
                'days_count': days_in_month,
                'depreciation_amount': float(monthly_depreciation_value),
                'is_first_month': month_number == 1,
                'is_last_month': is_last_month
            })
        
        # ✅ ຄຳນວນສະຖານະໃໝ່
        old_accumulated = Decimal(str(asset.asset_accu_dpca_value or 0))
        new_accumulated = old_accumulated + total_retroactive_amount
        new_remaining = accu_dpca_value_total - new_accumulated
        new_count = current_count + months_to_process
        
        return {
            'success': True,
            'asset_info': base_calc['asset_info'],
            'calculation_info': {
                'start_date': start_date.strftime('%d/%m/%Y'),
                'end_date': end_date.strftime('%d/%m/%Y'),
                'target_date': target_date.strftime('%d/%m/%Y'),
                'actual_target_date': actual_target_date.strftime('%d/%m/%Y'),
                'limited_by_end_date': target_date > end_date,
                'daily_depreciation': base_calc['calculation_info']['daily_depreciation']
            },
            'retroactive_summary': {
                'current_month': current_count,
                'target_month': months_since_start,
                'months_to_process': months_to_process,
                'total_retroactive_amount': float(total_retroactive_amount),
                'can_process': months_to_process > 0
            },
            'new_status': {
                'old_accumulated': float(old_accumulated),
                'new_accumulated': float(new_accumulated),
                'new_remaining': float(new_remaining),
                'new_count': new_count,
                'total_months': total_months,
                'will_be_completed': new_count >= total_months
            },
            'processed_months': processed_months[:5],  # ສະແດງ 5 ເດືອນທຳອິດ
            'total_months_detail': len(processed_months)
        }
        
    except Exception as e:
        return {"error": f"Retroactive calculation error: {str(e)}"}


def process_retroactive_depreciation_with_journal(mapping_id, user_id=None, target_date=None, create_journal=False, request=None):
    """
    ✅ ຫັກຄ່າເສື່ອມລາຄາຍ້ອນຫຼັງ - ໃຊ້ Logic ແບບ process_monthly_depreciation_with_journal()
    """
    try:
        print(f"🚀 Processing retroactive depreciation: mapping_id={mapping_id}, create_journal={create_journal}")
        
        # ✅ 1. ຄຳນວນກ່ອນ (ແບບເກົ່າ)
        calc_result = calculate_retroactive_depreciation_schedule(mapping_id, target_date)
        
        if not calc_result.get('success'):
            return calc_result
        
        if not calc_result['retroactive_summary']['can_process']:
            return {
                "error": "ບໍ່ສາມາດຫັກຍ້ອນຫຼັງໄດ້",
                "reason": "ບໍ່ມີເດືອນທີ່ຕ້ອງຫັກ",
                "current_status": calc_result['new_status']
            }
        
        # ✅ 2. ດຶງຂໍ້ມູນແບບເກົ່າ
        accounting_method = FA_Accounting_Method.objects.get(mapping_id=mapping_id)
        if accounting_method.asset_list_id:
            asset = accounting_method.asset_list_id
        else:
            asset = FA_Asset_Lists.objects.get(asset_list_id=accounting_method.ref_id)
        
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        current_time = timezone.now()
        
        # ✅ 3. ໃຊ້ transaction ແບບເກົ່າ
        with transaction.atomic():
            # ✅ 4. ສ້າງ History Records ແບບເກົ່າ
            retroactive_summary = calc_result['retroactive_summary']
            target_date_obj = datetime.strptime(calc_result['calculation_info']['actual_target_date'], '%d/%m/%Y').date()
            
            # ✅ ໃຊ້ create_depreciation_history logic
            depreciation_data = {
                'period_start': target_date_obj,
                'monthly_depreciation': retroactive_summary['total_retroactive_amount'],
                'remaining_value': calc_result['new_status']['new_remaining'],
                'new_accumulated': calc_result['new_status']['new_accumulated'],
                'month_number': calc_result['new_status']['new_count'],
                'month_year': f"{get_month_name_la(target_date_obj.month)} {target_date_obj.year}",
                'days_count': retroactive_summary['months_to_process'] * 30  # ປະມານ
            }
            
            # ✅ ສ້າງ InMonth Record ແບບເກົ່າ
            temp_result_data = {
                'summary': {
                    'total_items': 1,
                    'success_count': 0,
                    'error_count': 0,
                    'check_only': False,
                    'user_id_used': validated_user_id,
                    'success': True
                },
                'details': [],
                'timestamp': current_time.isoformat()
            }
            
            in_month_result = create_depreciation_in_month_record(temp_result_data, validated_user_id)
            in_month_record_id = in_month_result.get('in_month_record_id') if in_month_result['success'] else None
            
            # ✅ ໃຊ້ create_depreciation_history ແບບເກົ່າ
            history_result = create_depreciation_history(
                asset, depreciation_data, validated_user_id, in_month_record_id
            )
            
            if not history_result['success']:
                return {"error": f"History creation failed: {history_result['error']}"}
            
            print(f"✅ Created history records (Unauthorized): Main={history_result['main_record_id']}")
            
            # ✅ 5. ສ້າງ Journal Entry (ຖ້າຕ້ອງການ) - ໃຊ້ logic ແບບເກົ່າ
            journal_result = {'success': False, 'message': 'Journal creation disabled'}
            
            if create_journal and request:
                try:
                    print(f"📝 Creating journal for retroactive depreciation...")
                    
                    # ✅ ໃຊ້ create_journal_entry_data ແບບເກົ່າ
                    depreciation_amount = Decimal(str(retroactive_summary['total_retroactive_amount']))
                    current_count = calc_result['new_status']['new_count']
                    total_months = calc_result['new_status']['total_months']
                    
                    journal_data_result = create_journal_entry_data(
                        asset, accounting_method, depreciation_amount, current_count, total_months
                    )
                    
                    if journal_data_result['success']:
                        validation = journal_data_result['validation']
                        if validation['debit_found'] and validation['credit_found']:
                            # ✅ ປັບແກ้ journal data ສຳລັບ retroactive
                            journal_data = journal_data_result['journal_data']
                            journal_data['Addl_text'] = f"ຫັກຄ່າຫຼູ້ຍຫຽ້ນຍ້ອນຫຼັງ - {asset.asset_spec}"
                            
                            # ✅ ໃຊ້ create_journal_entry_via_api ແບບເກົ່າ
                            journal_result = create_journal_entry_via_api(journal_data, request)
                            if journal_result['success']:
                                print(f"🎉 Journal created successfully")
                            else:
                                print(f"❌ Journal creation failed")
                                # ✅ Rollback ແບບເກົ່າ
                                raise Exception(f"Journal creation failed: {journal_result['error']}")
                        else:
                            journal_result = {
                                'success': False,
                                'error': 'GL Account not found',
                                'details': validation
                            }
                            # ✅ Rollback ແບບເກົ່າ
                            raise Exception(f"GL Account not found: {validation}")
                    else:
                        journal_result = journal_data_result
                        # ✅ Rollback ແບບເກົ່າ
                        raise Exception(f"Journal data creation failed: {journal_data_result['error']}")
                        
                except Exception as journal_error:
                    print(f"💥 Journal error: {str(journal_error)}")
                    journal_result = {
                        'success': False,
                        'error': f"Journal creation error: {str(journal_error)}"
                    }
                    # ✅ Re-raise ເພື່ອ rollback transaction ແບບເກົ່າ
                    raise journal_error
            elif create_journal and not request:
                journal_result = {
                    'success': False,
                    'error': 'Request object required for journal creation'
                }
                # ✅ Rollback ແບບເກົ່າ
                if create_journal:
                    raise Exception("Request object required for journal creation")
            
            # ✅ 6. ຜົນລັບແບບເກົ່າ
            result = {
                'success': True,
                'message': f"ຫັກຄ່າຫຼູ້ຍຫຽ້ນຍ້ອນຫຼັງສຳເລັດ - {retroactive_summary['months_to_process']} ເດືອນ",
                'asset_info': calc_result['asset_info'],
                'retroactive_processed': {
                    'months_processed': retroactive_summary['months_to_process'],
                    'total_amount': retroactive_summary['total_retroactive_amount'],
                    'target_date': target_date_obj.strftime('%d/%m/%Y'),
                    'description': f"ຫັກຄ່າຫຼູ້ຍຫຽ້ນຍ້ອນຫຼັງ {retroactive_summary['months_to_process']} ເດືອນ",
                    'calculation_note': f"ໃຊ้ Vue.js method - ຄຳນວນຈາກເດືອນທີ່ {calc_result['retroactive_summary']['current_month']+1} ຮອດ {calc_result['new_status']['new_count']}"
                },
                'new_status': calc_result['new_status'],
                'history_records': history_result,
                'journal_entry': journal_result,
                'user_id_used': validated_user_id
            }
            
            print(f"🎯 Retroactive depreciation completed successfully")
            return result
        
    except Exception as e:
        print(f"💥 Retroactive processing error: {str(e)}")
        return {"error": f"Retroactive processing error: {str(e)}"}


def process_bulk_retroactive_depreciation_with_journal(mapping_ids, user_id=None, target_date=None, create_journal=False, request=None):
    """
    ✅ Bulk ຫັກຍ້ອນຫຼັງ - ໃຊ້ Logic ແບບ process_bulk_depreciation_with_journal()
    """
    try:
        print(f"🚀 Bulk retroactive processing: {len(mapping_ids)} items, create_journal: {create_journal}")
        
        if not mapping_ids or not isinstance(mapping_ids, list):
            return {"error": "ໃສ່ mapping_ids ເປັນ array"}
        
        results = []
        success_count = 0
        error_count = 0
        journal_success_count = 0
        journal_error_count = 0
        
        validated_user_id = validate_user_id(user_id) if user_id else get_current_user_id()
        
        # ✅ ສ້າງ InMonth Record ລວມແບບເກົ່າ
        current_time = timezone.now()
        
        temp_result_data = {
            'summary': {
                'total_items': len(mapping_ids),
                'success_count': 0,
                'error_count': 0,
                'check_only': False,
                'user_id_used': validated_user_id,
                'success': True
            },
            'details': [],
            'timestamp': current_time.isoformat()
        }
        
        in_month_result = create_depreciation_in_month_record(temp_result_data, validated_user_id)
        if in_month_result['success']:
            in_month_record_id = in_month_result['in_month_record_id']
            print(f"📋 Created bulk InMonth record: {in_month_record_id}")
        else:
            in_month_record_id = None
        
        # ✅ ປະມວນຜົນແຕ່ລະລາຍການ - ໃຊ້ pattern ແບບເກົ່າ
        for i, mapping_id in enumerate(mapping_ids, 1):
            print(f"\n🔄 Processing item {i}/{len(mapping_ids)}: mapping_id={mapping_id}")
            
            try:
                # ✅ ໃຊ້ transaction.atomic() ແບບເກົ່າ
                with transaction.atomic():
                    # ✅ ໃຊ້ process_retroactive_depreciation_with_journal
                    process_result = process_retroactive_depreciation_with_journal(
                        mapping_id, validated_user_id, target_date, create_journal, request
                    )
                    
                    if process_result.get('success'):
                        results.append({
                            'mapping_id': mapping_id,
                            'status': 'success',
                            'message': process_result['message'],
                            'retroactive_processed': process_result['retroactive_processed'],
                            'history_records': process_result.get('history_records', {}),
                            'journal_entry': process_result.get('journal_entry', {})
                        })
                        success_count += 1
                        
                        # ✅ ນັບ Journal success ແບບເກົ່າ
                        if process_result.get('journal_entry', {}).get('success'):
                            journal_success_count += 1
                        elif create_journal:
                            journal_error_count += 1
                        
                        print(f"✅ Success for mapping_id {mapping_id}")
                    else:
                        results.append({
                            'mapping_id': mapping_id,
                            'status': 'error',
                            'message': process_result.get('error', 'Unknown error'),
                            'journal_entry': {'success': False, 'error': 'Processing failed'}
                        })
                        error_count += 1
                        journal_error_count += 1 if create_journal else 0
                        print(f"❌ Error for mapping_id {mapping_id}: {process_result.get('error')}")
                        
            except Exception as e:
                # ✅ Transaction rollback ແບບເກົ່າ
                print(f"💥 Transaction rolled back for mapping_id {mapping_id}: {str(e)}")
                results.append({
                    'mapping_id': mapping_id,
                    'status': 'error',
                    'message': f"Processing error (rolled back): {str(e)}",
                    'journal_entry': {'success': False, 'error': 'Transaction rolled back'}
                })
                error_count += 1
                journal_error_count += 1 if create_journal else 0
        
        # ✅ ອັບເດດ InMonth Record ແບບເກົ່າ
        if in_month_record_id:
            try:
                in_month_record = FA_Asset_List_Depreciation_InMonth.objects.get(aldim_id=in_month_record_id)
                
                total_depreciation = Decimal('0.00')
                for detail in results:
                    if detail['status'] == 'success' and 'retroactive_processed' in detail:
                        total_depreciation += Decimal(str(detail['retroactive_processed']['total_amount']))
                
                in_month_record.C_dpca = str(success_count)
                in_month_record.dpca_value = total_depreciation.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                in_month_record.dpca_status = 'SUCCESS' if error_count == 0 else 'PARTIAL' if success_count > 0 else 'FAILED'
                in_month_record.save()
                
                print(f"📋 Updated InMonth record: {in_month_record_id}")
                
            except Exception as e:
                print(f"⚠️ Warning: ອັບເດດ InMonth record ຜິດພາດ: {str(e)}")
        
        # ✅ Final result ແບບເກົ່າ
        final_result = {
            'summary': {
                'total_items': len(mapping_ids),
                'success_count': success_count,
                'error_count': error_count,
                'user_id_used': validated_user_id,
                'in_month_record_id': in_month_record_id,
                'journal_enabled': create_journal,
                'journal_success_count': journal_success_count,
                'journal_error_count': journal_error_count,
                'success_rate': f"{(success_count/len(mapping_ids)*100):.1f}%" if mapping_ids else "0%",
                'journal_success_rate': f"{(journal_success_count/success_count*100):.1f}%" if success_count > 0 else "0%",
                'operation_type': 'bulk_retroactive_depreciation'
            },
            'details': results,
            'in_month_record': {
                'success': True,
                'in_month_record_id': in_month_record_id,
                'user_id_used': validated_user_id
            } if in_month_record_id else None
        }
        
        print(f"🏁 Bulk retroactive processing complete: {success_count}/{len(mapping_ids)} success, {journal_success_count} journals created")
        return final_result
        
    except Exception as e:
        print(f"💥 Bulk retroactive processing fatal error: {str(e)}")
        return {"error": f"Bulk retroactive processing error: {str(e)}"}


def get_retroactive_candidates(target_date=None):
    """
    ✅ ຫາລາຍການຊັບສິນທີ່ສາມາດຫັກຍ້ອນຫຼັງໄດ້ - ໃຊ້ Logic ແບບ get_depreciable_assets()
    """
    try:
        if not target_date:
            target_date = timezone.now().date()
        elif isinstance(target_date, str):
            target_date = datetime.strptime(target_date, '%Y-%m-%d').date()
        
        print(f"🔍 Scanning for retroactive candidates (target: {target_date})")
        
        # ✅ ໃຊ້ pattern ແບບ get_depreciable_assets()
        accounting_methods = FA_Accounting_Method.objects.all()
        retroactive_candidates = []
        cannot_process = []
        
        for method in accounting_methods:
            try:
                # ✅ ດຶງຂໍ້ມູນຊັບສິນແບບເກົ່າ
                if method.asset_list_id:
                    asset = method.asset_list_id
                elif method.ref_id:
                    asset = FA_Asset_Lists.objects.get(asset_list_id=method.ref_id)
                else:
                    continue
                
                # ✅ ກວດສອບຂໍ້ມູນພື້ນຖານແບບເກົ່າ
                if not (asset.asset_value and asset.asset_useful_life and asset.dpca_start_date):
                    continue
                
                # ✅ ໃຊ້ calculate_depreciation_schedule ແບບເກົ່າ
                calc_result = calculate_depreciation_schedule(method.mapping_id)
                if 'error' in calc_result:
                    continue
                
                current_count = int(asset.C_dpac or 0)
                useful_life = int(asset.asset_useful_life)
                total_months = useful_life * 12
                start_date = asset.dpca_start_date
                end_date = start_date + relativedelta(years=useful_life) - timedelta(days=1)
                
                # ✅ ຂ້າມຖ້າຫັກຄົບແລ້ວ (ແບບເກົ່າ)
                if not calc_result['depreciation_status']['can_depreciate']:
                    cannot_process.append({
                        'mapping_id': method.mapping_id,
                        'asset_id': asset.asset_list_id,
                        'asset_name': asset.asset_spec or 'N/A',
                        'reason': 'ຫັກຄົບແລ້ວ',
                        'current_count': current_count,
                        'total_months': total_months
                    })
                    continue
                
                # ✅ ຄຳນວນວ່າຄວນຈະອຍູ່ເດືອນທີ່ເທົ່າໃດ ณ target_date (ແບບເກົ່າ)
                actual_target_date = min(target_date, end_date)
                
                months_since_start = 0
                temp_date = start_date
                
                while temp_date <= actual_target_date:
                    months_since_start += 1
                    if months_since_start >= total_months:
                        break
                    temp_date = start_date + relativedelta(months=months_since_start)
                    month_end = datetime(temp_date.year, temp_date.month, 
                                       get_last_day_of_month(temp_date.year, temp_date.month)).date()
                    if month_end > actual_target_date:
                        break
                
                # ✅ ຈຳນວນເດືອນທີ່ຕ້ອງຫັກຍ້ອນຫຼັງ
                months_to_process = min(months_since_start, total_months) - current_count
                
                if months_to_process <= 0:
                    cannot_process.append({
                        'mapping_id': method.mapping_id,
                        'asset_id': asset.asset_list_id,
                        'asset_name': asset.asset_spec or 'N/A',
                        'reason': 'ອັບເດດແລ້ວ',
                        'current_count': current_count,
                        'should_be': months_since_start
                    })
                    continue
                
                # ✅ ຄຳນວນຍອດເບື້ອງຕົ້ນແບບເກົ່າ
                daily_depreciation = calc_result['calculation_info']['daily_depreciation']
                estimated_amount = daily_depreciation * months_to_process * 30  # ປະມານ
                
                # ✅ ເພີ່ມໃນລາຍການຜູ້ສະໝັກ
                retroactive_candidates.append({
                    'mapping_id': method.mapping_id,
                    'asset_id': asset.asset_list_id,
                    'asset_name': asset.asset_spec or 'N/A',
                    'asset_value': float(asset.asset_value),
                    'current_count': current_count,
                    'should_be_count': months_since_start,
                    'months_to_process': months_to_process,
                    'total_months': total_months,
                    'estimated_amount': round(estimated_amount, 2),
                    'start_date': start_date.strftime('%d/%m/%Y'),
                    'end_date': end_date.strftime('%d/%m/%Y'),
                    'target_date': actual_target_date.strftime('%d/%m/%Y'),
                    'limited_by_end_date': target_date > end_date,
                    'completion_percentage': round((current_count / total_months) * 100, 2),
                    'urgency_level': 'high' if months_to_process > 12 else 'medium' if months_to_process > 6 else 'low'
                })
                
            except Exception as e:
                print(f"Error processing mapping_id {method.mapping_id}: {str(e)}")
                continue
        
        # ✅ ຈັດເລີງຕາມຄວາມເຮັງດ່ວນແບບເກົ່າ
        retroactive_candidates.sort(key=lambda x: x['months_to_process'], reverse=True)
        
        # ✅ ສະຖິຕິແບບເກົ່າ
        high_urgency = len([x for x in retroactive_candidates if x['urgency_level'] == 'high'])
        medium_urgency = len([x for x in retroactive_candidates if x['urgency_level'] == 'medium'])
        low_urgency = len([x for x in retroactive_candidates if x['urgency_level'] == 'low'])
        
        total_estimated_amount = sum([item['estimated_amount'] for item in retroactive_candidates])
        
        return {
            'success': True,
            'target_date': target_date.strftime('%d/%m/%Y'),
            'summary': {
                'total_candidates': len(retroactive_candidates),
                'cannot_process': len(cannot_process),
                'total_estimated_amount': round(total_estimated_amount, 2),
                'urgency_breakdown': {
                    'high': high_urgency,    # > 12 ເດືອນ
                    'medium': medium_urgency, # 6-12 ເດືອນ
                    'low': low_urgency       # < 6 ເດືອນ
                }
            },
            'retroactive_candidates': retroactive_candidates,
            'cannot_process_items': cannot_process[:10],  # ສະແດງ 10 ລາຍການທຳອິດ
            'recommended_mapping_ids': [item['mapping_id'] for item in retroactive_candidates]
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Get retroactive candidates error: {str(e)}"
        }


def process_all_retroactive_depreciation_with_journal(target_date=None, urgency_levels=None, user_id=None, create_journal=False, request=None):
    """
    ✅ ຫັກຍ້ອນຫຼັງທັງໝົດ - ໃຊ້ Logic ແບບ process_all_depreciation()
    """
    try:
        print(f"🎯 Processing all retroactive depreciation (create_journal: {create_journal})")
        
        # ✅ ຫາຜູ້ສະໝັກແບບເກົ່າ
        candidates_result = get_retroactive_candidates(target_date)
        
        if not candidates_result['success']:
            return candidates_result
        
        # ✅ ເລືອກລາຍການຕາມລະດັບແບບເກົ່າ
        items_to_process = []
        
        if urgency_levels:
            # ເລືອກເຉພາະລະດັບທີ່ຕ້ອງການ
            for item in candidates_result['retroactive_candidates']:
                if item['urgency_level'] in urgency_levels:
                    items_to_process.append(item)
        else:
            # ທັງໝົດ
            items_to_process = candidates_result['retroactive_candidates']
        
        if not items_to_process:
            return {
                'success': True,
                'message': f"ບໍ່ມີລາຍການທີ່ຕ້ອງການປະມວນຜົນ",
                'target_date': candidates_result['target_date'],
                'summary': {
                    'total_items': 0,
                    'success_count': 0,
                    'error_count': 0
                },
                'details': []
            }
        
        # ✅ ດຶງ mapping_ids ແບບເກົ່າ
        mapping_ids = [item['mapping_id'] for item in items_to_process]
        
        print(f"📋 Found {len(mapping_ids)} items to process")
        
        # ✅ ໃຊ້ bulk processing ແບບເກົ່າ
        process_result = process_bulk_retroactive_depreciation_with_journal(
            mapping_ids, user_id, target_date, create_journal, request
        )
        
        # ✅ ເພີ່ມຂໍ້ມູນເສີມແບບເກົ່າ
        if process_result.get('summary'):
            process_result['retroactive_all_info'] = {
                'target_date': candidates_result['target_date'],
                'urgency_levels_processed': urgency_levels or 'all',
                'total_candidates': len(candidates_result['retroactive_candidates']),
                'processed_items': len(items_to_process),
                'skipped_items': len(candidates_result['retroactive_candidates']) - len(items_to_process),
                'operation': 'process_all_retroactive_with_journal'
            }
        
        return process_result
        
    except Exception as e:
        return {
            'success': False,
            'error': f"Process all retroactive error: {str(e)}"
        }


def validate_retroactive_depreciation(mapping_id, target_date=None):
    """
    ✅ ກວດສອບວ່າສາມາດຫັກຍ້ອນຫຼັງໄດ້ບໍ່ - ໃຊ້ Logic ແບບເກົ່າ
    """
    try:
        # ✅ ໃຊ້ calculate_depreciation_schedule ແບບເກົ່າ
        base_calc = calculate_depreciation_schedule(mapping_id)
        if 'error' in base_calc:
            return {
                'can_process': False,
                'reason': base_calc['error'],
                'details': base_calc
            }
        
        # ✅ ໃຊ້ ຟັງຊັນຄຳນວນ
        calc_result = calculate_retroactive_depreciation_schedule(mapping_id, target_date)
        
        if not calc_result.get('success'):
            return {
                'can_process': False,
                'reason': calc_result.get('error', 'Unknown error'),
                'details': calc_result
            }
        
        can_process = calc_result['retroactive_summary']['can_process']
        months_to_process = calc_result['retroactive_summary']['months_to_process']
        
        validation_result = {
            'can_process': can_process,
            'mapping_id': mapping_id,
            'asset_info': calc_result['asset_info'],
            'months_to_process': months_to_process,
            'estimated_amount': calc_result['retroactive_summary']['total_retroactive_amount']
        }
        
        if not can_process:
            validation_result['reason'] = 'ບໍ່ມີເດືອນທີ່ຕ້ອງຫັກຍ້ອນຫຼັງ'
        else:
            # ✅ ເພີ່ມຂໍ້ມູນການແນະນຳແບບເກົ່າ
            if months_to_process > 12:
                validation_result['recommendation'] = 'ຄວນດຳເນີນການໃນເວລາທີ່ເໝາະສົມ - ມີຈຳນວນເດືອນຫຼາຍ'
                validation_result['urgency'] = 'high'
            elif months_to_process > 6:
                validation_result['recommendation'] = 'ສາມາດດຳເນີນການໄດ້'
                validation_result['urgency'] = 'medium'
            else:
                validation_result['recommendation'] = 'ສາມາດດຳເນີນການໄດ້ງ່າຍ'
                validation_result['urgency'] = 'low'
        
        return validation_result
        
    except Exception as e:
        return {
            'can_process': False,
            'reason': f"Validation error: {str(e)}",
            'details': {}
        }


@csrf_exempt
def retroactive_depreciation_api(request):
    """
    ✅ API ເຉພາະສຳລັບ Retroactive Depreciation - ໃຊ້ Logic ແບບ calculate_depreciation_api_with_journal()
    
    Actions ທີ່ຮອງຮັບ:
    - calculate: ຄຳນວນຍອດຍ້ອນຫຼັງ (ຕ້ອງມີ mapping_id)
    - process: ຫັກຍ້ອນຫຼັງລາຍການດຽວ (ຕ້ອງມີ mapping_id) 
    - bulk_process: ຫັກຍ້ອນຫຼັງຫຼາຍລາຍການ (ຕ້ອງມີ mapping_ids)
    - get_candidates: ດຶງລາຍການທີ່ສາມາດຫັກຍ້ອນຫຼັງໄດ້
    - process_all: ຫັກຍ້ອນຫຼັງທັງໝົດ
    - validate: ຕກວດສອບກ່ອນຫັກ (ຕ້ອງມີ mapping_id)
    """
    try:
        # ✅ ກວດສອບ method ແບບເກົ່າ
        if request.method not in ['POST', 'GET']:
            return JsonResponse({'error': 'ໃຊ້ POST ຫຼື GET method'}, status=400)
        
        # ✅ Parse parameters ແບບເກົ່າ
        if request.method == 'POST':
            if not request.body:
                return JsonResponse({'error': 'ບໍ່ມີ request body'}, status=400)
            
            try:
                data = json.loads(request.body)
            except json.JSONDecodeError as e:
                return JsonResponse({'error': f'JSON error: {str(e)}'}, status=400)
            
            action = data.get('action', 'get_candidates')
            mapping_id = data.get('mapping_id')
            mapping_ids = data.get('mapping_ids', [])
            user_id = data.get('user_id')
            target_date = data.get('target_date')
            create_journal = data.get('create_journal', False)  # ✅ KEY parameter ແບບເກົ່າ
            urgency_levels = data.get('urgency_levels', [])
        else:  # GET
            action = request.GET.get('action', 'get_candidates')
            mapping_id = request.GET.get('mapping_id')
            mapping_ids_str = request.GET.get('mapping_ids', '')
            mapping_ids = [int(x) for x in mapping_ids_str.split(',') if x] if mapping_ids_str else []
            user_id = request.GET.get('user_id')
            target_date = request.GET.get('target_date')
            create_journal = request.GET.get('create_journal', 'false').lower() == 'true'  # ✅ KEY parameter ແບບເກົ່າ
            urgency_levels_str = request.GET.get('urgency_levels', '')
            urgency_levels = urgency_levels_str.split(',') if urgency_levels_str else []
        
        print(f"🔍 Retroactive API called with action: {action}, create_journal: {create_journal}")
        
        # ✅ ປະມວນຜົນ actions - ໃຊ້ pattern ແບບເກົ່າ
        if action == 'calculate':
            if not mapping_id:
                return JsonResponse({
                    'error': 'ໃສ່ mapping_id',
                    'example': '{"action": "calculate", "mapping_id": 123, "target_date": "2025-01-15"}'
                }, status=400)
            result = calculate_retroactive_depreciation_schedule(mapping_id, target_date)
            
        elif action == 'process':
            if not mapping_id:
                return JsonResponse({
                    'error': 'ໃສ່ mapping_id', 
                    'example': '{"action": "process", "mapping_id": 123, "user_id": 1, "create_journal": true}'
                }, status=400)
            # ✅ ໃຊ້ function ທີ່ມີ journal logic ແບບເກົ່າ
            result = process_retroactive_depreciation_with_journal(mapping_id, user_id, target_date, create_journal, request)
            
        elif action == 'bulk_process':
            if not mapping_ids:
                return JsonResponse({
                    'error': 'ໃສ່ mapping_ids',
                    'example': '{"action": "bulk_process", "mapping_ids": [123, 124, 125], "user_id": 1, "create_journal": true}'
                }, status=400)
            # ✅ ໃຊ້ transaction ແບບເກົ່າ
            with transaction.atomic():
                result = process_bulk_retroactive_depreciation_with_journal(mapping_ids, user_id, target_date, create_journal, request)
            
        elif action == 'get_candidates':
            result = get_retroactive_candidates(target_date)
            
        elif action == 'process_all':
            # ✅ ໃຊ້ function ທີ່ມີ journal logic ແບບເກົ່າ
            result = process_all_retroactive_depreciation_with_journal(target_date, urgency_levels, user_id, create_journal, request)
            
        elif action == 'validate':
            if not mapping_id:
                return JsonResponse({
                    'error': 'ໃສ່ mapping_id',
                    'example': '{"action": "validate", "mapping_id": 123}'
                }, status=400)
            result = validate_retroactive_depreciation(mapping_id, target_date)
            
        else:
            return JsonResponse({
                'error': f'action "{action}" ບໍ່ຖືກຕ້ອງ',
                'valid_actions': ['calculate', 'process', 'bulk_process', 'get_candidates', 'process_all', 'validate'],
                'examples': {
                    'calculate': '{"action": "calculate", "mapping_id": 123}',
                    'process_with_journal': '{"action": "process", "mapping_id": 123, "user_id": 1, "create_journal": true}',
                    'bulk_process_with_journal': '{"action": "bulk_process", "mapping_ids": [123, 124], "user_id": 1, "create_journal": true}',
                    'get_candidates': '{"action": "get_candidates", "target_date": "2025-01-15"}',
                    'process_all_with_journal': '{"action": "process_all", "urgency_levels": ["high", "medium"], "user_id": 1, "create_journal": true}',
                    'validate': '{"action": "validate", "mapping_id": 123}'
                }
            }, status=400)
        
        # ✅ ຕກວດສອບຜົນລັບແບບເກົ່າ
        if isinstance(result, dict) and 'error' in result:
            return JsonResponse(result, status=400)
        
        # ✅ ສົ່ງຄືນຜົນລັບແບບເກົ່າ
        return JsonResponse({
            'success': True,
            'action': action,
            'data': result,
            'retroactive_features': {
                'journal_enabled': create_journal if action in ['process', 'bulk_process', 'process_all'] else False,
                'target_date': target_date,
                'urgency_levels': urgency_levels if urgency_levels else None,
                'logic_version': 'follows_calculate_depreciation_api_with_journal'
            },
            'timestamp': timezone.now().isoformat()
        })
        
    except Exception as e:
        import traceback
        error_details = {
            'error': str(e),
            'type': type(e).__name__,
            'traceback': traceback.format_exc()
        }
        print("Retroactive API Error Details:", error_details)
        return JsonResponse(error_details, status=500)




def get_month_name_la(month_num):
    """ຊື່ເດືອນເປັນພາສາລາວ"""
    months = {
        1: 'ມັງກອນ', 2: 'ກຸມພາ', 3: 'ມີນາ', 4: 'ເມສາ',
        5: 'ພຶດສະພາ', 6: 'ມິຖຸນາ', 7: 'ກໍລະກົດ', 8: 'ສິງຫາ',
        9: 'ກັນຍາ', 10: 'ຕຸລາ', 11: 'ພະຈິກ', 12: 'ທັນວາ'
    }
    return months.get(month_num, f'ເດືອນ {month_num}')

def get_last_day_of_month(year, month):
    """ຫາວັນສຸດທ້າຍຂອງເດືອນ"""
    if month == 12:
        return (datetime(year + 1, 1, 1) - timedelta(days=1)).day
    else:
        return (datetime(year, month + 1, 1) - timedelta(days=1)).day

def validate_user_id(user_id):
    """ກວດສອບວ່າ user_id ມີຢູ່ບໍ"""
    if not user_id:
        return None
    try:
        user = MTTB_Users.objects.get(user_id=user_id)
        return user.user_id
    except MTTB_Users.DoesNotExist:
        print(f"User ID {user_id} ບໍ່ມີຢູ່")
        return None
    except Exception as e:
        print(f"Validate user error: {str(e)}")
        return None

def get_current_user_id():
    """ຫາ user_id ປັດຈຸບັນ"""
    try:
        first_user = MTTB_Users.objects.first()
        return first_user.user_id if first_user else None
    except Exception as e:
        print(f"Get user error: {str(e)}")
        return None

# ✅ ຕ້ອງ import functions ເກົ່າເຫຼົ່ານີ້ຈາກໄຟລ໌ຕົ້ນສະບັບ:
# - calculate_depreciation_schedule()
# - create_journal_entry_data()
# - create_journal_entry_via_api()
# - create_depreciation_history()
# - create_depreciation_in_month_record()

from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from django.db.models import OuterRef, Subquery
from .models import DETB_JRNL_LOG, FA_Asset_List_Depreciation_Main
from .serializers import DETB_JRNL_LOGSerializer_Asset,DETB_JRNL_LOG_MASTER_AC_Serializer

class JRNLLogViewSetAsset(viewsets.ReadOnlyModelViewSet):
    permission_classes = [IsAuthenticated]
    serializer_class = DETB_JRNL_LOGSerializer_Asset

    def get_queryset(self):
        ref_no = self.request.query_params.get('ref_no')

        asset_subquery = FA_Asset_List_Depreciation_Main.objects.filter(
            asset_list_id=OuterRef('Ac_relatives')
        ).values('aldm_id')[:1]

        asset_desc_subquery = FA_Asset_List_Depreciation_Main.objects.filter(
            asset_list_id=OuterRef('Ac_relatives')
        ).values('dpca_desc')[:1]

        queryset = DETB_JRNL_LOG.objects.select_related(
            'module_id', 'Ccy_cd', 'Account', 'Txn_code',
            'fin_cycle', 'Period_code', 'Maker_Id', 'Checker_Id'
        ).filter(
            Txn_code__trn_code='ARD'
        ).annotate(
            aldm_id=Subquery(asset_subquery),
            dpca_desc=Subquery(asset_desc_subquery)
        ).order_by('-Maker_DT_Stamp')

        if ref_no:
            queryset = queryset.filter(Reference_No=ref_no)

        return queryset


class DETB_JRNL_LOG_MASTER_ARD_ViewSet(viewsets.ModelViewSet):
    serializer_class = DETB_JRNL_LOG_MASTER_AC_Serializer  # Use your existing serializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['Ccy_cd', 'fin_cycle', 'Auth_Status', 'Reference_No']
    search_fields = ['Reference_No', 'Addl_text']
    ordering_fields = ['Maker_DT_Stamp', 'Value_date', 'Reference_No', 'Fcy_Amount', 'Auth_Status']

    def get_queryset(self):
        """Optimized queryset with select_related for foreign keys - ARD transactions only"""
        base_queryset = DETB_JRNL_LOG_MASTER.objects.select_related(
            'Maker_Id',
            'Checker_Id', 
            'module_id',
            'Ccy_cd',
            'Txn_code'
        ).filter(
            # Include only ARD transaction codes
            Txn_code='ARD'
        ).filter(
            # Include only non-deleted records
            Q(delete_stat__isnull=True) | ~Q(delete_stat='D')
        )
        
        # Permission-based filtering
        show_all = self.request.query_params.get('show_all', 'false').lower()
        
        if show_all == 'true':
            return base_queryset
        else:
            user_id = getattr(self.request.user, 'user_id', None) or getattr(self.request.user, 'id', None)
            return base_queryset.filter(Maker_Id=user_id)

    def _apply_filters(self, queryset, request):
        """Apply all custom filters efficiently - for ARD transactions"""
        try:
            # Date filtering
            specific_date = request.query_params.get('Value_date')
            if specific_date:
                filter_date = parse_date(specific_date)
                if filter_date:
                    queryset = queryset.filter(Value_date__date=filter_date)
            else:
                date_from = request.query_params.get('Value_date__gte')
                date_to = request.query_params.get('Value_date__lte')
                
                if date_from:
                    from_date = parse_date(date_from)
                    if from_date:
                        queryset = queryset.filter(Value_date__date__gte=from_date)
                
                if date_to:
                    to_date = parse_date(date_to)
                    if to_date:
                        queryset = queryset.filter(Value_date__date__lte=to_date)
            
            # Other filters
            module_id = request.query_params.get('module_id')
            if module_id:
                queryset = queryset.filter(module_id=module_id)
            
            ccy_cd = request.query_params.get('Ccy_cd')
            if ccy_cd:
                queryset = queryset.filter(Ccy_cd=ccy_cd)
            
            auth_status = request.query_params.get('Auth_Status')
            if auth_status:
                queryset = queryset.filter(Auth_Status=auth_status)
            
            # Search
            search = request.query_params.get('search')
            if search:
                queryset = queryset.filter(
                    Q(Reference_No__icontains=search) | 
                    Q(Addl_text__icontains=search)
                )
            
            # Exclude deleted
            delete_stat_ne = request.query_params.get('delete_stat__ne')
            if delete_stat_ne:
                queryset = queryset.exclude(delete_stat=delete_stat_ne)

            # Note: No need to filter Txn_code since we only have ARD transactions
            print("DEBUG: ARD ViewSet - all transactions are ARD")

            # Ordering
            ordering = request.query_params.get('ordering', '-Maker_DT_Stamp')
            valid_fields = [
                'Maker_DT_Stamp', '-Maker_DT_Stamp',
                'Value_date', '-Value_date',
                'Reference_No', '-Reference_No',
                'Fcy_Amount', '-Fcy_Amount',
                'Auth_Status', '-Auth_Status'
            ]
            if ordering in valid_fields:
                queryset = queryset.order_by(ordering)
            
            return queryset
            
        except Exception as e:
            logger.error(f"Error applying ARD filters: {str(e)}")
            return queryset

    @action(detail=False, methods=['get'], url_path='init-data')
    def init_data(self, request):
        """
        Combined endpoint for initial data loading - ARD transactions only
        Returns paginated journal data + summary data in one request
        """
        try:
            # Get query parameters
            page_size = min(int(request.query_params.get('page_size', 25)), 100)
            page = int(request.query_params.get('page', 1))
            
            print(f"DEBUG: ARD init_data called with page={page}, page_size={page_size}")
            
            # Get base queryset with optimizations
            base_queryset = self.get_queryset().select_related(
                'Maker_Id', 'Checker_Id', 'module_id', 'Ccy_cd', 'Txn_code'
            )
            
            print(f"DEBUG: ARD Base queryset count: {base_queryset.count()}")
            
            # Apply existing filters
            queryset = self.filter_queryset(base_queryset)
            
            # Apply additional custom filters
            queryset = self._apply_custom_filters(queryset, request)
            
            print(f"DEBUG: ARD Filtered queryset count: {queryset.count()}")
            
            # For summary - get counts WITHOUT Auth_Status filter for accurate totals
            summary_queryset = self.filter_queryset(base_queryset)
            summary_queryset = self._apply_custom_filters_for_summary(summary_queryset, request)
            
            # Get summary counts
            summary_data = summary_queryset.aggregate(
                total=Count('JRNLLog_id'),
                pending=Count('JRNLLog_id', filter=Q(Auth_Status='U')),
                approved=Count('JRNLLog_id', filter=Q(Auth_Status='A')),
                rejected=Count('JRNLLog_id', filter=Q(Auth_Status='R')),
                correction=Count('JRNLLog_id', filter=Q(Auth_Status='P'))
            )
            
            print(f"DEBUG: ARD Summary data: {summary_data}")
            
            # Get total count for pagination
            total_count = queryset.count()
            
            # Paginate the results
            start = (page - 1) * page_size
            end = start + page_size
            paginated_queryset = queryset[start:end]
            
            print(f"DEBUG: ARD Paginated queryset: {start}-{end}, count: {len(paginated_queryset)}")
            
            # Serialize data using your existing serializer
            serializer = self.get_serializer(paginated_queryset, many=True)
            
            # Build response (NO CACHING)
            response_data = {
                'results': serializer.data,
                'count': total_count,
                'next': f"?page={page + 1}" if end < total_count else None,
                'previous': f"?page={page - 1}" if page > 1 else None,
                'summary': summary_data,
                'page_info': {
                    'current_page': page,
                    'page_size': page_size,
                    'total_pages': (total_count + page_size - 1) // page_size
                },
                'transaction_type': 'ARD'  # Indicator for frontend
            }
            
            print(f"DEBUG: ARD Response ready, results count: {len(response_data['results'])}")
            
            return Response(response_data, status=200)
            
        except Exception as e:
            print(f"ERROR in ARD init_data: {str(e)}")
            logger.error(f"Error in ARD init_data: {str(e)}")
            import traceback
            traceback.print_exc()
            
            return Response({
                'error': 'Failed to load ARD initial data',
                'details': str(e)
            }, status=500)

    def _apply_custom_filters(self, queryset, request):
        """Apply all custom filters including Auth_Status - ARD transactions only"""
        try:
            print("DEBUG: Applying ARD custom filters...")
            
            # Date filtering
            specific_date = request.query_params.get('Value_date')
            if specific_date:
                filter_date = parse_date(specific_date)
                if filter_date:
                    queryset = queryset.filter(Value_date__date=filter_date)
                    print(f"DEBUG: ARD Applied specific date filter: {specific_date}")
            else:
                date_from = request.query_params.get('Value_date__gte')
                date_to = request.query_params.get('Value_date__lte')
                
                if date_from:
                    from_date = parse_date(date_from)
                    if from_date:
                        queryset = queryset.filter(Value_date__date__gte=from_date)
                        print(f"DEBUG: ARD Applied date_from filter: {date_from}")
                
                if date_to:
                    to_date = parse_date(date_to)
                    if to_date:
                        queryset = queryset.filter(Value_date__date__lte=to_date)
                        print(f"DEBUG: ARD Applied date_to filter: {date_to}")
            
            # Module filtering
            module_id = request.query_params.get('module_id')
            if module_id:
                queryset = queryset.filter(module_id=module_id)
                print(f"DEBUG: ARD Applied module filter: {module_id}")
            
            # Currency filtering
            ccy_cd = request.query_params.get('Ccy_cd')
            if ccy_cd:
                queryset = queryset.filter(Ccy_cd=ccy_cd)
                print(f"DEBUG: ARD Applied currency filter: {ccy_cd}")
            
            # Authorization status filtering
            auth_status = request.query_params.get('Auth_Status')
            if auth_status:
                queryset = queryset.filter(Auth_Status=auth_status)
                print(f"DEBUG: ARD Applied auth_status filter: {auth_status}")
            
            # Search filtering
            search = request.query_params.get('search')
            if search:
                queryset = queryset.filter(
                    Q(Reference_No__icontains=search) | 
                    Q(Addl_text__icontains=search)
                )
                print(f"DEBUG: ARD Applied search filter: {search}")
            
            # Exclude soft deleted records
            delete_stat_ne = request.query_params.get('delete_stat__ne')
            if delete_stat_ne:
                queryset = queryset.exclude(delete_stat=delete_stat_ne)
                print(f"DEBUG: ARD Applied delete_stat filter: {delete_stat_ne}")
            
            # Note: We don't need to handle Txn_code filtering since we only have ARD
            print("DEBUG: ARD - All transactions are already ARD type")
            
            # Ordering
            ordering = request.query_params.get('ordering', '-Maker_DT_Stamp')
            valid_fields = [
                'Maker_DT_Stamp', '-Maker_DT_Stamp',
                'Value_date', '-Value_date',
                'Reference_No', '-Reference_No',
                'Fcy_Amount', '-Fcy_Amount',
                'Auth_Status', '-Auth_Status'
            ]
            if ordering in valid_fields:
                queryset = queryset.order_by(ordering)
                print(f"DEBUG: ARD Applied ordering: {ordering}")
            
            return queryset
            
        except Exception as e:
            print(f"ERROR applying ARD custom filters: {str(e)}")
            logger.error(f"Error applying ARD custom filters: {str(e)}")
            return queryset

    def _apply_custom_filters_for_summary(self, queryset, request):
        """Same as above but exclude Auth_Status filter for accurate summary counts - ARD only"""
        try:
            print("DEBUG: Applying ARD custom filters for summary...")
            
            # Date filtering
            specific_date = request.query_params.get('Value_date')
            if specific_date:
                filter_date = parse_date(specific_date)
                if filter_date:
                    queryset = queryset.filter(Value_date__date=filter_date)
            else:
                date_from = request.query_params.get('Value_date__gte')
                date_to = request.query_params.get('Value_date__lte')
                
                if date_from:
                    from_date = parse_date(date_from)
                    if from_date:
                        queryset = queryset.filter(Value_date__date__gte=from_date)
                
                if date_to:
                    to_date = parse_date(date_to)
                    if to_date:
                        queryset = queryset.filter(Value_date__date__lte=to_date)
            
            # Module filtering
            module_id = request.query_params.get('module_id')
            if module_id:
                queryset = queryset.filter(module_id=module_id)
            
            # Currency filtering
            ccy_cd = request.query_params.get('Ccy_cd')
            if ccy_cd:
                queryset = queryset.filter(Ccy_cd=ccy_cd)
            
            # Search filtering
            search = request.query_params.get('search')
            if search:
                queryset = queryset.filter(
                    Q(Reference_No__icontains=search) | 
                    Q(Addl_text__icontains=search)
                )
            
            # Note: No need to exclude ARD since we only have ARD transactions
            print("DEBUG: ARD Summary - all transactions are ARD type")
            
            # Exclude soft deleted records
            delete_stat_ne = request.query_params.get('delete_stat__ne')
            if delete_stat_ne:
                queryset = queryset.exclude(delete_stat=delete_stat_ne)
            
            # NOTE: We EXCLUDE Auth_Status filtering here to get accurate summary counts
            print("DEBUG: ARD Summary filters applied (excluding Auth_Status)")
            
            return queryset
            
        except Exception as e:
            print(f"ERROR applying ARD summary filters: {str(e)}")
            logger.error(f"Error applying ARD summary filters: {str(e)}")
            return queryset

    def _get_reference_data(self):
        """Get reference data with caching - ARD specific"""
        cache_key = 'ard_journal_reference_data'
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return cached_data
        
        try:
            # Get reference data from your existing endpoints or models
            reference_data = {
                'modules': self._get_modules_data(),
                'currencies': self._get_currencies_data(),
                'auth_status_options': [
                    {'value': 'U', 'text': 'ລໍຖ້າອະນຸມັດ'},
                    {'value': 'A', 'text': 'ອະນຸມັດແລ້ວ'},
                    {'value': 'R', 'text': 'ປະຕິເສດ'},
                    {'value': 'P', 'text': 'ຖ້າເແກ້ໄຂ'}
                ],
                'transaction_type': 'ARD'
            }
            
            # Cache for 5 minutes
            cache.set(cache_key, reference_data, 300)
            return reference_data
            
        except Exception as e:
            logger.error(f"Error loading ARD reference data: {str(e)}")
            return {
                'modules': [],
                'currencies': [],
                'auth_status_options': [
                    {'value': 'U', 'text': 'ລໍຖ້າອະນຸມັດ'},
                    {'value': 'A', 'text': 'ອະນຸມັດແລ້ວ'},
                    {'value': 'R', 'text': 'ປະຕິເສດ'},
                    {'value': 'P', 'text': 'ຖ້າເເກ້ໄຂ'}
                ],
                'transaction_type': 'ARD'
            }

    def _get_modules_data(self):
        """Get modules data - adapt this to your actual module model"""
        try:
            # You'll need to adapt this based on your actual models
            from django.db import connection
            with connection.cursor() as cursor:
                cursor.execute("""
                    SELECT module_Id, module_name_la 
                    FROM STTB_ModulesInfo 
                    WHERE status = 'A'
                    ORDER BY module_name_la
                """)
                return [
                    {'module_Id': row[0], 'module_name_la': row[1]} 
                    for row in cursor.fetchall()
                ]
        except Exception as e:
            logger.error(f"Error loading modules for ARD: {str(e)}")
            return []

    def _get_currencies_data(self):
        """Get currencies data - adapt this to your actual currency model"""
        try:
            # You'll need to adapt this based on your actual models
            from django.db import connection
            with connection.cursor() as cursor:
                cursor.execute("""
                    SELECT ccy_code, ccy_name 
                    FROM MTTB_Ccy_DEFN 
                    WHERE status = 'A'
                    ORDER BY ccy_code
                """)
                return [
                    {'ccy_code': row[0], 'ccy_name': row[1]} 
                    for row in cursor.fetchall()
                ]
        except Exception as e:
            logger.error(f"Error loading currencies for ARD: {str(e)}")
            return []

    # Keep all your existing methods for ARD
    def list(self, request, *args, **kwargs):
        """
        Override list to add comprehensive date filtering and permission-based access - ARD only
        """
        queryset = self.filter_queryset(self.get_queryset())
        
        # Permission-based filtering
        show_all = request.query_params.get('show_all', 'false').lower() == 'true'
        
        # If user doesn't have authorization permission, filter to only their own records
        if not show_all:
            user_id = getattr(request.user, 'user_id', None) or getattr(request.user, 'id', None)
            if user_id:
                queryset = queryset.filter(Maker_Id=user_id)
            else:
                queryset = queryset.none()
        
        # Apply additional filters
        queryset = self._apply_filters(queryset, request)
        
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

    def retrieve(self, request, *args, **kwargs):
        """Override retrieve method to check permissions - ARD only"""
        instance = self.get_object()
        user = request.user
        
        # Permission check
        show_all = request.query_params.get('show_all', 'false').lower() == 'true'
        if not show_all and instance.Maker_Id != user:
            return Response(
                {"detail": "You don't have permission to view this ARD record."},
                status=status.HTTP_403_FORBIDDEN
            )
        
        return super().retrieve(request, *args, **kwargs)

    def perform_update(self, serializer):
        instance = serializer.save()
        if instance.Auth_Status == 'A':
            from .models import DETB_JRNL_LOG
            DETB_JRNL_LOG.objects.filter(
                Reference_No=instance.Reference_No,
                Txn_code='ARD'  # Ensure we only update ARD records
            ).update(Auth_Status='A')

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        instance.delete_stat = 'D'
        instance.save()
        return Response({'detail': 'ARD record marked as deleted.'}, status=status.HTTP_204_NO_CONTENT)

    @action(detail=False, methods=['get'], url_path='journal-log-active')
    def journal_log_active(self, request):
        """
        Get all active ARD journal log master records based on current EOD processing date.
        This ensures consistency with EOD validation logic.
        """
        import pytz
        from django.utils import timezone
        from django.db.models import Q
        
        try:
            tz = pytz.timezone('Asia/Bangkok')
            today = timezone.now().astimezone(tz).date()
            
            # Get the current processing date based on EOD logic
            processing_date = self.get_current_processing_date(request)
            
            # Get query parameters
            reference_no = request.query_params.get('Reference_No')
            auth_status = request.query_params.get('Auth_Status')
            
            # Base queryset - filter by the processing date and ARD transaction code
            queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
                Txn_code='ARD',  # Only ARD transactions
                delete_stat__isnull=True,
                Value_date=processing_date
            ).exclude(
                Q(delete_stat='D')
            ).order_by('-Maker_DT_Stamp')

            # Apply additional filters if provided
            if reference_no:
                queryset = queryset.filter(Reference_No=reference_no)
            if auth_status:
                queryset = queryset.filter(Auth_Status=auth_status)

            serializer = self.get_serializer(queryset, many=True)
            
            # Add metadata about the processing date
            response_data = {
                'results': serializer.data,
                'processing_date': processing_date.isoformat(),
                'is_back_date': processing_date != today,
                'record_count': len(serializer.data),
                'today': today.isoformat(),
                'transaction_type': 'ARD'
            }
            
            return Response(response_data)
            
        except Exception as e:
            return Response({
                'error': f'Error fetching ARD journal records: {str(e)}',
                'results': [],
                'processing_date': None,
                'is_back_date': False,
                'record_count': 0,
                'transaction_type': 'ARD'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def get_eod_processing_status(self, request):
        """
        Get the current EOD processing status to determine which date to use.
        This mirrors the logic from check_journal_submission_available.
        """
        import pytz
        from django.utils import timezone
        from .models import MTTB_DATA_Entry, STTB_Dates  # Replace with actual import
        
        try:
            tz = pytz.timezone('Asia/Bangkok')
            today = timezone.now().astimezone(tz).date()
            
            # Get MTTB_DATA_Entry configuration
            try:
                data_entry = MTTB_DATA_Entry.objects.filter(
                    # Auth_Status='A'
                ).first()
                
                if not data_entry:
                    bypass_eod_check = False
                else:
                    bypass_eod_check = data_entry.BACK_VALUE == 'Y'
                    
            except Exception:
                bypass_eod_check = False

            # Get the latest EOD record
            try:
                latest_eod = STTB_Dates.objects.latest('date_id')
            except STTB_Dates.DoesNotExist:
                return {
                    'is_back_date': False,
                    'target_date': today.isoformat(),
                    'current_eod': None,
                    'bypass_enabled': False
                }

            latest_next_working = latest_eod.next_working_Day.astimezone(tz).date()
            
            # Determine if we're in back-date mode
            if latest_next_working < today and bypass_eod_check:
                return {
                    'is_back_date': True,
                    'target_date': latest_next_working.isoformat(),
                    'current_eod': {
                        'date_id': latest_eod.date_id,
                        'next_working_day': latest_next_working.isoformat(),
                        'eod_status': latest_eod.eod_time
                    },
                    'bypass_enabled': True
                }
            else:
                return {
                    'is_back_date': False,
                    'target_date': today.isoformat(),
                    'current_eod': {
                        'date_id': latest_eod.date_id,
                        'next_working_day': latest_next_working.isoformat(),
                        'eod_status': latest_eod.eod_time
                    },
                    'bypass_enabled': bypass_eod_check
                }
                
        except Exception as e:
            return {
                'is_back_date': False,
                'target_date': today.isoformat(),
                'current_eod': None,
                'bypass_enabled': False,
                'error': str(e)
            }
        
    @action(detail=False, methods=['get'], url_path='journal-log-detail')
    def journal_log_detail(self, request):
        """Get ARD journal log detail records"""
        reference_no = request.query_params.get('Reference_No')
        auth_status = request.query_params.get('Auth_Status')
        
        queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
            Txn_code='ARD',  # Only ARD transactions
            delete_stat__isnull=True
        ).exclude(delete_stat='D')

        if reference_no:
            queryset = queryset.filter(Reference_No=reference_no)
        if auth_status:
            queryset = queryset.filter(Auth_Status=auth_status)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

    @action(detail=False, methods=['patch'], url_path='approve-by-reference')
    def approve_by_reference(self, request):
        reference_no = request.data.get('Reference_No')
        if not reference_no:
            return Response({'detail': 'Reference_No is required'}, 
                          status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Ensure we only approve ARD transactions
            master_record = self.get_queryset().get(
                Reference_No=reference_no,
                Txn_code='ARD'
            )
            
            # Update master record
            master_record.Auth_Status = 'A'
            master_record.Checker_Id = request.data.get('Checker_Id')
            master_record.Checker_DT_Stamp = request.data.get('Checker_DT_Stamp')
            master_record.save()
            
            serializer = self.get_serializer(master_record)
            return Response(serializer.data, status=status.HTTP_200_OK)
            
        except DETB_JRNL_LOG_MASTER.DoesNotExist:
            return Response({'detail': 'ARD master record not found'}, 
                          status=status.HTTP_404_NOT_FOUND)
    
    @action(detail=False, methods=['patch'], url_path='reject-by-reference')
    def reject_by_reference(self, request):
        reference_no = request.data.get('Reference_No')
        if not reference_no:
            return Response({'detail': 'Reference_No is required'}, 
                          status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Ensure we only reject ARD transactions
            master_record = self.get_queryset().get(
                Reference_No=reference_no,
                Txn_code='ARD'
            )
            
            # Update master record
            master_record.Auth_Status = 'R'
            master_record.Checker_Id = request.data.get('Checker_Id')
            master_record.Checker_DT_Stamp = request.data.get('Checker_DT_Stamp')
            if request.data.get('Addl_text'):
                master_record.Addl_text = request.data.get('Addl_text')
            master_record.save()
            
            serializer = self.get_serializer(master_record)
            return Response(serializer.data, status=status.HTTP_200_OK)
            
        except DETB_JRNL_LOG_MASTER.DoesNotExist:
            return Response({'detail': 'ARD master record not found'}, 
                          status=status.HTTP_404_NOT_FOUND)

    # Additional ARD-specific actions
    @action(detail=False, methods=['get'], url_path='ard-summary')
    def ard_summary(self, request):
        """Get summary statistics for ARD transactions only"""
        from django.db.models import Sum, Count, Avg
        from django.utils import timezone
        import pytz
        
        try:
            tz = pytz.timezone('Asia/Bangkok')
            today = timezone.now().astimezone(tz).date()
            
            # Get base queryset for ARD transactions
            queryset = self.get_queryset()
            
            # Apply date filters if provided
            date_from = request.query_params.get('date_from')
            date_to = request.query_params.get('date_to')
            
            if date_from:
                from_date = parse_date(date_from)
                if from_date:
                    queryset = queryset.filter(Value_date__date__gte=from_date)
            
            if date_to:
                to_date = parse_date(date_to)
                if to_date:
                    queryset = queryset.filter(Value_date__date__lte=to_date)
            else:
                # Default to today if no date_to specified
                queryset = queryset.filter(Value_date__date=today)
            
            # Calculate summary statistics
            summary = queryset.aggregate(
                total_count=Count('JRNLLog_id'),
                total_amount=Sum('Fcy_Amount'),
                average_amount=Avg('Fcy_Amount'),
                pending_count=Count('JRNLLog_id', filter=Q(Auth_Status='U')),
                approved_count=Count('JRNLLog_id', filter=Q(Auth_Status='A')),
                rejected_count=Count('JRNLLog_id', filter=Q(Auth_Status='R')),
                correction_count=Count('JRNLLog_id', filter=Q(Auth_Status='P')),
                pending_amount=Sum('Fcy_Amount', filter=Q(Auth_Status='U')),
                approved_amount=Sum('Fcy_Amount', filter=Q(Auth_Status='A')),
                rejected_amount=Sum('Fcy_Amount', filter=Q(Auth_Status='R')),
            )
            
            # Get currency breakdown
            currency_breakdown = queryset.values('Ccy_cd__ccy_code').annotate(
                count=Count('JRNLLog_id'),
                total_amount=Sum('Fcy_Amount')
            ).order_by('-total_amount')
            
            # Get status breakdown by date (last 7 days)
            from datetime import timedelta
            date_range = []
            for i in range(6, -1, -1):
                check_date = today - timedelta(days=i)
                day_data = queryset.filter(Value_date__date=check_date).aggregate(
                    date=check_date.isoformat(),
                    total=Count('JRNLLog_id'),
                    pending=Count('JRNLLog_id', filter=Q(Auth_Status='U')),
                    approved=Count('JRNLLog_id', filter=Q(Auth_Status='A')),
                    rejected=Count('JRNLLog_id', filter=Q(Auth_Status='R'))
                )
                day_data['date'] = check_date.isoformat()
                date_range.append(day_data)
            
            response_data = {
                'transaction_type': 'ARD',
                'summary_period': {
                    'from': date_from or today.isoformat(),
                    'to': date_to or today.isoformat()
                },
                'totals': summary,
                'currency_breakdown': list(currency_breakdown),
                'daily_trend': date_range,
                'generated_at': timezone.now().isoformat()
            }
            
            return Response(response_data)
            
        except Exception as e:
            return Response({
                'error': f'Error generating ARD summary: {str(e)}',
                'transaction_type': 'ARD'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @action(detail=False, methods=['post'], url_path='bulk-approve')
    def bulk_approve(self, request):
        """Bulk approve multiple ARD transactions"""
        reference_numbers = request.data.get('reference_numbers', [])
        checker_id = request.data.get('checker_id')
        checker_dt_stamp = request.data.get('checker_dt_stamp')
        
        if not reference_numbers:
            return Response({
                'detail': 'reference_numbers list is required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        if not checker_id:
            return Response({
                'detail': 'checker_id is required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Get ARD records to approve
            records = DETB_JRNL_LOG_MASTER.objects.filter(
                Reference_No__in=reference_numbers,
                Txn_code='ARD',
                Auth_Status='U'  # Only approve pending records
            )
            
            if not records.exists():
                return Response({
                    'detail': 'No pending ARD records found for the provided reference numbers'
                }, status=status.HTTP_404_NOT_FOUND)
            
            # Update records
            updated_count = records.update(
                Auth_Status='A',
                Checker_Id=checker_id,
                Checker_DT_Stamp=checker_dt_stamp
            )
            
            # Also update detail records if they exist
            from .models import DETB_JRNL_LOG
            DETB_JRNL_LOG.objects.filter(
                Reference_No__in=reference_numbers,
                Txn_code='ARD'
            ).update(Auth_Status='A')
            
            return Response({
                'detail': f'Successfully approved {updated_count} ARD transactions',
                'approved_references': reference_numbers,
                'updated_count': updated_count
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            return Response({
                'detail': f'Error during bulk approval: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @action(detail=False, methods=['post'], url_path='bulk-reject')
    def bulk_reject(self, request):
        """Bulk reject multiple ARD transactions"""
        reference_numbers = request.data.get('reference_numbers', [])
        checker_id = request.data.get('checker_id')
        checker_dt_stamp = request.data.get('checker_dt_stamp')
        rejection_reason = request.data.get('rejection_reason', '')
        
        if not reference_numbers:
            return Response({
                'detail': 'reference_numbers list is required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        if not checker_id:
            return Response({
                'detail': 'checker_id is required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Get ARD records to reject
            records = DETB_JRNL_LOG_MASTER.objects.filter(
                Reference_No__in=reference_numbers,
                Txn_code='ARD',
                Auth_Status='U'  # Only reject pending records
            )
            
            if not records.exists():
                return Response({
                    'detail': 'No pending ARD records found for the provided reference numbers'
                }, status=status.HTTP_404_NOT_FOUND)
            
            # Update records
            update_data = {
                'Auth_Status': 'R',
                'Checker_Id': checker_id,
                'Checker_DT_Stamp': checker_dt_stamp
            }
            
            if rejection_reason:
                update_data['Addl_text'] = rejection_reason
            
            updated_count = records.update(**update_data)
            
            # Also update detail records if they exist
            from .models import DETB_JRNL_LOG
            DETB_JRNL_LOG.objects.filter(
                Reference_No__in=reference_numbers,
                Txn_code='ARD'
            ).update(Auth_Status='R')
            
            return Response({
                'detail': f'Successfully rejected {updated_count} ARD transactions',
                'rejected_references': reference_numbers,
                'updated_count': updated_count,
                'rejection_reason': rejection_reason
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            return Response({
                'detail': f'Error during bulk rejection: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def get_current_processing_date(self, request):
        """
        Get the current processing date based on EOD logic.
        This should match the same logic used in check_journal_submission_available.
        """
        import pytz
        from django.utils import timezone
        from .models import MTTB_DATA_Entry, STTB_Dates  # Replace with actual import
        
        try:
            tz = pytz.timezone('Asia/Bangkok')
            today = timezone.now().astimezone(tz).date()
            
            # Get MTTB_DATA_Entry configuration
            try:
                data_entry = MTTB_DATA_Entry.objects.filter(
                    # Auth_Status='A'  # Uncomment if needed
                ).first()
                
                if not data_entry:
                    bypass_eod_check = False
                else:
                    bypass_eod_check = data_entry.BACK_VALUE == 'Y'
                    
            except Exception:
                bypass_eod_check = False

            # Get the latest EOD record
            try:
                latest_eod = STTB_Dates.objects.latest('date_id')
            except STTB_Dates.DoesNotExist:
                # No EOD records - use today
                return today

            latest_next_working = latest_eod.next_working_Day.astimezone(tz).date()
            
            # Apply the same logic as EOD validation
            if latest_next_working == today:
                # Normal case - processing today's journals
                return today
            elif latest_next_working < today:
                # We're ahead - check if back-dating is enabled
                if bypass_eod_check:
                    # Back-date mode - return the target date
                    return latest_next_working
                else:
                    # No back-dating - use today (but this might mean no journals)
                    return today
            else:
                # Future date (shouldn't happen normally) - use today
                return today
                
        except Exception:
            # Fallback to today if anything goes wrong
            return timezone.now().astimezone(pytz.timezone('Asia/Bangkok')).date()

    @action(detail=False, methods=['get'], url_path='journal-log-by-date')
    def journal_log_by_date(self, request):
        """
        Get ARD journal log records for a specific date.
        Used for back-date EOD processing.
        """
        target_date_str = request.query_params.get('date')
        
        if not target_date_str:
            return Response({
                'error': 'Date parameter is required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            from datetime import datetime
            target_date = datetime.strptime(target_date_str, '%Y-%m-%d').date()
            
            # Get query parameters
            reference_no = request.query_params.get('Reference_No')
            auth_status = request.query_params.get('Auth_Status')
            
            # Query ARD journals for the specific date
            queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
                Txn_code='ARD',  # Only ARD transactions
                delete_stat__isnull=True,
                Value_date=target_date,
                Auth_Status='U'
            ).exclude(
                Q(delete_stat='D')
            ).order_by('-Maker_DT_Stamp')

            # Apply additional filters if provided
            if reference_no:
                queryset = queryset.filter(Reference_No=reference_no)
            if auth_status:
                queryset = queryset.filter(Auth_Status=auth_status)

            serializer = self.get_serializer(queryset, many=True)
            
            return Response({
                'results': serializer.data,
                'target_date': target_date.isoformat(),
                'record_count': len(serializer.data),
                'transaction_type': 'ARD'
            })
            
        except ValueError:
            return Response({
                'error': 'Invalid date format. Use YYYY-MM-DD'
            }, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({
                'error': f'Error fetching ARD journal records: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @action(detail=False, methods=['get'], url_path='journal-log-eod-context')
    def journal_log_eod_context(self, request):
        """
        Get ARD journal log records with full EOD context.
        Returns both current and target date journals if in back-date mode.
        """
        import pytz
        from django.utils import timezone
        from django.db.models import Q
        
        try:
            tz = pytz.timezone('Asia/Bangkok')
            today = timezone.now().astimezone(tz).date()
            
            # Get EOD status to determine processing context
            eod_status = self.get_eod_processing_status(request)
            
            response_data = {
                'today': today.isoformat(),
                'eod_context': eod_status,
                'current_journals': [],
                'target_journals': [],
                'transaction_type': 'ARD'
            }
            
            # Get current day ARD journals (always needed for validation)
            current_queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
                Txn_code='ARD',  # Only ARD transactions
                delete_stat__isnull=True,
                Value_date=today
            ).exclude(
                Q(delete_stat='D')
            ).order_by('-Maker_DT_Stamp')
            
            current_serializer = self.get_serializer(current_queryset, many=True)
            response_data['current_journals'] = current_serializer.data
            
            # If in back-date mode, also get target date ARD journals
            if eod_status.get('is_back_date') and eod_status.get('target_date'):
                target_date_str = eod_status['target_date']
                target_date = datetime.strptime(target_date_str, '%Y-%m-%d').date()
                
                target_queryset = DETB_JRNL_LOG_MASTER.objects.filter( 
                    Txn_code='ARD',  # Only ARD transactions
                    delete_stat__isnull=True,
                    Value_date=target_date
                ).exclude(
                    Q(delete_stat='D')
                ).order_by('-Maker_DT_Stamp')
                
                target_serializer = self.get_serializer(target_queryset, many=True)
                response_data['target_journals'] = target_serializer.data
            
            return Response(response_data)
            
        except Exception as e:
            return Response({
                'error': f'Error fetching ARD journal records with EOD context: {str(e)}',
                'today': today.isoformat() if 'today' in locals() else None,
                'eod_context': {},
                'current_journals': [],
                'target_journals': [],
                'transaction_type': 'ARD'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
       

        
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.parsers import JSONParser
from django.db import transaction
from django.utils import timezone
from django.db.models import Q, Sum
from datetime import datetime, time, timedelta
import logging
from .models import (
    DETB_JRNL_LOG, DETB_JRNL_LOG_HIST,
    MTTB_GLSub, MTTB_GLMaster, MTTB_TRN_Code,
    DETB_JRNL_LOG_MASTER, ACTB_DAIRY_LOG, ACTB_DAIRY_LOG_HISTORY
)
from .serializers import JRNLLogSerializer, JRNLLogHistSerializer, JournalEntryBatchSerializer
from .utils import JournalEntryHelper

logger = logging.getLogger(__name__)




class JournalARDViewSet(viewsets.ModelViewSet):
    """
    ViewSet ສຳລັບດຶງຂໍ້ຮຽກຮ້ອງຈາກ DETB_JRNL_LOG_HIST ຕາມຄວາມຕ້ອງການສະເພາະ
    """
    parser_classes = [JSONParser]
    queryset = DETB_JRNL_LOG_HIST.objects.select_related(
        'Ccy_cd', 'Account', 'Account__gl_code', 'Txn_code',
        'fin_cycle', 'Period_code', 'Maker_Id', 'Checker_Id', 'module_id'
    ).all().order_by('-Maker_DT_Stamp')
    serializer_class = JRNLLogHistSerializer
    permission_classes = [IsAuthenticated]
    filterset_fields = ['Reference_No', 'Ccy_cd', 'Dr_cr', 'Auth_Status', 'Txn_code']
    search_fields = ['Reference_No', 'Addl_text', 'Account__glsub_code', 'Account__glsub_Desc_la', 'Ac_relatives']
    ordering_fields = ['Maker_DT_Stamp', 'Value_date', 'Reference_No']

    def get_queryset(self):
        """
        ປັບແຕ່ງ queryset ສຳລັບດຶງຂໍ້ຮຽກຮ້ອງຕາມຄວາມຕ້ອງການສະເພາະ
        """
        queryset = super().get_queryset()
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        if start_date:
            queryset = queryset.filter(Value_date__gte=start_date)
        if end_date:
            queryset = queryset.filter(Value_date__lte=end_date)
        account_id = self.request.query_params.get('account_id')
        if account_id:
            queryset = queryset.filter(Account_id=account_id)
        ccy_cd = self.request.query_params.get('Ccy_cd')
        if ccy_cd:
            queryset = queryset.filter(Ccy_cd_id=ccy_cd)
        Auth_Status = self.request.query_params.get('Auth_Status')
        if Auth_Status:
            queryset = queryset.filter(Auth_Status=Auth_Status)
        Reference_No = self.request.query_params.get('Reference_No')
        if Reference_No:
            queryset = queryset.filter(Reference_No=Reference_No)
            logger.info(f"Fetching JRNL_LOG_HIST with Reference_No: {Reference_No}")
        return queryset
        return queryset




from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from django.db import transaction, connection
from django.core.exceptions import ValidationError
from datetime import datetime
import logging
import re

# Assuming these imports and functions exist in your project
from .models import STTB_Somtop_Trial_Balancesheet, MTTB_Ccy_DEFN, MTTB_Fin_Cycle, MTTB_Per_Code, MTTB_Users
# Assuming helper functions: get_gltype_lookup_dict, get_gltype_from_gl_code, safe_decimal_convert
# and logger is set up as logging.getLogger(__name__)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def bulk_insert_somtop_trial_balancesheet(request):
    """
    Clear STTB_Somtop_Trial_Balancesheet table and insert data from both FCY and LCY stored procedures
    
    Expected payload:
    {
        "date_start": "YYYY-MM-DD",
        "date_end": "YYYY-MM-DD", 
        "fin_year": "2025",
        "period_code": "",
        "category": "TRIAL_BALANCE"
    }
    """
    try:
        # Validate request data
        date_start = request.data.get("date_start")
        date_end = request.data.get("date_end")
        fin_year = request.data.get("fin_year", "2025")
        period_code = request.data.get("period_code", "")
        default_category = request.data.get("category", "TRIAL_BALANCE")

        if not all([date_start, date_end]):
            return Response({
                'status': 'error',
                'message': 'ບໍ່ມີຂໍ້ມູນວັນທີ່ເລີ່ມຕົ້ນ ແລະ ວັນທີ່ສິ້ນສຸດ (Missing required parameters: date_start and date_end)'
            }, status=status.HTTP_400_BAD_REQUEST)

        # Date validation
        try:
            start_date_obj = datetime.strptime(date_start, '%Y-%m-%d').date()
            end_date_obj = datetime.strptime(date_end, '%Y-%m-%d').date()
            
            if start_date_obj > end_date_obj:
                return Response({
                    'status': 'error',
                    'message': 'ວັນທີເລີ່ມຕົ້ນຕ້ອງນ້ອຍກວ່າວັນທີສິ້ນສຸດ (Start date must be before end date)'
                }, status=status.HTTP_400_BAD_REQUEST)
                
        except ValueError:
            return Response({
                'status': 'error',
                'message': 'ຮູບແບບວັນທີບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້ YYYY-MM-DD (Invalid date format, please use YYYY-MM-DD)'
            }, status=status.HTTP_400_BAD_REQUEST)

        logger.info(f"[BulkInsertSomtopTrialBalancesheet] Starting bulk insert operation from {date_start} to {date_end}")

        # Statistics tracking
        stats = {
            'cleared_records': 0,
            'fcy_records_fetched': 0,
            'fcy_records_inserted': 0,
            'fcy_records_failed': 0,
            'lcy_records_fetched': 0,
            'lcy_records_inserted': 0,
            'lcy_records_failed': 0,
            'total_inserted': 0,
            'total_failed': 0
        }
        
        failed_records = []
        created_records = []

        # Create glType lookup dictionary for performance
        logger.info("Creating glType lookup dictionary...")
        gltype_lookup = get_gltype_lookup_dict()
        logger.info(f"glType lookup created with {len(gltype_lookup)} mappings")

        # Get related objects once
        ccy_objects = {}
        fin_year_obj = None
        period_obj = None

        try:
            if fin_year:
                fin_year_obj = MTTB_Fin_Cycle.objects.get(fin_cycle=fin_year)
        except Exception as e:
            logger.warning(f"Financial year {fin_year} not found: {str(e)}")

        try:
            if period_code:
                period_obj = MTTB_Per_Code.objects.get(period_code=period_code)
        except Exception as e:
            logger.warning(f"Period code {period_code} not found: {str(e)}")

        with transaction.atomic():
            # Step 1: Clear existing STTB_Somtop_Trial_Balancesheet data
            try:
                logger.info("Clearing existing STTB_Somtop_Trial_Balancesheet data...")
                stats['cleared_records'] = STTB_Somtop_Trial_Balancesheet.objects.all().count()
                STTB_Somtop_Trial_Balancesheet.objects.all().delete()
                logger.info(f"Successfully cleared {stats['cleared_records']} existing records")
                
            except Exception as e:
                logger.error(f"Error clearing STTB_Somtop_Trial_Balancesheet data: {str(e)}")
                return Response({
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນເກົ່າ: {str(e)} (Error clearing existing data)'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

            # Step 2: Execute FCY stored procedure and insert FCY data
            logger.info("Executing FCY stored procedure...")
            try:
                with connection.cursor() as cursor:
                    fcy_query = """
                        EXEC dbo.Somtop_Trail_Balance_All_Currency_fcy_afterEOC
                            @DateStart = %s,
                            @DateEnd = %s
                    """
                    cursor.execute(fcy_query, [date_start, date_end])
                    fcy_columns = [col[0] for col in cursor.description]
                    fcy_results = [dict(zip(fcy_columns, row)) for row in cursor.fetchall()]

                stats['fcy_records_fetched'] = len(fcy_results)
                logger.info(f"FCY stored procedure completed. Rows fetched: {stats['fcy_records_fetched']}")

                # Insert FCY data
                for index, item in enumerate(fcy_results):
                    try:
                        gl_code = item.get('GL', '')
                        currency_code = item.get('Currency', '')
                        
                        # Get or create currency object
                        if currency_code and currency_code not in ccy_objects:
                            try:
                                ccy_objects[currency_code] = MTTB_Ccy_DEFN.objects.get(ccy_code=currency_code)
                            except Exception:
                                logger.warning(f"Currency {currency_code} not found")
                                ccy_objects[currency_code] = None

                        # Determine glType
                        record_gltype = default_category
                        if gl_code and re.search(r'\.0', str(gl_code)):
                            record_gltype = '6'
                        else:
                            lookup_gltype = gltype_lookup.get(gl_code)
                            if lookup_gltype:
                                record_gltype = lookup_gltype
                            else:
                                direct_gltype = get_gltype_from_gl_code(gl_code)
                                if direct_gltype:
                                    record_gltype = direct_gltype

                        # Create STTB_Somtop_Trial_Balancesheet record with FCY data
                        somtop_report = STTB_Somtop_Trial_Balancesheet(
                            gl_code=gl_code,
                            Desc=item.get('_Desc', ''),
                            CCy_Code=ccy_objects.get(currency_code),
                            Fin_year=fin_year_obj,
                            Period_code=period_obj,
                            Category=record_gltype,
                            StartDate=start_date_obj,
                            EndDate=end_date_obj,
                            OP_DR=safe_decimal_convert(item.get('Opening_Dr_FCY', 0)),
                            OP_CR=safe_decimal_convert(item.get('Opening_Cr_FCY', 0)),
                            Mo_DR=safe_decimal_convert(item.get('Flow_Dr_FCY', 0)),
                            Mo_Cr=safe_decimal_convert(item.get('Flow_Cr_FCY', 0)),
                            C1_DR=safe_decimal_convert(item.get('Closing_Dr_FCY', 0)),
                            C1_CR=safe_decimal_convert(item.get('Closing_Cr_FCY', 0)),
                            OP_DR_lcy=safe_decimal_convert(0),
                            OP_CR_lcy=safe_decimal_convert(0),
                            Mo_DR_lcy=safe_decimal_convert(0),
                            Mo_Cr_lcy=safe_decimal_convert(0),
                            C1_DR_lcy=safe_decimal_convert(0),
                            C1_CR_lcy=safe_decimal_convert(0),
                            Maker_Id=request.user,
                            MSegment=item.get('MSegment', '')
                        )
                        
                        somtop_report.full_clean()
                        somtop_report.save()
                        
                        stats['fcy_records_inserted'] += 1
                        created_records.append({
                            'type': 'FCY',
                            'gl_code': gl_code,
                            'currency': currency_code,
                            'category': record_gltype
                        })
                        
                    except Exception as e:
                        stats['fcy_records_failed'] += 1
                        error_msg = f"FCY record {index} error: {str(e)}"
                        logger.error(error_msg)
                        failed_records.append({
                            'type': 'FCY',
                            'index': index,
                            'gl_code': item.get('GL', 'Unknown'),
                            'currency': item.get('Currency', ''),
                            'error': error_msg
                        })

            except Exception as e:
                logger.error(f"Error executing FCY stored procedure: {str(e)}")
                return Response({
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ FCY stored procedure: {str(e)}'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

            # Step 3: Execute LCY stored procedure and insert LCY data
            logger.info("Executing LCY consolidated stored procedure...")
            try:
                with connection.cursor() as cursor:
                    lcy_query = """
                        EXEC dbo.Somtop_Trail_Balance_All_Currency_Consolidated_lcy_afterEOC
                            @DateStart = %s,
                            @DateEnd = %s
                    """
                    cursor.execute(lcy_query, [date_start, date_end])
                    lcy_columns = [col[0] for col in cursor.description]
                    lcy_results = [dict(zip(lcy_columns, row)) for row in cursor.fetchall()]

                stats['lcy_records_fetched'] = len(lcy_results)
                logger.info(f"LCY stored procedure completed. Rows fetched: {stats['lcy_records_fetched']}")

                # Get LAK currency object
                lak_ccy_obj = None
                try:
                    lak_ccy_obj = MTTB_Ccy_DEFN.objects.get(ccy_code='LAK')
                except Exception:
                    logger.warning("LAK currency not found")

                # Insert LCY data
                for index, item in enumerate(lcy_results):
                    try:
                        gl_code = item.get('GL_Code', '')
                        
                        # Determine glType
                        record_gltype = default_category
                        if gl_code and re.search(r'\.0', str(gl_code)):
                            record_gltype = '6'
                        else:
                            lookup_gltype = gltype_lookup.get(gl_code)
                            if lookup_gltype:
                                record_gltype = lookup_gltype
                            else:
                                direct_gltype = get_gltype_from_gl_code(gl_code)
                                if direct_gltype:
                                    record_gltype = direct_gltype

                        # Create STTB_Somtop_Trial_Balancesheet record with LCY data
                        somtop_report = STTB_Somtop_Trial_Balancesheet(
                            gl_code=gl_code,
                            Desc=item.get('Description', ''),
                            CCy_Code=lak_ccy_obj,
                            Fin_year=fin_year_obj,
                            Period_code=period_obj,
                            Category=record_gltype,
                            StartDate=start_date_obj,
                            EndDate=end_date_obj,
                            OP_DR=safe_decimal_convert(item.get('Opening_Dr_LAK', 0)),
                            OP_CR=safe_decimal_convert(item.get('Opening_Cr_LAK', 0)),
                            Mo_DR=safe_decimal_convert(item.get('Flow_Dr_LAK', 0)),
                            Mo_Cr=safe_decimal_convert(item.get('Flow_Cr_LAK', 0)),
                            C1_DR=safe_decimal_convert(item.get('Closing_Dr_LAK', 0)),
                            C1_CR=safe_decimal_convert(item.get('Closing_Cr_LAK', 0)),
                            OP_DR_lcy=safe_decimal_convert(0),
                            OP_CR_lcy=safe_decimal_convert(0),
                            Mo_DR_lcy=safe_decimal_convert(0),
                            Mo_Cr_lcy=safe_decimal_convert(0),
                            C1_DR_lcy=safe_decimal_convert(0),
                            C1_CR_lcy=safe_decimal_convert(0),
                            Maker_Id=request.user,
                            MSegment=item.get('MSegment', '')
                        )
                        
                        somtop_report.full_clean()
                        somtop_report.save()
                        
                        stats['lcy_records_inserted'] += 1
                        created_records.append({
                            'type': 'LCY',
                            'gl_code': gl_code,
                            'currency': 'LAK',
                            'category': record_gltype
                        })
                        
                    except Exception as e:
                        stats['lcy_records_failed'] += 1
                        error_msg = f"LCY record {index} error: {str(e)}"
                        logger.error(error_msg)
                        failed_records.append({
                            'type': 'LCY',
                            'index': index,
                            'gl_code': item.get('GL_Code', 'Unknown'),
                            'currency': 'LAK',
                            'error': error_msg
                        })

            except Exception as e:
                logger.error(f"Error executing LCY stored procedure: {str(e)}")
                return Response({
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ LCY stored procedure: {str(e)}'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Calculate totals
        stats['total_inserted'] = stats['fcy_records_inserted'] + stats['lcy_records_inserted']
        stats['total_failed'] = stats['fcy_records_failed'] + stats['lcy_records_failed']

        # Prepare response
        response_data = {
            'status': 'success',
            'message': f'🎉 ການດຳເນີນງານສຳເລັດ! ລຶບຂໍ້ມູນເກົ່າ {stats["cleared_records"]} ລາຍການ, ນຳເຂົ້າຂໍ້ມູນໃໝ່ {stats["total_inserted"]} ລາຍການ (Operation completed successfully! Cleared {stats["cleared_records"]} old records, inserted {stats["total_inserted"]} new records)',
            'date_range': f"{date_start} to {date_end}",
            'statistics': {
                'cleared_records': stats['cleared_records'],
                'fcy_procedure': {
                    'fetched': stats['fcy_records_fetched'],
                    'inserted': stats['fcy_records_inserted'],
                    'failed': stats['fcy_records_failed']
                },
                'lcy_procedure': {
                    'fetched': stats['lcy_records_fetched'],
                    'inserted': stats['lcy_records_inserted'],
                    'failed': stats['lcy_records_failed']
                },
                'totals': {
                    'inserted': stats['total_inserted'],
                    'failed': stats['total_failed']
                }
            },
            'sample_created_records': created_records[:5] if created_records else []
        }

        if failed_records:
            response_data['failed_records_sample'] = failed_records[:5]
            response_data['message'] += f' ⚠️ {stats["total_failed"]} ລາຍການຜິດພາດ ({stats["total_failed"]} records failed)'

        logger.info(f"Bulk insert operation completed successfully:")
        logger.info(f"- Cleared: {stats['cleared_records']} records")
        logger.info(f"- FCY: {stats['fcy_records_inserted']}/{stats['fcy_records_fetched']} inserted")
        logger.info(f"- LCY: {stats['lcy_records_inserted']}/{stats['lcy_records_fetched']} inserted")
        logger.info(f"- Total: {stats['total_inserted']} inserted, {stats['total_failed']} failed")

        return Response(response_data, status=status.HTTP_201_CREATED)

    except Exception as e:
        logger.error(f"Bulk insert somtop trial balancesheet error: {str(e)}")
        return Response({
            'status': 'error',
            'message': f'ເກີດຂໍ້ຜິດພາດໃນການດຳເນີນງານ: {str(e)} (Error in operation)'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)





@api_view(['POST'])
@permission_classes([IsAuthenticated])
def bulk_insert_monthly_balancesheet_acc(request):
    """
    Clear Monthly_Balancesheet_acc records for specific period and insert fresh data 
    from stored procedure for both LCY and FCY segments with multiple currencies
    
    Expected payload:
    {
        "date_end": "YYYY-MM-DD"
    }
    
    Note: 
    - period_code is automatically calculated from date_end (YYYYMM format)
    - Only clears existing records for the calculated period, not the entire table
    
    Data Sources:
    - LCY segment: LAK currency only
    - FCY segment: LAK, USD, THB currencies
    """
    try:
        # Validate request data
        date_end = request.data.get("date_end")
        
        if not date_end:
            return Response({
                'status': 'error',
                'message': 'ບໍ່ມີຂໍ້ມູນວັນທີ່ສິ້ນສຸດ (Missing required parameter: date_end)'
            }, status=status.HTTP_400_BAD_REQUEST)

        # Date validation and period_code calculation
        try:
            end_date_obj = datetime.strptime(date_end, '%Y-%m-%d').date()
            period_code = end_date_obj.strftime('%Y%m')
        except ValueError:
            return Response({
                'status': 'error',
                'message': 'ຮູບແບບວັນທີບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້ YYYY-MM-DD (Invalid date format, please use YYYY-MM-DD)'
            }, status=status.HTTP_400_BAD_REQUEST)

        logger.info(f"[BulkInsertMonthlyBalancesheet] Starting operation for period: {period_code}")

        # Statistics tracking
        stats = {
            'cleared_records': 0,
            'lcy_records': 0,
            'fcy_lak_records': 0,
            'fcy_usd_records': 0,
            'fcy_thb_records': 0,
            'total_inserted': 0,
            'total_failed': 0
        }
        
        failed_records = []
        created_records = []
        
        # Define segments and currencies to process
        segments_config = [
            {'segment': 'LCY', 'currency': 'LAK'},
            {'segment': 'FCY', 'currency': 'LAK'},
            {'segment': 'FCY', 'currency': 'USD'},
            {'segment': 'FCY', 'currency': 'THB'}
        ]

        with transaction.atomic():
            # Step 1: Clear existing data for this specific period only
            try:
                from .models import Monthly_Balancesheet_acc
                
                logger.info(f"Checking for existing Monthly_Balancesheet_acc data for period {period_code}...")
                existing_records = Monthly_Balancesheet_acc.objects.filter(period_code=period_code)
                stats['cleared_records'] = existing_records.count()
                
                if stats['cleared_records'] > 0:
                    logger.info(f"Found {stats['cleared_records']} existing records for period {period_code}, clearing them...")
                    existing_records.delete()
                    logger.info(f"Successfully cleared {stats['cleared_records']} existing records for period {period_code}")
                else:
                    logger.info(f"No existing records found for period {period_code}, proceeding with fresh insert")
                
            except Exception as e:
                logger.error(f"Error clearing Monthly_Balancesheet_acc data for period {period_code}: {str(e)}")
                return Response({
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນເກົ່າສຳລັບຊ່ວງ {period_code}: {str(e)} (Error clearing existing data for period {period_code})'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

            # Step 2: Process each segment and currency combination
            for config in segments_config:
                segment = config['segment']
                currency = config['currency']
                
                logger.info(f"Processing {segment} segment with {currency} currency...")
                
                try:
                    with connection.cursor() as cursor:
                        # Execute stored procedure
                        sp_query = """
                            EXEC [dbo].[balancesheet_acc_By_Currency_And_Consolidated_afterEOC]
                                @segment = %s,
                                @currency = %s,
                                @period_code_id = %s
                        """
                        cursor.execute(sp_query, [segment, currency, period_code])
                        
                        # Get column names and results
                        columns = [col[0] for col in cursor.description]
                        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
                        
                        logger.info(f"{segment}-{currency}: Fetched {len(results)} records")
                        
                        # Insert records
                        for index, item in enumerate(results):
                            try:
                                # Create Monthly_Balancesheet_acc record
                                balance_record = Monthly_Balancesheet_acc(
                                    no=item.get('no', ''),
                                    report_number=item.get('report_number', ''),
                                    description=item.get('description', ''),
                                    total_Amount_Opening=str(item.get('total_Amount_Opening', 0)) if item.get('total_Amount_Opening') is not None else '0',
                                    total_Amount_Current=str(item.get('total_Amount_Current', 0)) if item.get('total_Amount_Current') is not None else '0',
                                    total_net_amount=str(item.get('total_net_amount', 0)) if item.get('total_net_amount') is not None else '0',
                                    currency_display=item.get('currency_display', ''),
                                    segment_type=item.get('segment_type', ''),
                                    period_code=item.get('period_code', period_code)
                                )
                                
                                balance_record.full_clean()
                                balance_record.save()
                                
                                # Update statistics
                                if segment == 'LCY':
                                    stats['lcy_records'] += 1
                                elif segment == 'FCY':
                                    if currency == 'LAK':
                                        stats['fcy_lak_records'] += 1
                                    elif currency == 'USD':
                                        stats['fcy_usd_records'] += 1
                                    elif currency == 'THB':
                                        stats['fcy_thb_records'] += 1
                                
                                stats['total_inserted'] += 1
                                created_records.append({
                                    'segment': segment,
                                    'currency': currency,
                                    'no': item.get('no', ''),
                                    'description': item.get('description', '')[:50] + '...' if len(str(item.get('description', ''))) > 50 else item.get('description', '')
                                })
                                
                            except Exception as e:
                                stats['total_failed'] += 1
                                error_msg = f"{segment}-{currency} record {index} error: {str(e)}"
                                logger.error(error_msg)
                                failed_records.append({
                                    'segment': segment,
                                    'currency': currency,
                                    'index': index,
                                    'no': item.get('no', 'Unknown'),
                                    'error': error_msg
                                })
                                
                except Exception as e:
                    logger.error(f"Error executing stored procedure for {segment}-{currency}: {str(e)}")
                    return Response({
                        'status': 'error',
                        'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ stored procedure ສຳລັບ {segment}-{currency}: {str(e)}'
                    }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare response
        response_data = {
            'status': 'success',
            'message': f'🎉 ການດຳເນີນງານສຳເລັດ! ລຶບຂໍ້ມູນເກົ່າຊ່ວງ {period_code}: {stats["cleared_records"]} ລາຍການ, ນຳເຂົ້າຂໍ້ມູນໃໝ່ {stats["total_inserted"]} ລາຍການ (Operation completed successfully! Cleared {stats["cleared_records"]} old records for period {period_code}, inserted {stats["total_inserted"]} new records)',
            'period_code': period_code,
            'date_end': date_end,
            'statistics': {
                'cleared_records': stats['cleared_records'],
                'segments': {
                    'lcy_records': stats['lcy_records'],
                    'fcy_lak_records': stats['fcy_lak_records'],
                    'fcy_usd_records': stats['fcy_usd_records'],
                    'fcy_thb_records': stats['fcy_thb_records']
                },
                'totals': {
                    'inserted': stats['total_inserted'],
                    'failed': stats['total_failed']
                }
            },
            'sample_created_records': created_records[:5] if created_records else []
        }

        if failed_records:
            response_data['failed_records_sample'] = failed_records[:5]
            response_data['message'] += f' ⚠️ {stats["total_failed"]} ລາຍການຜິດພາດ ({stats["total_failed"]} records failed)'

        logger.info(f"Monthly balancesheet insert operation completed successfully:")
        logger.info(f"- Period: {period_code}")
        logger.info(f"- Cleared existing records for period {period_code}: {stats['cleared_records']} records")
        logger.info(f"- LCY: {stats['lcy_records']} records")
        logger.info(f"- FCY-LAK: {stats['fcy_lak_records']} records")
        logger.info(f"- FCY-USD: {stats['fcy_usd_records']} records")
        logger.info(f"- FCY-THB: {stats['fcy_thb_records']} records")
        logger.info(f"- Total: {stats['total_inserted']} inserted, {stats['total_failed']} failed")

        return Response(response_data, status=status.HTTP_201_CREATED)

    except Exception as e:
        logger.error(f"Bulk insert monthly balancesheet error: {str(e)}")
        return Response({
            'status': 'error',
            'message': f'ເກີດຂໍ້ຜິດພາດໃນການດຳເນີນງານ: {str(e)} (Error in operation)'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def bulk_insert_monthly_balancesheet_mfi(request):
    """
    Clear Monthly_Balancesheet_mfi records for specific period and insert fresh data 
    from stored procedure for both LCY and FCY segments with multiple currencies
    
    Expected payload:
    {
        "date_end": "YYYY-MM-DD"
    }
    
    Note: 
    - period_code is automatically calculated from date_end (YYYYMM format)
    - Only clears existing records for the calculated period, not the entire table
    
    Data Sources:
    - LCY segment: LAK currency only
    - FCY segment: LAK, USD, THB currencies
    """
    try:
        # Validate request data
        date_end = request.data.get("date_end")
        
        if not date_end:
            return Response({
                'status': 'error',
                'message': 'ບໍ່ມີຂໍ້ມູນວັນທີ່ສິ້ນສຸດ (Missing required parameter: date_end)'
            }, status=status.HTTP_400_BAD_REQUEST)

        # Date validation and period_code calculation
        try:
            end_date_obj = datetime.strptime(date_end, '%Y-%m-%d').date()
            period_code = end_date_obj.strftime('%Y%m')
        except ValueError:
            return Response({
                'status': 'error',
                'message': 'ຮູບແບບວັນທີບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້ YYYY-MM-DD (Invalid date format, please use YYYY-MM-DD)'
            }, status=status.HTTP_400_BAD_REQUEST)

        logger.info(f"[BulkInsertMonthlyBalancesheetMFI] Starting operation for period: {period_code}")

        # Statistics tracking
        stats = {
            'cleared_records': 0,
            'lcy_records': 0,
            'fcy_lak_records': 0,
            'fcy_usd_records': 0,
            'fcy_thb_records': 0,
            'total_inserted': 0,
            'total_failed': 0
        }
        
        failed_records = []
        created_records = []
        
        # Define segments and currencies to process
        segments_config = [
            {'segment': 'LCY', 'currency': 'LAK'},
            {'segment': 'FCY', 'currency': 'LAK'},
            {'segment': 'FCY', 'currency': 'USD'},
            {'segment': 'FCY', 'currency': 'THB'}
        ]

        with transaction.atomic():
            # Step 1: Clear existing data for this specific period only
            try:
                from .models import Monthly_Balancesheet_mfi
                
                logger.info(f"Checking for existing Monthly_Balancesheet_mfi data for period {period_code}...")
                existing_records = Monthly_Balancesheet_mfi.objects.filter(period_code=period_code)
                stats['cleared_records'] = existing_records.count()
                
                if stats['cleared_records'] > 0:
                    logger.info(f"Found {stats['cleared_records']} existing records for period {period_code}, clearing them...")
                    existing_records.delete()
                    logger.info(f"Successfully cleared {stats['cleared_records']} existing records for period {period_code}")
                else:
                    logger.info(f"No existing records found for period {period_code}, proceeding with fresh insert")
                
            except Exception as e:
                logger.error(f"Error clearing Monthly_Balancesheet_mfi data for period {period_code}: {str(e)}")
                return Response({
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນເກົ່າສຳລັບຊ່ວງ {period_code}: {str(e)} (Error clearing existing data for period {period_code})'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

            # Step 2: Process each segment and currency combination
            for config in segments_config:
                segment = config['segment']
                currency = config['currency']
                
                logger.info(f"Processing MFI {segment} segment with {currency} currency...")
                
                try:
                    with connection.cursor() as cursor:
                        # Execute stored procedure
                        sp_query = """
                            EXEC [dbo].[balancesheet_mfi_By_Currency_And_Consolidated_afterEOC]
                                @segment = %s,
                                @currency = %s,
                                @period_code_id = %s
                        """
                        cursor.execute(sp_query, [segment, currency, period_code])
                        
                        # Get column names and results
                        columns = [col[0] for col in cursor.description]
                        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
                        
                        logger.info(f"MFI {segment}-{currency}: Fetched {len(results)} records")
                        
                        # Insert records
                        for index, item in enumerate(results):
                            try:
                                # Create Monthly_Balancesheet_mfi record
                                balance_record = Monthly_Balancesheet_mfi(
                                    no=item.get('no', ''),
                                    report_number=item.get('report_number', ''),
                                    description=item.get('description', ''),
                                    total_Amount_Opening=str(item.get('total_Amount_Opening', 0)) if item.get('total_Amount_Opening') is not None else '0',
                                    total_Amount_Current=str(item.get('total_Amount_Current', 0)) if item.get('total_Amount_Current') is not None else '0',
                                    total_net_amount=str(item.get('total_net_amount', 0)) if item.get('total_net_amount') is not None else '0',
                                    currency_display=item.get('currency_display', ''),
                                    segment_type=item.get('segment_type', ''),
                                    period_code=item.get('period_code', period_code)
                                )
                                
                                balance_record.full_clean()
                                balance_record.save()
                                
                                # Update statistics
                                if segment == 'LCY':
                                    stats['lcy_records'] += 1
                                elif segment == 'FCY':
                                    if currency == 'LAK':
                                        stats['fcy_lak_records'] += 1
                                    elif currency == 'USD':
                                        stats['fcy_usd_records'] += 1
                                    elif currency == 'THB':
                                        stats['fcy_thb_records'] += 1
                                
                                stats['total_inserted'] += 1
                                created_records.append({
                                    'segment': segment,
                                    'currency': currency,
                                    'no': item.get('no', ''),
                                    'description': item.get('description', '')[:50] + '...' if len(str(item.get('description', ''))) > 50 else item.get('description', '')
                                })
                                
                            except Exception as e:
                                stats['total_failed'] += 1
                                error_msg = f"MFI {segment}-{currency} record {index} error: {str(e)}"
                                logger.error(error_msg)
                                failed_records.append({
                                    'segment': segment,
                                    'currency': currency,
                                    'index': index,
                                    'no': item.get('no', 'Unknown'),
                                    'error': error_msg
                                })
                                
                except Exception as e:
                    logger.error(f"Error executing MFI stored procedure for {segment}-{currency}: {str(e)}")
                    return Response({
                        'status': 'error',
                        'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ MFI stored procedure ສຳລັບ {segment}-{currency}: {str(e)}'
                    }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare response
        response_data = {
            'status': 'success',
            'message': f'🎉 ການດຳເນີນງານ MFI ສຳເລັດ! ລຶບຂໍ້ມູນເກົ່າຊ່ວງ {period_code}: {stats["cleared_records"]} ລາຍການ, ນຳເຂົ້າຂໍ້ມູນໃໝ່ {stats["total_inserted"]} ລາຍການ (MFI Operation completed successfully! Cleared {stats["cleared_records"]} old records for period {period_code}, inserted {stats["total_inserted"]} new records)',
            'period_code': period_code,
            'date_end': date_end,
            'report_type': 'MFI Balance Sheet',
            'statistics': {
                'cleared_records': stats['cleared_records'],
                'segments': {
                    'lcy_records': stats['lcy_records'],
                    'fcy_lak_records': stats['fcy_lak_records'],
                    'fcy_usd_records': stats['fcy_usd_records'],
                    'fcy_thb_records': stats['fcy_thb_records']
                },
                'totals': {
                    'inserted': stats['total_inserted'],
                    'failed': stats['total_failed']
                }
            },
            'sample_created_records': created_records[:5] if created_records else []
        }

        if failed_records:
            response_data['failed_records_sample'] = failed_records[:5]
            response_data['message'] += f' ⚠️ {stats["total_failed"]} ລາຍການຜິດພາດ ({stats["total_failed"]} records failed)'

        logger.info(f"Monthly MFI balancesheet insert operation completed successfully:")
        logger.info(f"- Period: {period_code}")
        logger.info(f"- Cleared existing MFI records for period {period_code}: {stats['cleared_records']} records")
        logger.info(f"- MFI LCY: {stats['lcy_records']} records")
        logger.info(f"- MFI FCY-LAK: {stats['fcy_lak_records']} records")
        logger.info(f"- MFI FCY-USD: {stats['fcy_usd_records']} records")
        logger.info(f"- MFI FCY-THB: {stats['fcy_thb_records']} records")
        logger.info(f"- MFI Total: {stats['total_inserted']} inserted, {stats['total_failed']} failed")

        return Response(response_data, status=status.HTTP_201_CREATED)

    except Exception as e:
        logger.error(f"Bulk insert monthly MFI balancesheet error: {str(e)}")
        return Response({
            'status': 'error',
            'message': f'ເກີດຂໍ້ຜິດພາດໃນການດຳເນີນງານ MFI: {str(e)} (Error in MFI operation)'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def bulk_insert_monthly_incomestatement_acc(request):
    """
    Clear Monthly_Incomestatement_acc records for specific period and insert fresh data 
    from stored procedure for both LCY and FCY segments with multiple currencies
    
    Expected payload:
    {
        "date_end": "YYYY-MM-DD"
    }
    
    Note: 
    - period_code is automatically calculated from date_end (YYYYMM format)
    - Only clears existing records for the calculated period, not the entire table
    
    Data Sources:
    - LCY segment: LAK currency only
    - FCY segment: LAK, USD, THB currencies
    """
    try:
        # Validate request data
        date_end = request.data.get("date_end")
        
        if not date_end:
            return Response({
                'status': 'error',
                'message': 'ບໍ່ມີຂໍ້ມູນວັນທີ່ສິ້ນສຸດ (Missing required parameter: date_end)'
            }, status=status.HTTP_400_BAD_REQUEST)

        # Date validation and period_code calculation
        try:
            end_date_obj = datetime.strptime(date_end, '%Y-%m-%d').date()
            period_code = end_date_obj.strftime('%Y%m')
        except ValueError:
            return Response({
                'status': 'error',
                'message': 'ຮູບແບບວັນທີບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້ YYYY-MM-DD (Invalid date format, please use YYYY-MM-DD)'
            }, status=status.HTTP_400_BAD_REQUEST)

        logger.info(f"[BulkInsertMonthlyIncomestatementAcc] Starting operation for period: {period_code}")

        # Statistics tracking
        stats = {
            'cleared_records': 0,
            'lcy_records': 0,
            'fcy_lak_records': 0,
            'fcy_usd_records': 0,
            'fcy_thb_records': 0,
            'total_inserted': 0,
            'total_failed': 0
        }
        
        failed_records = []
        created_records = []
        
        # Define segments and currencies to process
        segments_config = [
            {'segment': 'LCY', 'currency': 'LAK'},
            {'segment': 'FCY', 'currency': 'LAK'},
            {'segment': 'FCY', 'currency': 'USD'},
            {'segment': 'FCY', 'currency': 'THB'}
        ]

        with transaction.atomic():
            # Step 1: Clear existing data for this specific period only
            try:
                from .models import Monthly_Incomestatement_acc
                
                logger.info(f"Checking for existing Monthly_Incomestatement_acc data for period {period_code}...")
                existing_records = Monthly_Incomestatement_acc.objects.filter(period_code=period_code)
                stats['cleared_records'] = existing_records.count()
                
                if stats['cleared_records'] > 0:
                    logger.info(f"Found {stats['cleared_records']} existing records for period {period_code}, clearing them...")
                    existing_records.delete()
                    logger.info(f"Successfully cleared {stats['cleared_records']} existing records for period {period_code}")
                else:
                    logger.info(f"No existing records found for period {period_code}, proceeding with fresh insert")
                
            except Exception as e:
                logger.error(f"Error clearing Monthly_Incomestatement_acc data for period {period_code}: {str(e)}")
                return Response({
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນເກົ່າສຳລັບຊ່ວງ {period_code}: {str(e)} (Error clearing existing data for period {period_code})'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

            # Step 2: Process each segment and currency combination
            for config in segments_config:
                segment = config['segment']
                currency = config['currency']
                
                logger.info(f"Processing Income Statement ACC {segment} segment with {currency} currency...")
                
                try:
                    with connection.cursor() as cursor:
                        # Execute stored procedure
                        sp_query = """
                            EXEC [dbo].[incomestatement_acc_By_Currency_And_Consolidated_afterEOC]
                                @segment = %s,
                                @currency = %s,
                                @period_code_id = %s
                        """
                        cursor.execute(sp_query, [segment, currency, period_code])
                        
                        # Get column names and results
                        columns = [col[0] for col in cursor.description]
                        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
                        
                        logger.info(f"Income Statement ACC {segment}-{currency}: Fetched {len(results)} records")
                        
                        # Insert records
                        for index, item in enumerate(results):
                            try:
                                # Create Monthly_Incomestatement_acc record
                                income_record = Monthly_Incomestatement_acc(
                                    no=item.get('no', ''),
                                    report_number=item.get('report_number', ''),
                                    description=item.get('description', ''),
                                    previous_month=str(item.get('previous_month', 0)) if item.get('previous_month') is not None else '0',
                                    current_month=str(item.get('current_month', 0)) if item.get('current_month') is not None else '0',
                                    net_change=str(item.get('net_change', 0)) if item.get('net_change') is not None else '0',
                                    currency_display=item.get('currency_display', ''),
                                    segment_type=item.get('segment_type', ''),
                                    period_code=item.get('period_code', period_code)
                                )
                                
                                income_record.full_clean()
                                income_record.save()
                                
                                # Update statistics
                                if segment == 'LCY':
                                    stats['lcy_records'] += 1
                                elif segment == 'FCY':
                                    if currency == 'LAK':
                                        stats['fcy_lak_records'] += 1
                                    elif currency == 'USD':
                                        stats['fcy_usd_records'] += 1
                                    elif currency == 'THB':
                                        stats['fcy_thb_records'] += 1
                                
                                stats['total_inserted'] += 1
                                created_records.append({
                                    'segment': segment,
                                    'currency': currency,
                                    'no': item.get('no', ''),
                                    'description': item.get('description', '')[:50] + '...' if len(str(item.get('description', ''))) > 50 else item.get('description', '')
                                })
                                
                            except Exception as e:
                                stats['total_failed'] += 1
                                error_msg = f"Income ACC {segment}-{currency} record {index} error: {str(e)}"
                                logger.error(error_msg)
                                failed_records.append({
                                    'segment': segment,
                                    'currency': currency,
                                    'index': index,
                                    'no': item.get('no', 'Unknown'),
                                    'error': error_msg
                                })
                                
                except Exception as e:
                    logger.error(f"Error executing Income Statement ACC stored procedure for {segment}-{currency}: {str(e)}")
                    return Response({
                        'status': 'error',
                        'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ Income Statement ACC stored procedure ສຳລັບ {segment}-{currency}: {str(e)}'
                    }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare response
        response_data = {
            'status': 'success',
            'message': f'🎉 ການດຳເນີນງານ Income Statement ACC ສຳເລັດ! ລຶບຂໍ້ມູນເກົ່າຊ່ວງ {period_code}: {stats["cleared_records"]} ລາຍການ, ນຳເຂົ້າຂໍ້ມູນໃໝ່ {stats["total_inserted"]} ລາຍການ (Income Statement ACC Operation completed successfully! Cleared {stats["cleared_records"]} old records for period {period_code}, inserted {stats["total_inserted"]} new records)',
            'period_code': period_code,
            'date_end': date_end,
            'report_type': 'Income Statement ACC',
            'statistics': {
                'cleared_records': stats['cleared_records'],
                'segments': {
                    'lcy_records': stats['lcy_records'],
                    'fcy_lak_records': stats['fcy_lak_records'],
                    'fcy_usd_records': stats['fcy_usd_records'],
                    'fcy_thb_records': stats['fcy_thb_records']
                },
                'totals': {
                    'inserted': stats['total_inserted'],
                    'failed': stats['total_failed']
                }
            },
            'sample_created_records': created_records[:5] if created_records else []
        }

        if failed_records:
            response_data['failed_records_sample'] = failed_records[:5]
            response_data['message'] += f' ⚠️ {stats["total_failed"]} ລາຍການຜິດພາດ ({stats["total_failed"]} records failed)'

        logger.info(f"Monthly Income Statement ACC insert operation completed successfully:")
        logger.info(f"- Period: {period_code}")
        logger.info(f"- Cleared existing Income ACC records for period {period_code}: {stats['cleared_records']} records")
        logger.info(f"- Income ACC LCY: {stats['lcy_records']} records")
        logger.info(f"- Income ACC FCY-LAK: {stats['fcy_lak_records']} records")
        logger.info(f"- Income ACC FCY-USD: {stats['fcy_usd_records']} records")
        logger.info(f"- Income ACC FCY-THB: {stats['fcy_thb_records']} records")
        logger.info(f"- Income ACC Total: {stats['total_inserted']} inserted, {stats['total_failed']} failed")

        return Response(response_data, status=status.HTTP_201_CREATED)

    except Exception as e:
        logger.error(f"Bulk insert monthly Income Statement ACC error: {str(e)}")
        return Response({
            'status': 'error',
            'message': f'ເກີດຂໍ້ຜິດພາດໃນການດຳເນີນງານ Income Statement ACC: {str(e)} (Error in Income Statement ACC operation)'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def bulk_insert_monthly_incomestatement_mfi(request):
    """
    Clear Monthly_Incomestatement_mfi records for specific period and insert fresh data 
    from stored procedure for both LCY and FCY segments with multiple currencies
    
    Expected payload:
    {
        "date_end": "YYYY-MM-DD"
    }
    
    Note: 
    - period_code is automatically calculated from date_end (YYYYMM format)
    - Only clears existing records for the calculated period, not the entire table
    
    Data Sources:
    - LCY segment: LAK currency only
    - FCY segment: LAK, USD, THB currencies
    """
    try:
        # Validate request data
        date_end = request.data.get("date_end")
        
        if not date_end:
            return Response({
                'status': 'error',
                'message': 'ບໍ່ມີຂໍ້ມູນວັນທີ່ສິ້ນສຸດ (Missing required parameter: date_end)'
            }, status=status.HTTP_400_BAD_REQUEST)

        # Date validation and period_code calculation
        try:
            end_date_obj = datetime.strptime(date_end, '%Y-%m-%d').date()
            period_code = end_date_obj.strftime('%Y%m')
        except ValueError:
            return Response({
                'status': 'error',
                'message': 'ຮູບແບບວັນທີບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້ YYYY-MM-DD (Invalid date format, please use YYYY-MM-DD)'
            }, status=status.HTTP_400_BAD_REQUEST)

        logger.info(f"[BulkInsertMonthlyIncomestatementMFI] Starting operation for period: {period_code}")

        # Statistics tracking
        stats = {
            'cleared_records': 0,
            'lcy_records': 0,
            'fcy_lak_records': 0,
            'fcy_usd_records': 0,
            'fcy_thb_records': 0,
            'total_inserted': 0,
            'total_failed': 0
        }
        
        failed_records = []
        created_records = []
        
        # Define segments and currencies to process
        segments_config = [
            {'segment': 'LCY', 'currency': 'LAK'},
            {'segment': 'FCY', 'currency': 'LAK'},
            {'segment': 'FCY', 'currency': 'USD'},
            {'segment': 'FCY', 'currency': 'THB'}
        ]

        with transaction.atomic():
            # Step 1: Clear existing data for this specific period only
            try:
                from .models import Monthly_Incomestatement_mfi
                
                logger.info(f"Checking for existing Monthly_Incomestatement_mfi data for period {period_code}...")
                existing_records = Monthly_Incomestatement_mfi.objects.filter(period_code=period_code)
                stats['cleared_records'] = existing_records.count()
                
                if stats['cleared_records'] > 0:
                    logger.info(f"Found {stats['cleared_records']} existing records for period {period_code}, clearing them...")
                    existing_records.delete()
                    logger.info(f"Successfully cleared {stats['cleared_records']} existing records for period {period_code}")
                else:
                    logger.info(f"No existing records found for period {period_code}, proceeding with fresh insert")
                
            except Exception as e:
                logger.error(f"Error clearing Monthly_Incomestatement_mfi data for period {period_code}: {str(e)}")
                return Response({
                    'status': 'error',
                    'message': f'ເກີດຂໍ້ຜິດພາດໃນການລຶບຂໍ້ມູນເກົ່າສຳລັບຊ່ວງ {period_code}: {str(e)} (Error clearing existing data for period {period_code})'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

            # Step 2: Process each segment and currency combination
            for config in segments_config:
                segment = config['segment']
                currency = config['currency']
                
                logger.info(f"Processing Income Statement MFI {segment} segment with {currency} currency...")
                
                try:
                    with connection.cursor() as cursor:
                        # Execute stored procedure
                        sp_query = """
                            EXEC [dbo].[incomestatement_mfi_By_Currency_And_Consolidated_afterEOC]
                                @segment = %s,
                                @currency = %s,
                                @period_code_id = %s
                        """
                        cursor.execute(sp_query, [segment, currency, period_code])
                        
                        # Get column names and results
                        columns = [col[0] for col in cursor.description]
                        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
                        
                        logger.info(f"Income Statement MFI {segment}-{currency}: Fetched {len(results)} records")
                        
                        # Insert records
                        for index, item in enumerate(results):
                            try:
                                # Create Monthly_Incomestatement_mfi record
                                income_record = Monthly_Incomestatement_mfi(
                                    no=item.get('no', ''),
                                    report_number=item.get('report_number', ''),
                                    description=item.get('description', ''),
                                    previous_month=str(item.get('previous_month', 0)) if item.get('previous_month') is not None else '0',
                                    current_month=str(item.get('current_month', 0)) if item.get('current_month') is not None else '0',
                                    net_change=str(item.get('net_change', 0)) if item.get('net_change') is not None else '0',
                                    currency_display=item.get('currency_display', ''),
                                    segment_type=item.get('segment_type', ''),
                                    period_code=item.get('period_code', period_code)
                                )
                                
                                income_record.full_clean()
                                income_record.save()
                                
                                # Update statistics
                                if segment == 'LCY':
                                    stats['lcy_records'] += 1
                                elif segment == 'FCY':
                                    if currency == 'LAK':
                                        stats['fcy_lak_records'] += 1
                                    elif currency == 'USD':
                                        stats['fcy_usd_records'] += 1
                                    elif currency == 'THB':
                                        stats['fcy_thb_records'] += 1
                                
                                stats['total_inserted'] += 1
                                created_records.append({
                                    'segment': segment,
                                    'currency': currency,
                                    'no': item.get('no', ''),
                                    'description': item.get('description', '')[:50] + '...' if len(str(item.get('description', ''))) > 50 else item.get('description', '')
                                })
                                
                            except Exception as e:
                                stats['total_failed'] += 1
                                error_msg = f"Income MFI {segment}-{currency} record {index} error: {str(e)}"
                                logger.error(error_msg)
                                failed_records.append({
                                    'segment': segment,
                                    'currency': currency,
                                    'index': index,
                                    'no': item.get('no', 'Unknown'),
                                    'error': error_msg
                                })
                                
                except Exception as e:
                    logger.error(f"Error executing Income Statement MFI stored procedure for {segment}-{currency}: {str(e)}")
                    return Response({
                        'status': 'error',
                        'message': f'ເກີດຂໍ້ຜິດພາດໃນການເອີ້ນ Income Statement MFI stored procedure ສຳລັບ {segment}-{currency}: {str(e)}'
                    }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare response
        response_data = {
            'status': 'success',
            'message': f'🎉 ການດຳເນີນງານ Income Statement MFI ສຳເລັດ! ລຶບຂໍ້ມູນເກົ່າຊ່ວງ {period_code}: {stats["cleared_records"]} ລາຍການ, ນຳເຂົ້າຂໍ້ມູນໃໝ່ {stats["total_inserted"]} ລາຍການ (Income Statement MFI Operation completed successfully! Cleared {stats["cleared_records"]} old records for period {period_code}, inserted {stats["total_inserted"]} new records)',
            'period_code': period_code,
            'date_end': date_end,
            'report_type': 'Income Statement MFI',
            'statistics': {
                'cleared_records': stats['cleared_records'],
                'segments': {
                    'lcy_records': stats['lcy_records'],
                    'fcy_lak_records': stats['fcy_lak_records'],
                    'fcy_usd_records': stats['fcy_usd_records'],
                    'fcy_thb_records': stats['fcy_thb_records']
                },
                'totals': {
                    'inserted': stats['total_inserted'],
                    'failed': stats['total_failed']
                }
            },
            'sample_created_records': created_records[:5] if created_records else []
        }

        if failed_records:
            response_data['failed_records_sample'] = failed_records[:5]
            response_data['message'] += f' ⚠️ {stats["total_failed"]} ລາຍການຜິດພາດ ({stats["total_failed"]} records failed)'

        logger.info(f"Monthly Income Statement MFI insert operation completed successfully:")
        logger.info(f"- Period: {period_code}")
        logger.info(f"- Cleared existing Income MFI records for period {period_code}: {stats['cleared_records']} records")
        logger.info(f"- Income MFI LCY: {stats['lcy_records']} records")
        logger.info(f"- Income MFI FCY-LAK: {stats['fcy_lak_records']} records")
        logger.info(f"- Income MFI FCY-USD: {stats['fcy_usd_records']} records")
        logger.info(f"- Income MFI FCY-THB: {stats['fcy_thb_records']} records")
        logger.info(f"- Income MFI Total: {stats['total_inserted']} inserted, {stats['total_failed']} failed")

        return Response(response_data, status=status.HTTP_201_CREATED)

    except Exception as e:
        logger.error(f"Bulk insert monthly Income Statement MFI error: {str(e)}")
        return Response({
            'status': 'error',
            'message': f'ເກີດຂໍ້ຜິດພາດໃນການດຳເນີນງານ Income Statement MFI: {str(e)} (Error in Income Statement MFI operation)'
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)




# BALANCE SHEET DAIRY - Clean Implementation
from django.db import connection
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

# =============================================
# STORED PROCEDURE EXECUTION FUNCTIONS
# =============================================

def run_balance_sheet_dairy_acc_proc(segment: str, currency: str):
    """
    Execute the balance sheet dairy ACC stored procedure
    
    Args:
        segment (str): FCY or LCY
        currency (str): Currency code (LAK, USD, THB, etc.)
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            sql = """
                EXEC dbo.balancesheet_acc_By_Currency_And_Consolidated
                    @segment = %s,
                    @currency = %s
            """
            
            cursor.execute(sql, [segment, currency])
            
            # Get column names and results
            columns = [col[0] for col in cursor.description]
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing balance sheet dairy ACC procedure: {str(e)}")
        raise

def run_balance_sheet_dairy_mfi_proc(segment: str, currency: str):
    """
    Execute the balance sheet dairy MFI stored procedure
    
    Args:
        segment (str): FCY or LCY
        currency (str): Currency code (LAK, USD, THB, etc.)
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            sql = """
                EXEC dbo.balancesheet_mfi_By_Currency_And_Consolidated
                    @segment = %s,
                    @currency = %s
            """
            
            cursor.execute(sql, [segment, currency])
            
            # Get column names and results
            columns = [col[0] for col in cursor.description]
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing balance sheet dairy MFI procedure: {str(e)}")
        raise

# =============================================
# VALIDATION FUNCTIONS
# =============================================

def validate_segment_dairy(segment: str) -> bool:
    """Validate segment parameter (FCY or LCY) for dairy reports"""
    if not segment or not isinstance(segment, str):
        return False
    return segment.upper() in ['FCY', 'LCY']

def validate_currency_code_dairy(currency_code: str) -> bool:
    """Validate currency code for dairy reports"""
    if not currency_code or not isinstance(currency_code, str):
        return False
    
    if len(currency_code) < 3 or len(currency_code) > 5:
        return False
    
    allowed_currencies = ['LAK', 'USD', 'THB', 'EUR', 'JPY', 'CNY']
    return currency_code.upper() in allowed_currencies

def validate_balance_sheet_dairy_params(segment: str, currency: str) -> tuple:
    """
    Validate all balance sheet dairy parameters
    
    Returns:
        tuple: (is_valid: bool, error_message: str)
    """
    if not segment or not currency:
        return False, "ບໍ່ມີຂໍ້ມູນທີ່ຈຳເປັນ: segment ແລະ currency ແມ່ນຕ້ອງການ (Missing required parameters: segment and currency are required)"
    
    if not validate_segment_dairy(segment):
        return False, "ຄ່າ segment ບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້: FCY ຫຼື LCY (Invalid segment. Supported values: FCY, LCY)"
    
    if not validate_currency_code_dairy(currency):
        return False, "ລະຫັດສະກຸນເງິນບໍ່ຖືກຕ້ອງ ສະກຸນເງິນທີ່ຮອງຮັບ: LAK, USD, THB (Invalid currency code. Supported currencies: LAK, USD, THB)"
    
    return True, ""

# =============================================
# HELPER FUNCTIONS
# =============================================

def get_display_currency_dairy(segment: str, currency: str) -> str:
    """Get formatted display currency for dairy reports"""
    return f"{currency} (FCY)" if segment == 'FCY' else "LAK (ທຽບເທົ່າ)"

def get_dairy_report_type(report_type: str) -> str:
    """Get formatted dairy report type"""
    types = {
        'ACC': 'Accounting',
        'MFI': 'Microfinance'
    }
    return types.get(report_type.upper(), report_type)

# =============================================
# API ENDPOINTS
# =============================================

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def balance_sheet_dairy_acc_view(request):
    """
    API endpoint for balance sheet dairy ACC data
    
    Expected payload:
    {
        "segment": "FCY|LCY",
        "currency": "LAK|USD|THB"
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "segment": "segment_type",
        "currency": "currency_code",
        "type": "ACC",
        "report_category": "DAIRY",
        "display_currency": "formatted_currency",
        "count": number_of_records,
        "data": [balance_sheet_records]
    }
    """
    try:
        # Extract and normalize parameters
        segment = str(request.data.get("segment", "")).strip().upper()
        currency = str(request.data.get("currency", "")).strip().upper()
        
        # Validate parameters
        is_valid, error_message = validate_balance_sheet_dairy_params(segment, currency)
        if not is_valid:
            return Response({
                "status": "error",
                "message": error_message,
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        logger.info(f"[BalanceSheet-Dairy-ACC] Executing procedure for segment={segment}, currency={currency}")
        
        # Execute stored procedure
        result = run_balance_sheet_dairy_acc_proc(segment, currency)
        
        # Format response
        display_currency = get_display_currency_dairy(segment, currency)
        
        logger.info(f"[BalanceSheet-Dairy-ACC] Procedure completed successfully. Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ Dairy ACC ສຳລັບ {display_currency} ສຳເລັດ (Balance sheet dairy ACC data retrieved successfully - {display_currency})",
            "segment": segment,
            "currency": currency,
            "type": "ACC",
            "report_category": "DAIRY",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[BalanceSheet-Dairy-ACC] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ Dairy ACC (Internal server error occurred while retrieving balance sheet dairy ACC data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def balance_sheet_dairy_mfi_view(request):
    """
    API endpoint for balance sheet dairy MFI data
    
    Expected payload:
    {
        "segment": "FCY|LCY",
        "currency": "LAK|USD|THB"
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "segment": "segment_type",
        "currency": "currency_code",
        "type": "MFI",
        "report_category": "DAIRY",
        "display_currency": "formatted_currency",
        "count": number_of_records,
        "data": [balance_sheet_records]
    }
    """
    try:
        # Extract and normalize parameters
        segment = str(request.data.get("segment", "")).strip().upper()
        currency = str(request.data.get("currency", "")).strip().upper()
        
        # Validate parameters
        is_valid, error_message = validate_balance_sheet_dairy_params(segment, currency)
        if not is_valid:
            return Response({
                "status": "error",
                "message": error_message,
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        logger.info(f"[BalanceSheet-Dairy-MFI] Executing procedure for segment={segment}, currency={currency}")
        
        # Execute stored procedure
        result = run_balance_sheet_dairy_mfi_proc(segment, currency)
        
        # Format response
        display_currency = get_display_currency_dairy(segment, currency)
        
        logger.info(f"[BalanceSheet-Dairy-MFI] Procedure completed successfully. Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ Dairy MFI ສຳລັບ {display_currency} ສຳເລັດ (Balance sheet dairy MFI data retrieved successfully - {display_currency})",
            "segment": segment,
            "currency": currency,
            "type": "MFI",
            "report_category": "DAIRY",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[BalanceSheet-Dairy-MFI] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນໃບສະຫຼຸບຊັບສິນ Dairy MFI (Internal server error occurred while retrieving balance sheet dairy MFI data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# INCOME STATEMENT DAIRY - Clean Implementation
from django.db import connection
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

# =============================================
# STORED PROCEDURE EXECUTION FUNCTIONS
# =============================================

def run_income_statement_dairy_acc_proc(segment: str, currency: str):
    """
    Execute the income statement dairy ACC stored procedure
    
    Args:
        segment (str): FCY or LCY
        currency (str): Currency code (LAK, USD, THB, etc.)
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            sql = """
                EXEC dbo.incomestatement_acc_By_Currency_And_Consolidated
                    @segment = %s,
                    @currency = %s
            """
            
            cursor.execute(sql, [segment, currency])
            
            # Get column names and results
            columns = [col[0] for col in cursor.description]
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing income statement dairy ACC procedure: {str(e)}")
        raise

def run_income_statement_dairy_mfi_proc(segment: str, currency: str):
    """
    Execute the income statement dairy MFI stored procedure
    
    Args:
        segment (str): FCY or LCY
        currency (str): Currency code (LAK, USD, THB, etc.)
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            sql = """
                EXEC dbo.incomestatement_mfi_By_Currency_And_Consolidated
                    @segment = %s,
                    @currency = %s
            """
            
            cursor.execute(sql, [segment, currency])
            
            # Get column names and results
            columns = [col[0] for col in cursor.description]
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing income statement dairy MFI procedure: {str(e)}")
        raise

# =============================================
# VALIDATION FUNCTIONS
# =============================================

def validate_segment_income_dairy(segment: str) -> bool:
    """Validate segment parameter (FCY or LCY) for income statement dairy reports"""
    if not segment or not isinstance(segment, str):
        return False
    return segment.upper() in ['FCY', 'LCY']

def validate_currency_code_income_dairy(currency_code: str) -> bool:
    """Validate currency code for income statement dairy reports"""
    if not currency_code or not isinstance(currency_code, str):
        return False
    
    if len(currency_code) < 3 or len(currency_code) > 5:
        return False
    
    allowed_currencies = ['LAK', 'USD', 'THB', 'EUR', 'JPY', 'CNY']
    return currency_code.upper() in allowed_currencies

def validate_income_statement_dairy_params(segment: str, currency: str) -> tuple:
    """
    Validate all income statement dairy parameters
    
    Returns:
        tuple: (is_valid: bool, error_message: str)
    """
    if not segment or not currency:
        return False, "ບໍ່ມີຂໍ້ມູນທີ່ຈຳເປັນ: segment ແລະ currency ແມ່ນຕ້ອງການ (Missing required parameters: segment and currency are required)"
    
    if not validate_segment_income_dairy(segment):
        return False, "ຄ່າ segment ບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້: FCY ຫຼື LCY (Invalid segment. Supported values: FCY, LCY)"
    
    if not validate_currency_code_income_dairy(currency):
        return False, "ລະຫັດສະກຸນເງິນບໍ່ຖືກຕ້ອງ ສະກຸນເງິນທີ່ຮອງຮັບ: LAK, USD, THB (Invalid currency code. Supported currencies: LAK, USD, THB)"
    
    return True, ""

# =============================================
# HELPER FUNCTIONS
# =============================================

def get_display_currency_income_dairy(segment: str, currency: str) -> str:
    """Get formatted display currency for income statement dairy reports"""
    return f"{currency} (FCY)" if segment == 'FCY' else "LAK (ທຽບເທົ່າ)"

def get_income_dairy_report_type(report_type: str) -> str:
    """Get formatted income statement dairy report type"""
    types = {
        'ACC': 'Accounting',
        'MFI': 'Microfinance'
    }
    return types.get(report_type.upper(), report_type)

# =============================================
# API ENDPOINTS
# =============================================

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def income_statement_dairy_acc_view(request):
    """
    API endpoint for income statement dairy ACC data
    
    Expected payload:
    {
        "segment": "FCY|LCY",
        "currency": "LAK|USD|THB"
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "segment": "segment_type",
        "currency": "currency_code",
        "type": "ACC",
        "report_category": "DAIRY",
        "display_currency": "formatted_currency",
        "count": number_of_records,
        "data": [income_statement_records]
    }
    """
    try:
        # Extract and normalize parameters
        segment = str(request.data.get("segment", "")).strip().upper()
        currency = str(request.data.get("currency", "")).strip().upper()
        
        # Validate parameters
        is_valid, error_message = validate_income_statement_dairy_params(segment, currency)
        if not is_valid:
            return Response({
                "status": "error",
                "message": error_message,
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        logger.info(f"[IncomeStatement-Dairy-ACC] Executing procedure for segment={segment}, currency={currency}")
        
        # Execute stored procedure
        result = run_income_statement_dairy_acc_proc(segment, currency)
        
        # Format response
        display_currency = get_display_currency_income_dairy(segment, currency)
        
        logger.info(f"[IncomeStatement-Dairy-ACC] Procedure completed successfully. Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ Dairy ACC ສຳລັບ {display_currency} ສຳເລັດ (Income statement dairy ACC data retrieved successfully - {display_currency})",
            "segment": segment,
            "currency": currency,
            "type": "ACC",
            "report_category": "DAIRY",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[IncomeStatement-Dairy-ACC] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ Dairy ACC (Internal server error occurred while retrieving income statement dairy ACC data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def income_statement_dairy_mfi_view(request):
    """
    API endpoint for income statement dairy MFI data
    
    Expected payload:
    {
        "segment": "FCY|LCY",
        "currency": "LAK|USD|THB"
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "segment": "segment_type",
        "currency": "currency_code",
        "type": "MFI",
        "report_category": "DAIRY",
        "display_currency": "formatted_currency",
        "count": number_of_records,
        "data": [income_statement_records]
    }
    """
    try:
        # Extract and normalize parameters
        segment = str(request.data.get("segment", "")).strip().upper()
        currency = str(request.data.get("currency", "")).strip().upper()
        
        # Validate parameters
        is_valid, error_message = validate_income_statement_dairy_params(segment, currency)
        if not is_valid:
            return Response({
                "status": "error",
                "message": error_message,
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        logger.info(f"[IncomeStatement-Dairy-MFI] Executing procedure for segment={segment}, currency={currency}")
        
        # Execute stored procedure
        result = run_income_statement_dairy_mfi_proc(segment, currency)
        
        # Format response
        display_currency = get_display_currency_income_dairy(segment, currency)
        
        logger.info(f"[IncomeStatement-Dairy-MFI] Procedure completed successfully. Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ Dairy MFI ສຳລັບ {display_currency} ສຳເລັດ (Income statement dairy MFI data retrieved successfully - {display_currency})",
            "segment": segment,
            "currency": currency,
            "type": "MFI",
            "report_category": "DAIRY",
            "display_currency": display_currency,
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[IncomeStatement-Dairy-MFI] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນງົບກຳໄລຂາດທຸນ Dairy MFI (Internal server error occurred while retrieving income statement dairy MFI data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# TRIAL BALANCE DAIRY - Clean Implementation
from django.db import connection
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

# =============================================
# STORED PROCEDURE EXECUTION FUNCTIONS
# =============================================

def run_trial_balance_dairy_proc(ccy_code_id: str, m_segment: str):
    """
    Execute the trial balance dairy stored procedure
    
    Args:
        ccy_code_id (str): Currency code (LAK, USD, THB, etc.)
        m_segment (str): Market segment (FCY, LCY)
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            sql = """
                EXEC dbo.Trial_Balance_By_Currency_And_Consolidated
                    @CCy_Code_id = %s,
                    @MSegment = %s
            """
            
            cursor.execute(sql, [ccy_code_id, m_segment])
            
            # Get column names and results
            columns = [col[0] for col in cursor.description]
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing trial balance dairy procedure: {str(e)}")
        raise

# =============================================
# VALIDATION FUNCTIONS
# =============================================

def validate_segment_trial_dairy(segment: str) -> bool:
    """Validate segment parameter (FCY or LCY) for trial balance dairy reports"""
    if not segment or not isinstance(segment, str):
        return False
    return segment.upper() in ['FCY', 'LCY']

def validate_currency_code_trial_dairy(currency_code: str) -> bool:
    """Validate currency code for trial balance dairy reports"""
    if not currency_code or not isinstance(currency_code, str):
        return False
    
    if len(currency_code) < 3 or len(currency_code) > 5:
        return False
    
    allowed_currencies = ['LAK', 'USD', 'THB', 'EUR', 'JPY', 'CNY']
    return currency_code.upper() in allowed_currencies

def validate_trial_balance_dairy_params(ccy_code_id: str, m_segment: str) -> tuple:
    """
    Validate all trial balance dairy parameters with business logic:
    - LCY segment: only LAK currency allowed
    - FCY segment: LAK, USD, THB currencies allowed
    
    Returns:
        tuple: (is_valid: bool, error_message: str)
    """
    if not ccy_code_id or not m_segment:
        return False, "ບໍ່ມີຂໍ້ມູນທີ່ຈຳເປັນ: ccy_code_id ແລະ m_segment ແມ່ນຕ້ອງການ (Missing required parameters: ccy_code_id and m_segment are required)"
    
    if not validate_segment_trial_dairy(m_segment):
        return False, "ຄ່າ segment ບໍ່ຖືກຕ້ອງ ກະລຸນາໃຊ້: FCY ຫຼື LCY (Invalid segment. Supported values: FCY, LCY)"
    
    # Business logic validation based on segment
    if m_segment.upper() == 'LCY':
        if ccy_code_id.upper() != 'LAK':
            return False, "ສຳລັບ LCY segment ສາມາດໃຊ້ແຕ່ LAK ເທົ່ານັ້ນ (For LCY segment, only LAK currency is allowed)"
    elif m_segment.upper() == 'FCY':
        allowed_fcy_currencies = ['LAK', 'USD', 'THB']
        if ccy_code_id.upper() not in allowed_fcy_currencies:
            return False, f"ສຳລັບ FCY segment ສາມາດໃຊ້: {', '.join(allowed_fcy_currencies)} (For FCY segment, allowed currencies: {', '.join(allowed_fcy_currencies)})"
    
    if not validate_currency_code_trial_dairy(ccy_code_id):
        return False, "ລະຫັດສະກຸນເງິນບໍ່ຖືກຕ້ອງ (Invalid currency code format)"
    
    return True, ""

# =============================================
# HELPER FUNCTIONS
# =============================================

def get_display_currency_trial_dairy(m_segment: str, ccy_code_id: str) -> str:
    """Get formatted display currency for trial balance dairy reports"""
    return f"{ccy_code_id} (FCY)" if m_segment == 'FCY' else "LAK (ທຽບເທົ່າ)"

def normalize_trial_balance_dairy_data(data: list) -> list:
    """
    Normalize trial balance dairy data for consistent output
    
    Args:
        data (list): Raw data from stored procedure
    
    Returns:
        list: Normalized data with consistent field names
    """
    normalized_data = []
    
    for item in data:
        normalized_item = {
            'GL_Code': item.get('gl_code', ''),
            'Description': item.get('Desc', ''),
            'Opening_Dr': float(item.get('OP_DR', 0) or 0),
            'Opening_Cr': float(item.get('OP_CR', 0) or 0),
            'Flow_Dr': float(item.get('Mo_DR', 0) or 0),
            'Flow_Cr': float(item.get('Mo_Cr', 0) or 0),
            'Closing_Dr': float(item.get('C1_DR', 0) or 0),
            'Closing_Cr': float(item.get('C1_CR', 0) or 0),
            'Category': int(item.get('Category', 0) or 0),
            'Currency_Code': item.get('CCy_Code_id', ''),
            'Market_Segment': item.get('MSegment', ''),
            'Financial_Year': item.get('Fin_year_id', ''),
            'Period_Code': item.get('Period_code_id', '')
        }
        
        # Calculate net amounts
        normalized_item['Opening_Net'] = normalized_item['Opening_Dr'] - normalized_item['Opening_Cr']
        normalized_item['Flow_Net'] = normalized_item['Flow_Dr'] - normalized_item['Flow_Cr']
        normalized_item['Closing_Net'] = normalized_item['Closing_Dr'] - normalized_item['Closing_Cr']
        
        normalized_data.append(normalized_item)
    
    return normalized_data

# =============================================
# API ENDPOINTS
# =============================================

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def trial_balance_dairy_view(request):
    """
    API endpoint for trial balance dairy data
    
    Business Logic:
    - LCY segment: only LAK currency allowed
    - FCY segment: LAK, USD, THB currencies allowed
    
    Expected payload:
    {
        "ccy_code_id": "LAK|USD|THB",
        "m_segment": "FCY|LCY"
    }
    
    Examples:
    LCY: {"ccy_code_id": "LAK", "m_segment": "LCY"}
    FCY: {"ccy_code_id": "USD", "m_segment": "FCY"}
    
    Returns:
    {
        "status": "success|error",
        "message": "Description",
        "ccy_code_id": "currency_code",
        "m_segment": "segment_type",
        "report_category": "DAIRY",
        "display_currency": "formatted_currency",
        "business_rules": {
            "lcy_currencies": ["LAK"],
            "fcy_currencies": ["LAK", "USD", "THB"]
        },
        "count": number_of_records,
        "data": [trial_balance_records]
    }
    """
    try:
        # Extract and normalize parameters
        ccy_code_id = str(request.data.get("ccy_code_id", "")).strip().upper()
        m_segment = str(request.data.get("m_segment", "")).strip().upper()
        
        # Validate parameters with business logic
        is_valid, error_message = validate_trial_balance_dairy_params(ccy_code_id, m_segment)
        if not is_valid:
            return Response({
                "status": "error",
                "message": error_message,
                "business_rules": {
                    "lcy_currencies": ["LAK"],
                    "fcy_currencies": ["LAK", "USD", "THB"]
                },
                "data": None
            }, status=status.HTTP_400_BAD_REQUEST)
        
        logger.info(f"[TrialBalance-Dairy] Executing procedure for ccy_code_id={ccy_code_id}, m_segment={m_segment}")
        
        # Execute stored procedure
        result = run_trial_balance_dairy_proc(ccy_code_id, m_segment)
        
        # Normalize data for consistent output
        normalized_result = normalize_trial_balance_dairy_data(result)
        
        # Format response
        display_currency = get_display_currency_trial_dairy(m_segment, ccy_code_id)
        
        logger.info(f"[TrialBalance-Dairy] Procedure completed successfully. Records: {len(normalized_result)}")
        
        return Response({
            "status": "success",
            "message": f"ດຶງຂໍ້ມູນໃບສົມທົບ Dairy ສຳລັບ {display_currency} ສຳເລັດ (Trial balance dairy data retrieved successfully - {display_currency})",
            "ccy_code_id": ccy_code_id,
            "m_segment": m_segment,
            "report_category": "DAIRY",
            "display_currency": display_currency,
            "business_rules": {
                "lcy_currencies": ["LAK"],
                "fcy_currencies": ["LAK", "USD", "THB"]
            },
            "count": len(normalized_result),
            "data": normalized_result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[TrialBalance-Dairy] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ເກີດຂໍ້ຜິດພາດໃນການດຶງຂໍ້ມູນໃບສົມທົບ Dairy (Internal server error occurred while retrieving trial balance dairy data)",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


#  Store Procedure Journal Report 
from django.db import connection
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

def run_journal_report_proc(financial_cycle_id=None, period_code_id=None, 
                           date_start=None, date_end=None, module_id=None):
    """
    Execute the EndOfDay_GetList stored procedure for journal reports
    
    Args:
        financial_cycle_id (str): Financial cycle ID
        period_code_id (str): Period code ID
        date_start (str): Start date in YYYY-MM-DD format
        date_end (str): End date in YYYY-MM-DD format
        module_id (str): Module ID
    
    Returns:
        list: Query results as list of dictionaries
    """
    try:
        with connection.cursor() as cursor:
            # Use parameterized SQL to prevent SQL injection
            sql = """
                EXEC [dbo].[EndOfDay_GetList]
                    @financial_cycle_id = %s,
                    @period_code_id = %s,
                    @startDate = %s,
                    @Enddate = %s,
                    @module_id = %s
            """
            
            cursor.execute(sql, [financial_cycle_id, period_code_id, date_start, date_end, module_id])
            
            # Get column names
            columns = [col[0] for col in cursor.description]
            
            # Fetch all results and convert to list of dictionaries
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
            return results
            
    except Exception as e:
        logger.error(f"Error executing journal report procedure: {str(e)}")
        raise


def validate_date_format(date_string: str) -> bool:
    """
    Validate date format (YYYY-MM-DD)
    
    Args:
        date_string (str): Date string to validate
    
    Returns:
        bool: True if valid, False otherwise
    """
    if not date_string:
        return True  # Allow None/empty dates
    try:
        datetime.strptime(date_string, '%Y-%m-%d')
        return True
    except ValueError:
        return False


def validate_date_range(date_start: str, date_end: str) -> bool:
    """
    Validate that start date is before or equal to end date
    
    Args:
        date_start (str): Start date
        date_end (str): End date
    
    Returns:
        bool: True if valid range, False otherwise
    """
    if not date_start or not date_end:
        return True  # Allow None dates
    try:
        start = datetime.strptime(date_start, '%Y-%m-%d')
        end = datetime.strptime(date_end, '%Y-%m-%d')
        return start <= end
    except ValueError:
        return False


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def journal_report_view(request):
    """
    API endpoint for journal reports using EndOfDay_GetList stored procedure
    
    Expected payload:
    {
        "financial_cycle_id": "2024", // optional
        "period_code_id": "202401",   // optional
        "date_start": "2024-01-01",   // optional
        "date_end": "2024-01-31",     // optional
        "module_id": "ACC"            // optional
    }
    
    Returns:
    {
        "status": "success|error",
        "message": "Description in Lao",
        "count": number_of_records,
        "data": [journal_records]
    }
    """
    # Extract parameters from request (all optional)
    financial_cycle_id = request.data.get("financial_cycle_id")
    period_code_id = request.data.get("period_code_id")
    date_start = request.data.get("date_start")
    date_end = request.data.get("date_end")
    module_id = request.data.get("module_id")
    
    # Validate date formats if provided
    if not validate_date_format(date_start):
        return Response({
            "status": "error",
            "message": "ຮູບແບບວັນທີ່ເລີ່ມຕົ້ນບໍ່ຖືກຕ້ອງ. ຕ້ອງເປັນ: YYYY-MM-DD",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    if not validate_date_format(date_end):
        return Response({
            "status": "error",
            "message": "ຮູບແບບວັນທີ່ສິ້ນສຸດບໍ່ຖືກຕ້ອງ. ຕ້ອງເປັນ: YYYY-MM-DD",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Validate date range if both dates provided
    if not validate_date_range(date_start, date_end):
        return Response({
            "status": "error",
            "message": "ຊ່ວງວັນທີ່ບໍ່ຖືກຕ້ອງ: ວັນທີ່ເລີ່ມຕົ້ນຕ້ອງມາກ່ອນຫຼືເທົ່າກັບວັນທີ່ສິ້ນສຸດ",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[JournalReport] Executing procedure - Cycle: {financial_cycle_id}, Period: {period_code_id}, Dates: {date_start} to {date_end}, Module: {module_id}")
        
        # Execute stored procedure
        result = run_journal_report_proc(
            financial_cycle_id=financial_cycle_id,
            period_code_id=period_code_id,
            date_start=date_start,
            date_end=date_end,
            module_id=module_id
        )
        
        logger.info(f"[JournalReport] Procedure completed successfully. Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": "ດຶງຂໍ້ມູນລາຍງານສໍາເລັດແລ້ວ",
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[JournalReport] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ມີຂໍ້ຜິດພາດໃນລະບົບ ກະລຸນາລອງໃໝ່ອີກຄັ້ງ",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def journal_report_get_view(request):
    """
    GET version of journal report endpoint with query parameters
    
    URL: /api/journal-report/?financial_cycle_id=2024&date_start=2024-01-01&date_end=2024-01-31
    """
    # Extract parameters from query params
    financial_cycle_id = request.query_params.get("financial_cycle_id")
    period_code_id = request.query_params.get("period_code_id")
    date_start = request.query_params.get("date_start")
    date_end = request.query_params.get("date_end")
    module_id = request.query_params.get("module_id")
    
    # Same validation as POST
    if not validate_date_format(date_start):
        return Response({
            "status": "error",
            "message": "ຮູບແບບວັນທີ່ເລີ່ມຕົ້ນບໍ່ຖືກຕ້ອງ. ຕ້ອງເປັນ: YYYY-MM-DD",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    if not validate_date_format(date_end):
        return Response({
            "status": "error",
            "message": "ຮູບແບບວັນທີ່ສິ້ນສຸດບໍ່ຖືກຕ້ອງ. ຕ້ອງເປັນ: YYYY-MM-DD",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    if not validate_date_range(date_start, date_end):
        return Response({
            "status": "error",
            "message": "ຊ່ວງວັນທີ່ບໍ່ຖືກຕ້ອງ: ວັນທີ່ເລີ່ມຕົ້ນຕ້ອງມາກ່ອນຫຼືເທົ່າກັບວັນທີ່ສິ້ນສຸດ",
            "data": None
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        logger.info(f"[JournalReport-GET] Executing procedure - Cycle: {financial_cycle_id}, Period: {period_code_id}, Dates: {date_start} to {date_end}, Module: {module_id}")
        
        # Execute stored procedure
        result = run_journal_report_proc(
            financial_cycle_id=financial_cycle_id,
            period_code_id=period_code_id,
            date_start=date_start,
            date_end=date_end,
            module_id=module_id
        )
        
        logger.info(f"[JournalReport-GET] Procedure completed successfully. Records: {len(result)}")
        
        return Response({
            "status": "success",
            "message": "ດຶງຂໍ້ມູນລາຍງານສໍາເລັດແລ້ວ",
            "count": len(result),
            "data": result
        }, status=status.HTTP_200_OK)
        
    except Exception as e:
        logger.exception(f"[JournalReport-GET] Error executing stored procedure: {str(e)}")
        
        return Response({
            "status": "error",
            "message": "ມີຂໍ້ຜິດພາດໃນລະບົບ ກະລຸນາລອງໃໝ່ອີກຄັ້ງ",
            "data": None
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# sone__________________________________________________________________________________________________________________________________________________________________________
from django.http import JsonResponse
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.db import connection
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class AssetService:
    """Service class ສຳລັບຈັດການຂໍ້ມູນ Asset"""
    
    @staticmethod
    def get_asset_by_id(asset_list_id):
        """
        ດຶງຂໍ້ມູນ Asset ດ້ວຍ asset_list_id ຈຸດດຽວ
        """
        try:
            with connection.cursor() as cursor:
                cursor.execute("""
                    SELECT * FROM SAMCSYS_fa_asset_lists
                    WHERE asset_list_id = %s
                """, [asset_list_id])
                
                columns = [col[0] for col in cursor.description]
                results = []
                
                for row in cursor.fetchall():
                    row_dict = {}
                    for i, value in enumerate(row):
                        column_name = columns[i]
                        # ແປງ datetime ເປັນ string ສຳລັບ JSON
                        if isinstance(value, datetime):
                            row_dict[column_name] = value.isoformat()
                        else:
                            row_dict[column_name] = value
                    results.append(row_dict)
                
                logger.info(f"Retrieved {len(results)} asset records for ID: {asset_list_id}")
                return results
                
        except Exception as e:
            logger.error(f"Error in get_asset_by_id: {str(e)}")
            return []

    @staticmethod
    def get_assets_by_criteria(asset_list_id=None, asset_type_id=None, asset_status=None, start_date=None, end_date=None):
        """
        ດຶງລາຍການ Assets ດ້ວຍເງື່ອນໄຂຕ່າງໆ
        """
        try:
            with connection.cursor() as cursor:
                # ສ້າງ SQL query ແບບ dynamic
                base_query = "SELECT * FROM SAMCSYS_fa_asset_lists WHERE 1=1"
                params = []
                
                if asset_list_id:
                    base_query += " AND asset_list_id = %s"
                    params.append(asset_list_id)
                
                if asset_type_id:
                    base_query += " AND asset_type_id_id = %s"
                    params.append(asset_type_id)
                
                if asset_status:
                    base_query += " AND asset_status = %s"
                    params.append(asset_status)
                
                if start_date and end_date:
                    base_query += " AND asset_date BETWEEN %s AND %s"
                    params.extend([start_date, end_date])
                elif start_date:
                    base_query += " AND asset_date >= %s"
                    params.append(start_date)
                elif end_date:
                    base_query += " AND asset_date <= %s"
                    params.append(end_date)
                
                base_query += " ORDER BY asset_type_id_id, C_dpac"
                
                cursor.execute(base_query, params)
                
                columns = [col[0] for col in cursor.description]
                results = []
                
                for row in cursor.fetchall():
                    row_dict = {}
                    for i, value in enumerate(row):
                        column_name = columns[i]
                        if isinstance(value, datetime):
                            row_dict[column_name] = value.isoformat()
                        else:
                            row_dict[column_name] = value
                    results.append(row_dict)
                
                logger.info(f"Retrieved {len(results)} asset records")
                return results
                
        except Exception as e:
            logger.error(f"Error in get_assets_by_criteria: {str(e)}")
            return []


def parse_date_parameter(date_str):
    """ປັບແຕ່ງ parameter ວັນທີ່ຢ່າງປອດໄພ"""
    if not date_str or date_str.strip() == '':
        return None
    
    try:
        date_formats = [
            '%Y-%m-%d',           # 2024-01-01
            '%Y-%m-%dT%H:%M:%S',  # ISO format
            '%d/%m/%Y',           # 01/01/2024
            '%m/%d/%Y',           # 01/01/2024
            '%Y%m%d'              # 20240101
        ]
        
        for fmt in date_formats:
            try:
                parsed_date = datetime.strptime(date_str.strip(), fmt)
                return parsed_date
            except ValueError:
                continue
                
        logger.warning(f"Cannot parse date: {date_str}")
        return None
        
    except Exception as e:
        logger.error(f"Error parsing date {date_str}: {str(e)}")
        return None


@method_decorator(csrf_exempt, name='dispatch')
class AssetListAPIView(View):
    """
    API View ສຳລັບ /api/assets/ endpoint
    ຮອງຮັບການດຶງຂໍ້ມູນ Asset ດ້ວຍ asset_list_id ແລະເງື່ອນໄຂອື່ນໆ
    """
    
    def get(self, request):
        """GET method - ຮອງຮັບການດຶງ assets ດ້ວຍເງື່ອນໄຂຕ່າງໆ"""
        try:
            # ດຶງ parameters
            asset_list_id = request.GET.get('asset_list_id', '').strip()
            asset_type_id = request.GET.get('asset_type_id', '').strip()
            asset_status = request.GET.get('asset_status', '').strip()
            start_date_str = request.GET.get('start_date', '').strip()
            end_date_str = request.GET.get('end_date', '').strip()
            
            # ປ່ຽນ empty strings ເປັນ None
            asset_list_id = asset_list_id if asset_list_id else None
            asset_type_id = asset_type_id if asset_type_id else None
            asset_status = asset_status if asset_status else None
            
            # ປັບແຕ່ງວັນທີ່
            start_date = None
            end_date = None
            
            if start_date_str:
                start_date = parse_date_parameter(start_date_str)
                if start_date is None:
                    return JsonResponse({
                        'success': False,
                        'error': 'Invalid start_date format. Use: YYYY-MM-DD, YYYY-MM-DDTHH:MM:SS, DD/MM/YYYY'
                    }, status=400)
            
            if end_date_str:
                end_date = parse_date_parameter(end_date_str)
                if end_date is None:
                    return JsonResponse({
                        'success': False,
                        'error': 'Invalid end_date format. Use: YYYY-MM-DD, YYYY-MM-DDTHH:MM:SS, DD/MM/YYYY'
                    }, status=400)
            
            # Log request
            logger.info(f"Assets API request - asset_list_id={asset_list_id}, "
                       f"type={asset_type_id}, status={asset_status}, "
                       f"dates={start_date_str} to {end_date_str}")
            
            # ດຶງຂໍ້ມູນ
            assets = AssetService.get_assets_by_criteria(
                asset_list_id=asset_list_id,
                asset_type_id=asset_type_id,
                asset_status=asset_status,
                start_date=start_date,
                end_date=end_date
            )
            
            # ຖ້າບໍ່ພົບຂໍ້ມູນ
            if not assets:
                return JsonResponse({
                    'success': True,
                    'data': [],
                    'count': 0,
                    'message': 'ບໍ່ພົບຂໍ້ມູນຊັບສິນທີ່ຕົງຕາມເງື່ອນໄຂ',
                    'filters': {
                        'asset_list_id': asset_list_id,
                        'asset_type_id': asset_type_id,
                        'asset_status': asset_status,
                        'start_date': start_date_str,
                        'end_date': end_date_str
                    }
                })
            
            # ຄິດໄລ່ສະຖິຕິ
            total_asset_value = 0
            active_count = 0
            status_breakdown = {}
            
            for asset in assets:
                # ຄິດລວມມູນຄ່າ
                try:
                    asset_value = float(asset.get('asset_value', 0) or 0)
                    total_asset_value += asset_value
                except (ValueError, TypeError):
                    pass
                
                # ນັບຕາມສະຖານະ
                status = asset.get('asset_status', 'Unknown')
                status_breakdown[status] = status_breakdown.get(status, 0) + 1
                
                if status == 'AC':  # Active
                    active_count += 1
            
            return JsonResponse({
                'success': True,
                'data': assets,
                'count': len(assets),
                'statistics': {
                    'total_count': len(assets),
                    'active_count': active_count,
                    'inactive_count': len(assets) - active_count,
                    'total_asset_value': total_asset_value,
                    'status_breakdown': status_breakdown
                },
                'filters': {
                    'asset_list_id': asset_list_id,
                    'asset_type_id': asset_type_id,
                    'asset_status': asset_status,
                    'start_date': start_date_str,
                    'end_date': end_date_str
                },
                'message': f'ພົບຂໍ້ມູນຊັບສິນ {len(assets)} ລາຍການ'
            })
            
        except Exception as e:
            logger.error(f"Error in AssetsAPIView: {str(e)}", exc_info=True)
            return JsonResponse({
                'success': False,
                'error': f'ເກີດຂໍ້ຜິດພາດໃນລະບົບ: {str(e)}',
                'message': 'ກະລຸນາກວດສອບ log ສຳລັບລາຍລະອຽດ'
            }, status=500)

    def post(self, request):
        """POST method - ຮອງຮັບ JSON payload"""
        try:
            import json
            
            # Parse JSON data
            try:
                data = json.loads(request.body.decode('utf-8'))
            except json.JSONDecodeError as e:
                return JsonResponse({
                    'success': False,
                    'error': f'Invalid JSON data: {str(e)}'
                }, status=400)
            
            # ດຶງ parameters ຈາກ JSON
            asset_list_id = data.get('asset_list_id', '').strip()
            asset_type_id = data.get('asset_type_id', '').strip()
            asset_status = data.get('asset_status', '').strip()
            start_date_str = data.get('start_date', '').strip()
            end_date_str = data.get('end_date', '').strip()
            
            # ແປງເປັນ None ຖ້າຫວ່າງ
            asset_list_id = asset_list_id if asset_list_id else None
            asset_type_id = asset_type_id if asset_type_id else None
            asset_status = asset_status if asset_status else None
            
            # ປັບແຕ່ງວັນທີ່
            start_date = parse_date_parameter(start_date_str) if start_date_str else None
            end_date = parse_date_parameter(end_date_str) if end_date_str else None
            
            # ດຶງຂໍ້ມູນ
            assets = AssetService.get_assets_by_criteria(
                asset_list_id=asset_list_id,
                asset_type_id=asset_type_id,
                asset_status=asset_status,
                start_date=start_date,
                end_date=end_date
            )
            
            return JsonResponse({
                'success': True,
                'data': assets,
                'count': len(assets),
                'message': f'ພົບຂໍ້ມູນຊັບສິນ {len(assets)} ລາຍການ'
            })
            
        except Exception as e:
            logger.error(f"Error in AssetsAPIView POST: {str(e)}", exc_info=True)
            return JsonResponse({
                'success': False,
                'error': f'ເກີດຂໍ້ຜິດພາດໃນລະບົບ: {str(e)}'
            }, status=500)


@method_decorator(csrf_exempt, name='dispatch')
class AssetSummaryView(View):
    """API View ສຳລັບສະຖິຕິສະຫຼຸບ - ປັບປຸງແລ້ວ"""
    
    def get(self, request):
        try:
            # ດຶງ parameters
            asset_type_id = request.GET.get('asset_type_id', '').strip()
            start_date_str = request.GET.get('start_date', '').strip()
            end_date_str = request.GET.get('end_date', '').strip()
            
            # ປ່ຽນ empty strings ເປັນ None
            asset_type_id = asset_type_id if asset_type_id else None
            
            # Parse dates
            start_date = None
            end_date = None
            
            if start_date_str:
                start_date = parse_date_parameter(start_date_str)
                if start_date is None:
                    return JsonResponse({
                        'success': False,
                        'error': 'Invalid start_date format'
                    }, status=400)
            
            if end_date_str:
                end_date = parse_date_parameter(end_date_str)
                if end_date is None:
                    return JsonResponse({
                        'success': False,
                        'error': 'Invalid end_date format'
                    }, status=400)
            
            logger.info(f"Asset summary request - Filters: type={asset_type_id}, "
                       f"dates={start_date_str} to {end_date_str}")
            
            # Get summary stats
            summary = AssetService.get_asset_summary_stats(
                asset_type_id=asset_type_id,
                start_date=start_date,
                end_date=end_date
            )
            
            # ຄິດໄລ່ມູນຄ່າລວມ
            total_asset_value = 0
            depreciation_info = {}
            
            for asset in summary.get('raw_data', []):
                # ຄິດລວມມູນຄ່າ
                try:
                    asset_value = float(asset.get('asset_value', 0) or 0)
                    total_asset_value += asset_value
                except (ValueError, TypeError):
                    pass
                
                # ຂໍ້ມູນການຫຼຸດມູນຄ່າ
                dpca_type = asset.get('dpca_type', 'Unknown')
                if dpca_type not in depreciation_info:
                    depreciation_info[dpca_type] = {'count': 0, 'total_value': 0}
                depreciation_info[dpca_type]['count'] += 1
                try:
                    depreciation_info[dpca_type]['total_value'] += float(asset.get('asset_value', 0) or 0)
                except (ValueError, TypeError):
                    pass
            
            return JsonResponse({
                'success': True,
                'summary': {
                    'total_count': summary['total_count'],
                    'status_breakdown': summary['status_breakdown'],
                    'type_breakdown': summary['type_breakdown'],
                    'total_asset_value': total_asset_value,
                    'depreciation_methods': depreciation_info
                },
                'filters': {
                    'asset_type_id': asset_type_id,
                    'start_date': start_date_str,
                    'end_date': end_date_str
                },
                'message': f'ສະຫຼຸບຂໍ້ມູນຊັບສິນ {summary["total_count"]} ລາຍການ'
                # ບໍ່ສົ່ງ raw_data ໃນ summary ເພື່ອປົກປ້ອງຂະໜາດ response
            })
            
        except Exception as e:
            logger.error(f"Error in AssetSummaryView: {str(e)}", exc_info=True)
            return JsonResponse({
                'success': False,
                'error': f'ເກີດຂໍ້ຜິດພາດໃນລະບົບ: {str(e)}'
            }, status=500)


# ເພີ່ມ View ສຳລັບດຶງ Asset Types ແລະ Status options
@method_decorator(csrf_exempt, name='dispatch')
class AssetOptionsView(View):
    """API View ສຳລັບດຶງ options ຕ່າງໆ ສຳລັບ dropdown"""
    
    def get(self, request):
        try:
            with connection.cursor() as cursor:
                # ດຶງລາຍການ Asset Types
                cursor.execute("""
                    SELECT DISTINCT asset_type_id_id, asset_type_id_id as asset_type_name
                    FROM SAMCSYS_fa_asset_lists 
                    WHERE asset_type_id_id IS NOT NULL 
                    ORDER BY asset_type_id_id
                """)
                
                asset_types = []
                for row in cursor.fetchall():
                    asset_types.append({
                        'id': row[0],
                        'name': row[1]
                    })
                
                # ດຶງລາຍການ Asset Status
                cursor.execute("""
                    SELECT DISTINCT asset_status, asset_status as status_name
                    FROM SAMCSYS_fa_asset_lists 
                    WHERE asset_status IS NOT NULL 
                    ORDER BY asset_status
                """)
                
                asset_statuses = []
                for row in cursor.fetchall():
                    asset_statuses.append({
                        'id': row[0],
                        'name': row[1]
                    })
            
            return JsonResponse({
                'success': True,
                'options': {
                    'asset_types': asset_types,
                    'asset_statuses': asset_statuses
                },
                'message': f'ດຶງຕົວເລືອກສຳເລັດ: {len(asset_types)} ປະເພດ, {len(asset_statuses)} ສະຖານະ'
            })
            
        except Exception as e:
            logger.error(f"Error in AssetOptionsView: {str(e)}")
            return JsonResponse({
                'success': False,
                'error': f'ເກີດຂໍ້ຜິດພາດໃນການດຶງຕົວເລືອກ: {str(e)}'
            }, status=500)


# ===============================
# ໄຟລ์: asset_api.py
# ຟັງຊັ້ນສຳລັບ API ດຶງຂໍ້ມູນຊັບສິນ
# ===============================

from django.http import JsonResponse
from django.views import View
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.utils.dateparse import parse_datetime
from django.db import connection
import json
from datetime import datetime

# ===============================
# ຟັງຊັ້ນຫຼັກສຳລັບເອີ້ນ Stored Procedure
# ===============================

def get_asset_depreciation_report(asset_list_id=None, asset_type_id=None, 
                                asset_status=None, start_date=None, end_date=None):
    """
    ຟັງຊັ້ນເອີ້ນ Stored Procedure ເພື່ອດຶງຂໍ້ມູນບົດລາຍງານຊັບສິນ
    
    Parameters:
    - asset_list_id: ລະຫັດຊັບສິນສະເພາະ (ຖ້າຕ້ອງການ)
    - asset_type_id: ປະເພດຊັບສິນ (1001, 1002, ...)
    - asset_status: ສະຖານະຊັບສິນ (AC, UC, IA, ...)
    - start_date: ວັນທີ່ເລີ່ມຕົ້ນ
    - end_date: ວັນທີ່ສິ້ນສຸດ
    
    Returns:
    - List ຂອງຂໍ້ມູນຊັບສິນ
    """
    try:
        with connection.cursor() as cursor:
            # ເອີ້ນ Stored Procedure
            cursor.execute("""
                EXEC [dbo].[Asset_List_GetAllList_Depreciation_Monthly] 
                @asset_list_id_id = %s,
                @asset_type_id = %s,
                @asset_status = %s,
                @startDate = %s,
                @Enddate = %s
            """, [asset_list_id, asset_type_id, asset_status, start_date, end_date])
            
            # ດຶງຊື່ຖັນ (columns)
            columns = [col[0] for col in cursor.description]
            
            # ດຶງຂໍ້ມູນທັງໝົດ
            rows = cursor.fetchall()
            
            # ປ່ຽນເປັນ list of dictionaries
            result = []
            for row in rows:
                row_dict = dict(zip(columns, row))
                
                # ປ່ຽນ datetime objects ເປັນ string ສຳລັບ JSON
                for key, value in row_dict.items():
                    if isinstance(value, datetime):
                        row_dict[key] = value.isoformat()
                
                result.append(row_dict)
            
            return result
            
    except Exception as e:
        print(f"Error in get_asset_depreciation_report: {str(e)}")
        raise e

# ===============================
# ຟັງຊັ້ນຄິດໄລ່ຄ່າລວມ
# ===============================

def calculate_asset_totals(asset_data):
    """
    ຄິດໄລ່ຄ່າລວມຕ່າງໆ ຈາກຂໍ້ມູນຊັບສິນ
    
    Parameters:
    - asset_data: List ຂອງຂໍ້ມູນຊັບສິນ
    
    Returns:
    - Dictionary ທີ່ມີຄ່າລວມຕ່າງໆ
    """
    totals = {
        'total_asset_value': 0,
        'total_depreciation_value': 0,
        'total_remaining_value': 0,
        'total_monthly_depreciation': 0,
        'asset_count': len(asset_data)
    }
    
    for asset in asset_data:
        # ປ່ຽນ string ເປັນ float ຖ້າຈຳເປັນ
        asset_value = float(asset.get('asset_value', 0) or 0)
        accu_depreciation = float(asset.get('asset_accu_dpca_value', 0) or 0)
        remaining_value = float(asset.get('asset_value_remain', 0) or 0)
        monthly_depreciation = float(asset.get('asset_value_remainMonth', 0) or 0)
        
        totals['total_asset_value'] += asset_value
        totals['total_depreciation_value'] += accu_depreciation
        totals['total_remaining_value'] += remaining_value
        totals['total_monthly_depreciation'] += monthly_depreciation
    
    return totals

# ===============================
# ຟັງຊັ້ນປັບແຕ່ງວັນທີ່
# ===============================

def parse_date_parameter(date_string):
    """
    ປັບແຕ່ງ date string ເປັນ datetime object
    
    Parameters:
    - date_string: ວັນທີ່ໃນຮູບແບບ string
    
    Returns:
    - datetime object ຫຼື None
    """
    if not date_string:
        return None
        
    # ລອງ parse ຫຼາຍຮູບແບບ
    try:
        # ISO format: YYYY-MM-DDTHH:MM:SS
        return parse_datetime(date_string)
    except:
        try:
            # Simple date format: YYYY-MM-DD
            return datetime.strptime(date_string, '%Y-%m-%d')
        except:
            try:
                # DD/MM/YYYY format
                return datetime.strptime(date_string, '%d/%m/%Y')
            except:
                return None

# ===============================
# API View Class
# ===============================

@method_decorator(csrf_exempt, name='dispatch')
class AssetDepreciationReportView1(View):
    """API View ສຳລັບບົດລາຍງານການຫຼຸດມູນຄ່າຊັບສິນ"""
    
    def get(self, request):
        """GET method - ໃຊ້ query parameters"""
        try:
            # ດຶງ parameters ຈາກ URL
            asset_list_id = request.GET.get('asset_list_id')
            asset_type_id = request.GET.get('asset_type_id') or request.GET.get('type')
            asset_status = request.GET.get('asset_status') or request.GET.get('status')
            start_date_str = request.GET.get('start_date') or request.GET.get('start')
            end_date_str = request.GET.get('end_date') or request.GET.get('end')
            
            # ປັບແຕ່ງວັນທີ່
            start_date = parse_date_parameter(start_date_str)
            end_date = parse_date_parameter(end_date_str)
            
            # ກວດສອບຮູບແບບວັນທີ່
            if start_date_str and not start_date:
                return JsonResponse({
                    'success': False,
                    'error': 'Invalid start_date format. Use YYYY-MM-DD or YYYY-MM-DDTHH:MM:SS'
                }, status=400)
            
            if end_date_str and not end_date:
                return JsonResponse({
                    'success': False,
                    'error': 'Invalid end_date format. Use YYYY-MM-DD or YYYY-MM-DDTHH:MM:SS'
                }, status=400)
            
            # ດຶງຂໍ້ມູນຈາກ Stored Procedure
            assets = get_asset_depreciation_report(
                asset_list_id=asset_list_id,
                asset_type_id=asset_type_id,
                asset_status=asset_status,
                start_date=start_date,
                end_date=end_date
            )
            
            # ຄິດໄລ່ຄ່າລວມ
            totals = calculate_asset_totals(assets)
            
            return JsonResponse({
                'success': True,
                'data': assets,
                'totals': totals,
                'filters': {
                    'asset_list_id': asset_list_id,
                    'asset_type_id': asset_type_id,
                    'asset_status': asset_status,
                    'start_date': start_date_str,
                    'end_date': end_date_str
                },
                'message': f'ພົບຂໍ້ມູນ {len(assets)} ລາຍການ'
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'
            }, status=500)
    
    def post(self, request):
        """POST method - ໃຊ້ JSON payload"""
        try:
            data = json.loads(request.body)
            
            # ດຶງຂໍ້ມູນຈາກ JSON
            asset_list_id = data.get('asset_list_id')
            asset_type_id = data.get('asset_type_id') or data.get('type')
            asset_status = data.get('asset_status') or data.get('status')
            start_date_str = data.get('start_date') or data.get('start')
            end_date_str = data.get('end_date') or data.get('end')
            
            # ປັບແຕ່ງວັນທີ່
            start_date = parse_date_parameter(start_date_str)
            end_date = parse_date_parameter(end_date_str)
            
            # ດຶງຂໍ້ມູນ
            assets = get_asset_depreciation_report(
                asset_list_id=asset_list_id,
                asset_type_id=asset_type_id,
                asset_status=asset_status,
                start_date=start_date,
                end_date=end_date
            )
            
            # ຄິດໄລ່ຄ່າລວມ
            totals = calculate_asset_totals(assets)
            
            return JsonResponse({
                'success': True,
                'data': assets,
                'totals': totals,
                'message': f'ພົບຂໍ້ມູນ {len(assets)} ລາຍການ'
            })
            
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'JSON format ບໍ່ຖືກຕ້ອງ'
            }, status=400)
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'
            }, status=500)

# ===============================
# ຟັງຊັ້ນເສີມສຳລັບສະຖິຕິ
# ===============================

def get_asset_statistics(asset_type_id=None, start_date=None, end_date=None):
    """
    ດຶງສະຖິຕິສະຫຼຸບຂອງຊັບສິນ
    """
    try:
        # ດຶງຂໍ້ມູນທັງໝົດ
        assets = get_asset_depreciation_report(
            asset_type_id=asset_type_id,
            start_date=start_date,
            end_date=end_date
        )
        
        # ສະຖິຕິຕາມສະຖານະ
        status_stats = {}
        type_stats = {}
        
        for asset in assets:
            status = asset.get('asset_status', 'ບໍ່ລະບຸ')
            asset_type = asset.get('asset_type_id_id', 'ບໍ່ລະບຸ')
            
            # ນັບຕາມສະຖານະ
            if status in status_stats:
                status_stats[status] += 1
            else:
                status_stats[status] = 1
            
            # ນັບຕາມປະເພດ
            if asset_type in type_stats:
                type_stats[asset_type] += 1
            else:
                type_stats[asset_type] = 1
        
        # ຄິດໄລ່ຄ່າລວມ
        totals = calculate_asset_totals(assets)
        
        return {
            'total_count': len(assets),
            'status_breakdown': status_stats,
            'type_breakdown': type_stats,
            'financial_summary': totals
        }
        
    except Exception as e:
        print(f"Error in get_asset_statistics: {str(e)}")
        raise e

# ===============================
# API View ສຳລັບສະຖິຕິ
# ===============================

class AssetStatisticsView(View):
    """API View ສຳລັບສະຖິຕິສະຫຼຸບຊັບສິນ"""
    
    def get(self, request):
        try:
            asset_type_id = request.GET.get('asset_type_id') or request.GET.get('type')
            start_date_str = request.GET.get('start_date') or request.GET.get('start')
            end_date_str = request.GET.get('end_date') or request.GET.get('end')
            
            # ປັບແຕ່ງວັນທີ່
            start_date = parse_date_parameter(start_date_str)
            end_date = parse_date_parameter(end_date_str)
            
            # ດຶງສະຖິຕິ
            stats = get_asset_statistics(
                asset_type_id=asset_type_id,
                start_date=start_date,
                end_date=end_date
            )
            
            return JsonResponse({
                'success': True,
                'statistics': stats,
                'filters': {
                    'asset_type_id': asset_type_id,
                    'start_date': start_date_str,
                    'end_date': end_date_str
                }
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': f'ເກີດຂໍ້ຜິດພາດ: {str(e)}'
            }, status=500)

# ===============================
# ການນຳໄປໃຊ້
# ===============================

"""
ການໃຊ້ງານ:

1. ເພີ່ມໃນ urls.py:
from .asset_api import AssetDepreciationReportView, AssetStatisticsView

urlpatterns = [
    path('api/assets/depreciation/', AssetDepreciationReportView.as_view(), name='asset_depreciation'),
    path('api/assets/statistics/', AssetStatisticsView.as_view(), name='asset_statistics'),
]

2. ເອີ້ນໃຊ້ຈາກ Frontend:
GET /api/assets/depreciation/?type=1002&status=AC&start=2024-01-01&end=2024-12-31
POST /api/assets/depreciation/ with JSON payload

3. ຜົນລັບ:
{
    "success": true,
    "data": [...],
    "totals": {
        "total_asset_value": 1000000,
        "total_depreciation_value": 200000,
        "total_remaining_value": 800000,
        "asset_count": 50
    },
    "filters": {...}
}
"""
from django.http import JsonResponse
from django.views import View
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

def parse_date_parameter(date_str):
    """
    ປັບແຕ່ງ parameter ວັນທີ່ຢ່າງປອດໄພ
    """
    if not date_str or date_str.strip() == '':
        return None
    
    try:
        # ລອງຫຼາຍແບບ date format
        date_formats = ['%Y-%m-%d', '%d/%m/%Y', '%m/%d/%Y', '%Y%m%d']
        
        for fmt in date_formats:
            try:
                return datetime.strptime(date_str.strip(), fmt).date()
            except ValueError:
                continue
                
        # ຖ້າບໍ່ສາມາດ parse ໄດ້
        logger.warning(f"Cannot parse date: {date_str}")
        return None
        
    except Exception as e:
        logger.error(f"Error parsing date {date_str}: {str(e)}")
        return None


def safe_float_conversion(value, default=0.0):
    """
    ແປງຄ່າເປັນ float ຢ່າງປອດໄພ
    """
    if value is None or value == '':
        return default
    
    try:
        if isinstance(value, (int, float)):
            return float(value)
        
        # ຖ້າເປັນ string ໃຫ້ລົບ comma ແລະ space
        if isinstance(value, str):
            clean_value = value.replace(',', '').replace(' ', '')
            return float(clean_value) if clean_value else default
            
        return float(value)
    except (ValueError, TypeError):
        logger.warning(f"Cannot convert to float: {value}, using default: {default}")
        return default


def group_depreciation_data_by_asset(data):
    """
    ຈັດກຸ່ມຂໍ້ມູນການຫຼຸດມູນຄ່າຕາມ asset_list_id (ປັບປຸງແລ້ວ)
    """
    from collections import defaultdict
    
    if not data:
        return {}
    
    grouped = defaultdict(lambda: {
        'asset_info': {},
        'depreciation_records': [],
        'summary': {}
    })
    
    try:
        for record in data:
            # ກວດສອບວ່າ record ມີຂໍ້ມູນຄົບຖ້ວນບໍ່
            if not isinstance(record, dict) or not record.get('asset_list_id'):
                logger.warning(f"Invalid record structure: {record}")
                continue
                
            asset_id = record['asset_list_id']
            
            # ຂໍ້ມູນພື້ນຖານຂອງຊັບສິນ (ເອົາຄັ້ງດຽວ)
            if not grouped[asset_id]['asset_info']:
                grouped[asset_id]['asset_info'] = {
                    'asset_list_id': record.get('asset_list_id', ''),
                    'asset_list_code': record.get('asset_list_code', ''),
                    'asset_serial_no': record.get('asset_serial_no', ''),
                    'asset_tag': record.get('asset_tag', ''),
                    'asset_spec': record.get('asset_spec', ''),
                    'asset_type_id': record.get('asset_type_id_id', record.get('asset_type_id', '')),
                    'asset_location_id': record.get('asset_location_id_id', record.get('asset_location_id', '')),
                    'asset_value': safe_float_conversion(record.get('asset_value', 0)),
                    'asset_salvage_value': safe_float_conversion(record.get('asset_salvage_value', 0)),
                    'asset_useful_life': record.get('asset_useful_life', 0),
                    'dpca_type': record.get('dpca_type', ''),
                    'dpca_percentage': safe_float_conversion(record.get('dpca_percentage', 0)),
                    'dpca_start_date': record.get('dpca_start_date'),
                    'dpca_end_date': record.get('dpca_end_date'),
                    'asset_currency': record.get('asset_currency', ''),
                    'asset_status': record.get('asset_status', '')
                }
            
            # ຂໍ້ມູນການຫຼຸດມູນຄ່າແຕ່ລະເດືອນ
            depreciation_record = {
                'aldm_id': record.get('aldm_id', ''),
                'dpca_year': record.get('dpca_year', 0),
                'dpca_month': record.get('dpca_month', 0),
                'dpca_date': record.get('dpca_date'),
                'dpca_desc': record.get('dpca_desc', ''),
                'dpca_value': safe_float_conversion(record.get('dpca_value', 0)),
                'remaining_value': safe_float_conversion(record.get('remaining_value', 0)),
                'accumulated_dpca': safe_float_conversion(record.get('accumulated_dpca', 0)),
                'dpca_no_of_days': record.get('dpca_no_of_days', 0),
                'dpca_ac_yesno': record.get('dpca_ac_yesno', ''),
                'Auth_Status': record.get('Auth_Status', ''),
                'Maker_Id': record.get('Maker_Id_id', record.get('Maker_Id', '')),
                'Maker_DT_Stamp': record.get('Maker_DT_Stamp')
            }
            
            grouped[asset_id]['depreciation_records'].append(depreciation_record)
        
        # ຄິດໄລ່ສະຫຼຸບສຳລັບແຕ່ລະຊັບສິນ
        for asset_id, asset_data in grouped.items():
            records = asset_data['depreciation_records']
            
            if not records:
                continue
            
            # ຈັດເລຽງຕາມວັນທີ່ (ຖ້າມີ)
            records_with_date = [r for r in records if r.get('dpca_date')]
            if records_with_date:
                try:
                    records.sort(key=lambda x: x['dpca_date'] if x.get('dpca_date') else '')
                except Exception as e:
                    logger.warning(f"Cannot sort records by date: {str(e)}")
            
            # ຄິດໄລ່ສະຫຼຸບ
            total_depreciation = sum(r['dpca_value'] for r in records if r['dpca_value'])
            latest_remaining = records[-1]['remaining_value'] if records else 0
            latest_accumulated = records[-1]['accumulated_dpca'] if records else 0
            
            asset_data['summary'] = {
                'total_periods': len(records),
                'total_depreciation_amount': total_depreciation,
                'latest_remaining_value': latest_remaining,
                'latest_accumulated_depreciation': latest_accumulated,
                'first_depreciation_date': records[0]['dpca_date'] if records else None,
                'last_depreciation_date': records[-1]['dpca_date'] if records else None,
                'average_monthly_depreciation': total_depreciation / len(records) if records and total_depreciation > 0 else 0
            }
        
        return dict(grouped)
        
    except Exception as e:
        logger.error(f"Error in group_depreciation_data_by_asset: {str(e)}")
        return {}


def format_grouped_response(grouped_data):
    """
    ຈັດຮູບແບບ response ສຳລັບ API (ປັບປຸງແລ້ວ)
    """
    if not grouped_data:
        return {
            'success': True,
            'grouped_by': 'asset_list_id',
            'data': [],
            'grand_totals': {
                'total_assets': 0,
                'total_depreciation_records': 0,
                'total_depreciation_amount': 0.0,
                'total_remaining_value': 0.0
            }
        }
    
    try:
        formatted_assets = []
        
        for asset_id, asset_data in grouped_data.items():
            formatted_asset = {
                **asset_data['asset_info'],
                'depreciation_schedule': asset_data['depreciation_records'],
                'depreciation_summary': asset_data['summary']
            }
            formatted_assets.append(formatted_asset)
        
        # ຄິດໄລ່ສະຫຼຸບລວມທັງໝົດ
        grand_totals = {
            'total_assets': len(formatted_assets),
            'total_depreciation_records': sum(len(asset.get('depreciation_schedule', [])) for asset in formatted_assets),
            'total_depreciation_amount': sum(asset.get('depreciation_summary', {}).get('total_depreciation_amount', 0) for asset in formatted_assets),
            'total_remaining_value': sum(asset.get('depreciation_summary', {}).get('latest_remaining_value', 0) for asset in formatted_assets)
        }
        
        return {
            'success': True,
            'grouped_by': 'asset_list_id',
            'data': formatted_assets,
            'grand_totals': grand_totals
        }
        
    except Exception as e:
        logger.error(f"Error in format_grouped_response: {str(e)}")
        return {
            'success': False,
            'error': f'Error formatting response: {str(e)}',
            'data': []
        }


def calculate_asset_totals(assets):
    """
    ຄິດໄລ່ຍອດລວມສຳລັບແບບບໍ່ຈັດກຸ່ມ
    """
    if not assets:
        return {
            'total_count': 0,
            'total_asset_value': 0.0,
            'total_depreciation_value': 0.0,
            'total_remaining_value': 0.0,
            'total_accumulated_depreciation': 0.0
        }
    
    try:
        return {
            'total_count': len(assets),
            'total_asset_value': sum(safe_float_conversion(asset.get('asset_value', 0)) for asset in assets),
            'total_depreciation_value': sum(safe_float_conversion(asset.get('dpca_value', 0)) for asset in assets),
            'total_remaining_value': sum(safe_float_conversion(asset.get('remaining_value', 0)) for asset in assets),
            'total_accumulated_depreciation': sum(safe_float_conversion(asset.get('accumulated_dpca', 0)) for asset in assets)
        }
    except Exception as e:
        logger.error(f"Error calculating totals: {str(e)}")
        return {
            'total_count': len(assets) if assets else 0,
            'total_asset_value': 0.0,
            'total_depreciation_value': 0.0,
            'total_remaining_value': 0.0,
            'total_accumulated_depreciation': 0.0
        }


# ສົມມຸດວ່າມີຟັງຊັນນີ້ຢູ່ແລ້ວ - ເພີ່ມ error handling
def get_asset_depreciation_report(asset_list_id=None, division_id=None, asset_type_id=None, 
                                asset_status=None, start_date=None, end_date=None):
    """
    ເອີ້ນ Stored Procedure ເພື່ອດຶງຂໍ້ມູນ
    """
    try:
        # ໃສ່ໂຄດເອີ້ນ stored procedure ຂອງທ່ານທີ່ນີ້
        # ຕົວຢ່າງ:
        from django.db import connection
        
        with connection.cursor() as cursor:
            cursor.execute("""
                EXEC Asset_List_GetAllList_Depreciation_Monthly 
                %s, %s, %s, %s, %s, %s
            """, [asset_list_id, asset_type_id, asset_status, division_id, start_date, end_date])
            
            columns = [col[0] for col in cursor.description]
            results = [dict(zip(columns, row)) for row in cursor.fetchall()]
            
        return results
        
    except Exception as e:
        logger.error(f"Error in get_asset_depreciation_report: {str(e)}")
        return []


class AssetDepreciationReportView(View):
    """API View ສຳລັບບົດລາຍງານການຫຼຸດມູນຄ່າຊັບສິນ - ເວີຊັນປັບປຸງ"""
    
    def get(self, request):
        try:
           
            asset_list_id = request.GET.get('asset_list_id', '').strip()
            asset_type_id = request.GET.get('asset_type_id', '').strip() or request.GET.get('type', '').strip()
            division_id = request.GET.get('division_id', '').strip()
            asset_status = request.GET.get('asset_status', '').strip() or request.GET.get('status', '').strip()
            start_date_str = request.GET.get('start_date', '').strip() or request.GET.get('start', '').strip()
            end_date_str = request.GET.get('end_date', '').strip() or request.GET.get('end', '').strip()
            group_by = request.GET.get('group_by', 'asset').strip().lower()
            
            # ປັບແຕ່ງ empty strings ເປັນ None
            asset_list_id = asset_list_id if asset_list_id else None
            asset_type_id = asset_type_id if asset_type_id else None
            division_id = division_id if division_id else None
            asset_status = asset_status if asset_status else None
            
            # ປັບແຕ່ງວັນທີ່
            start_date = parse_date_parameter(start_date_str)
            end_date = parse_date_parameter(end_date_str)
            
            logger.info(f"Asset depreciation request - Filters: asset_id={asset_list_id}, "
                       f"type={asset_type_id}, status={asset_status}, division={division_id}, "
                       f"dates={start_date} to {end_date}, group_by={group_by}")
            
            # ດຶງຂໍ້ມູນຈາກ Stored Procedure
            assets = get_asset_depreciation_report(
                asset_list_id=asset_list_id,
                division_id=division_id,
                asset_type_id=asset_type_id,
                asset_status=asset_status,
                start_date=start_date,
                end_date=end_date
            )
            
            logger.info(f"Retrieved {len(assets)} records from database")
            
            
            if group_by == 'asset' and assets:
                grouped_data = group_depreciation_data_by_asset(assets)
                response_data = format_grouped_response(grouped_data)
                
                response_data.update({
                    'filters': {
                        'asset_list_id': asset_list_id,
                        'asset_type_id': asset_type_id,
                        'asset_status': asset_status,
                        'start_date': start_date_str,
                        'division_id': division_id,
                        'end_date': end_date_str,
                        'group_by': group_by
                    },
                    'message': f'ພົບຂໍ້ມູນ {len(grouped_data)} ຊັບສິນ'
                })
                
                return JsonResponse(response_data)
            
          
            else:
                totals = calculate_asset_totals(assets)
                return JsonResponse({
                    'success': True,
                    'data': assets,
                    'totals': totals,
                    'filters': {
                        'asset_list_id': asset_list_id,
                        'asset_type_id': asset_type_id,
                        'asset_status': asset_status,
                        'division_id': division_id,
                        'start_date': start_date_str,
                        'end_date': end_date_str,
                        'group_by': group_by or 'none'
                    },
                    'message': f'ພົບຂໍ້ມູນ {len(assets)} ລາຍການ'
                })
                
        except Exception as e:
            logger.error(f"Error in AssetDepreciationReportView: {str(e)}", exc_info=True)
            return JsonResponse({
                'success': False,
                'error': f'ເກີດຂໍ້ຜິດພາດໃນລະບົບ: {str(e)}',
                'data': [],
                'message': 'ກະລຸນາກວດສອບ log ສຳລັບລາຍລະອຽດ'
            }, status=500)
    
    def post(self, request):
        """ສຳລັບ POST request ຖ້າຈຳເປັນ"""
        return JsonResponse({
            'success': False,
            'error': 'Method not allowed. Use GET request.'
        }, status=405)